"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow-models";
exports.ids = ["vendor-chunks/@tensorflow-models"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tensorflow-models/body-pix/dist/body-pix.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tensorflow-models/body-pix/dist/body-pix.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BodyPix: () => (/* binding */ BodyPix),\n/* harmony export */   PART_CHANNELS: () => (/* binding */ PART_CHANNELS),\n/* harmony export */   blurBodyPart: () => (/* binding */ blurBodyPart),\n/* harmony export */   drawBokehEffect: () => (/* binding */ drawBokehEffect),\n/* harmony export */   drawMask: () => (/* binding */ drawMask),\n/* harmony export */   drawPixelatedMask: () => (/* binding */ drawPixelatedMask),\n/* harmony export */   flipPoseHorizontal: () => (/* binding */ flipPoseHorizontal),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   resizeAndPadTo: () => (/* binding */ resizeAndPadTo),\n/* harmony export */   scaleAndCropToInputTensorShape: () => (/* binding */ scaleAndCropToInputTensorShape),\n/* harmony export */   toColoredPartMask: () => (/* binding */ toColoredPartMask),\n/* harmony export */   toMask: () => (/* binding */ toMask),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-converter */ \"(ssr)/./node_modules/@tensorflow/tfjs-converter/dist/index.js\");\n/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/index.js\");\n/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Takes the sigmoid of the part heatmap output and generates a 2d one-hot\n * tensor with ones where the part's score has the maximum value.\n *\n * @param partHeatmapScores\n */\nfunction toFlattenedOneHotPartMap(partHeatmapScores) {\n    var numParts = partHeatmapScores.shape[2];\n    var partMapLocations = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.argMax(partHeatmapScores, 2);\n    var partMapFlattened = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.reshape(partMapLocations, [-1]);\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.oneHot(partMapFlattened, numParts);\n}\nfunction clipByMask2d(image, mask) {\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(image, mask);\n}\n/**\n * Takes the sigmoid of the segmentation output, and generates a segmentation\n * mask with a 1 or 0 at each pixel where there is a person or not a person. The\n * segmentation threshold determines the threshold of a score for a pixel for it\n * to be considered part of a person.\n * @param segmentScores A 3d-tensor of the sigmoid of the segmentation output.\n * @param segmentationThreshold The minimum that segmentation values must have\n * to be considered part of the person.  Affects the generation of the\n * segmentation mask and the clipping of the colored part image.\n *\n * @returns A segmentation mask with a 1 or 0 at each pixel where there is a\n * person or not a person.\n */\nfunction toMaskTensor(segmentScores, threshold) {\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.greater(segmentScores, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.scalar(threshold)), 'int32');\n    });\n}\n/**\n * Takes the sigmoid of the person and part map output, and returns a 2d tensor\n * of an image with the corresponding value at each pixel corresponding to the\n * part with the highest value. These part ids are clipped by the segmentation\n * mask. Wherever the a pixel is clipped by the segmentation mask, its value\n * will set to -1, indicating that there is no part in that pixel.\n * @param segmentScores A 3d-tensor of the sigmoid of the segmentation output.\n * @param partHeatmapScores A 3d-tensor of the sigmoid of the part heatmap\n * output. The third dimension corresponds to the part.\n *\n * @returns A 2d tensor of an image with the corresponding value at each pixel\n * corresponding to the part with the highest value. These part ids are clipped\n * by the segmentation mask.  It will have values of -1 for pixels that are\n * outside of the body and do not have a corresponding part.\n */\nfunction decodePartSegmentation(segmentationMask, partHeatmapScores) {\n    var _a = partHeatmapScores.shape, partMapHeight = _a[0], partMapWidth = _a[1], numParts = _a[2];\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n        var partNumbers = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.expandDims(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.range(0, numParts, 1, 'int32'), 1);\n        var partMapFlattened = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.matMul(flattenedMap, partNumbers), 'int32');\n        var partMap = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.reshape(partMapFlattened, [partMapHeight, partMapWidth]);\n        var partMapShiftedUpForClipping = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.add(partMap, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.scalar(1, 'int32'));\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(clipByMask2d(partMapShiftedUpForClipping, segmentationMask), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.scalar(1, 'int32'));\n    });\n}\nfunction decodeOnlyPartSegmentation(partHeatmapScores) {\n    var _a = partHeatmapScores.shape, partMapHeight = _a[0], partMapWidth = _a[1], numParts = _a[2];\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n        var partNumbers = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.expandDims(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.range(0, numParts, 1, 'int32'), 1);\n        var partMapFlattened = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.matMul(flattenedMap, partNumbers), 'int32');\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.reshape(partMapFlattened, [partMapHeight, partMapWidth]);\n    });\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * BodyPix supports using various convolution neural network models\n * (e.g. ResNet and MobileNetV1) as its underlying base model.\n * The following BaseModel interface defines a unified interface for\n * creating such BodyPix base models. Currently both MobileNet (in\n * ./mobilenet.ts) and ResNet (in ./resnet.ts) implements the BaseModel\n * interface. New base models that conform to the BaseModel interface can be\n * added to BodyPix.\n */\nvar BaseModel = /** @class */ (function () {\n    function BaseModel(model, outputStride) {\n        this.model = model;\n        this.outputStride = outputStride;\n        var inputShape = this.model.inputs[0].shape;\n        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.assert((inputShape[1] === -1) && (inputShape[2] === -1), function () { return \"Input shape [\".concat(inputShape[1], \", \").concat(inputShape[2], \"] \") +\n            \"must both be equal to or -1\"; });\n    }\n    /**\n     * Predicts intermediate Tensor representations.\n     *\n     * @param input The input RGB image of the base model.\n     * A Tensor of shape: [`inputResolution`, `inputResolution`, 3].\n     *\n     * @return A dictionary of base model's intermediate predictions.\n     * The returned dictionary should contains the following elements:\n     * - heatmapScores: A Tensor3D that represents the keypoint heatmap scores.\n     * - offsets: A Tensor3D that represents the offsets.\n     * - displacementFwd: A Tensor3D that represents the forward displacement.\n     * - displacementBwd: A Tensor3D that represents the backward displacement.\n     * - segmentation: A Tensor3D that represents the segmentation of all\n     * people.\n     * - longOffsets: A Tensor3D that represents the long offsets used for\n     * instance grouping.\n     * - partHeatmaps: A Tensor3D that represents the body part segmentation.\n     */\n    BaseModel.prototype.predict = function (input) {\n        var _this = this;\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n            var asFloat = _this.preprocessInput(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(input, 'float32'));\n            var asBatch = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.expandDims(asFloat, 0);\n            var results = _this.model.predict(asBatch);\n            var results3d = results.map(function (y) { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(y, [0]); });\n            var namedResults = _this.nameOutputResults(results3d);\n            return {\n                heatmapScores: _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sigmoid(namedResults.heatmap),\n                offsets: namedResults.offsets,\n                displacementFwd: namedResults.displacementFwd,\n                displacementBwd: namedResults.displacementBwd,\n                segmentation: namedResults.segmentation,\n                partHeatmaps: namedResults.partHeatmaps,\n                longOffsets: namedResults.longOffsets,\n                partOffsets: namedResults.partOffsets\n            };\n        });\n    };\n    /**\n     * Releases the CPU and GPU memory allocated by the model.\n     */\n    BaseModel.prototype.dispose = function () {\n        this.model.dispose();\n    };\n    return BaseModel;\n}());\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar MobileNet = /** @class */ (function (_super) {\n    __extends(MobileNet, _super);\n    function MobileNet() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MobileNet.prototype.preprocessInput = function (input) {\n        // Normalize the pixels [0, 255] to be between [-1, 1].\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.div(input, 127.5), 1.0); });\n    };\n    MobileNet.prototype.nameOutputResults = function (results) {\n        var offsets = results[0], segmentation = results[1], partHeatmaps = results[2], longOffsets = results[3], heatmap = results[4], displacementFwd = results[5], displacementBwd = results[6], partOffsets = results[7];\n        return {\n            offsets: offsets,\n            segmentation: segmentation,\n            partHeatmaps: partHeatmaps,\n            longOffsets: longOffsets,\n            heatmap: heatmap,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            partOffsets: partOffsets\n        };\n    };\n    return MobileNet;\n}(BaseModel));\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar PART_NAMES = [\n    'nose', 'leftEye', 'rightEye', 'leftEar', 'rightEar', 'leftShoulder',\n    'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist',\n    'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'\n];\nvar NUM_KEYPOINTS = PART_NAMES.length;\nvar PART_IDS = PART_NAMES.reduce(function (result, jointName, i) {\n    result[jointName] = i;\n    return result;\n}, {});\nvar CONNECTED_PART_NAMES = [\n    ['leftHip', 'leftShoulder'], ['leftElbow', 'leftShoulder'],\n    ['leftElbow', 'leftWrist'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['rightHip', 'rightShoulder'],\n    ['rightElbow', 'rightShoulder'], ['rightElbow', 'rightWrist'],\n    ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'],\n    ['leftShoulder', 'rightShoulder'], ['leftHip', 'rightHip']\n];\n/*\n * Define the skeleton. This defines the parent->child relationships of our\n * tree. Arbitrarily this defines the nose as the root of the tree, however\n * since we will infer the displacement for both parent->child and\n * child->parent, we can define the tree root as any node.\n */\nvar POSE_CHAIN = [\n    ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n    ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n    ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n    ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n    ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n    ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n    ['rightKnee', 'rightAnkle']\n];\nCONNECTED_PART_NAMES.map(function (_a) {\n    var jointNameA = _a[0], jointNameB = _a[1];\n    return ([PART_IDS[jointNameA], PART_IDS[jointNameB]]);\n});\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction getScale(_a, _b, padding) {\n    var height = _a[0], width = _a[1];\n    var inputResolutionY = _b[0], inputResolutionX = _b[1];\n    var padT = padding.top, padB = padding.bottom, padL = padding.left, padR = padding.right;\n    var scaleY = inputResolutionY / (padT + padB + height);\n    var scaleX = inputResolutionX / (padL + padR + width);\n    return [scaleX, scaleY];\n}\nfunction getOffsetPoint(y, x, keypoint, offsets) {\n    return {\n        y: offsets.get(y, x, keypoint),\n        x: offsets.get(y, x, keypoint + NUM_KEYPOINTS)\n    };\n}\nfunction getImageCoords(part, outputStride, offsets) {\n    var heatmapY = part.heatmapY, heatmapX = part.heatmapX, keypoint = part.id;\n    var _a = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets), y = _a.y, x = _a.x;\n    return {\n        x: part.heatmapX * outputStride + x,\n        y: part.heatmapY * outputStride + y\n    };\n}\nfunction clamp(a, min, max) {\n    if (a < min) {\n        return min;\n    }\n    if (a > max) {\n        return max;\n    }\n    return a;\n}\nfunction squaredDistance(y1, x1, y2, x2) {\n    var dy = y2 - y1;\n    var dx = x2 - x1;\n    return dy * dy + dx * dx;\n}\nfunction addVectors(a, b) {\n    return { x: a.x + b.x, y: a.y + b.y };\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction computeDistance(embedding, pose, minPartScore) {\n    if (minPartScore === void 0) { minPartScore = 0.3; }\n    var distance = 0.0;\n    var numKpt = 0;\n    for (var p = 0; p < embedding.length; p++) {\n        if (pose.keypoints[p].score > minPartScore) {\n            numKpt += 1;\n            distance += Math.pow((embedding[p].x - pose.keypoints[p].position.x), 2) +\n                Math.pow((embedding[p].y - pose.keypoints[p].position.y), 2);\n        }\n    }\n    if (numKpt === 0) {\n        distance = Infinity;\n    }\n    else {\n        distance = distance / numKpt;\n    }\n    return distance;\n}\nfunction convertToPositionInOuput(position, _a, _b, stride) {\n    var padT = _a[0], padL = _a[1];\n    var scaleX = _b[0], scaleY = _b[1];\n    var y = Math.round(((padT + position.y + 1.0) * scaleY - 1.0) / stride);\n    var x = Math.round(((padL + position.x + 1.0) * scaleX - 1.0) / stride);\n    return { x: x, y: y };\n}\nfunction getEmbedding(location, keypointIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, _a) {\n    var height = _a[0], width = _a[1];\n    var newLocation = convertToPosition(location);\n    var nn = newLocation.y * outputResolutionX + newLocation.x;\n    var dy = longOffsets[NUM_KEYPOINTS * (2 * nn) + keypointIndex];\n    var dx = longOffsets[NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];\n    var y = location.y + dy;\n    var x = location.x + dx;\n    for (var t = 0; t < refineSteps; t++) {\n        y = Math.min(y, height - 1);\n        x = Math.min(x, width - 1);\n        var newPos = convertToPosition({ x: x, y: y });\n        var nn_1 = newPos.y * outputResolutionX + newPos.x;\n        dy = longOffsets[NUM_KEYPOINTS * (2 * nn_1) + keypointIndex];\n        dx = longOffsets[NUM_KEYPOINTS * (2 * nn_1 + 1) + keypointIndex];\n        y = y + dy;\n        x = x + dx;\n    }\n    return { x: x, y: y };\n}\nfunction matchEmbeddingToInstance(location, longOffsets, poses, numKptForMatching, _a, _b, outputResolutionX, _c, stride, refineSteps) {\n    var padT = _a[0], padL = _a[1];\n    var scaleX = _b[0], scaleY = _b[1];\n    var height = _c[0], width = _c[1];\n    var embed = [];\n    var convertToPosition = function (pair) {\n        return convertToPositionInOuput(pair, [padT, padL], [scaleX, scaleY], stride);\n    };\n    for (var keypointsIndex = 0; keypointsIndex < numKptForMatching; keypointsIndex++) {\n        var embedding = getEmbedding(location, keypointsIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, [height, width]);\n        embed.push(embedding);\n    }\n    var kMin = -1;\n    var kMinDist = Infinity;\n    for (var k = 0; k < poses.length; k++) {\n        var dist = computeDistance(embed, poses[k]);\n        if (dist < kMinDist) {\n            kMin = k;\n            kMinDist = dist;\n        }\n    }\n    return kMin;\n}\nfunction getOutputResolution(_a, stride) {\n    var inputResolutionY = _a[0], inputResolutionX = _a[1];\n    var outputResolutionX = Math.round((inputResolutionX - 1.0) / stride + 1.0);\n    var outputResolutionY = Math.round((inputResolutionY - 1.0) / stride + 1.0);\n    return [outputResolutionX, outputResolutionY];\n}\nfunction decodeMultipleMasksCPU(segmentation, longOffsets, posesAboveScore, height, width, stride, _a, padding, refineSteps, numKptForMatching) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (numKptForMatching === void 0) { numKptForMatching = 5; }\n    var dataArrays = posesAboveScore.map(function (x) { return new Uint8Array(height * width).fill(0); });\n    var padT = padding.top, padL = padding.left;\n    var _b = getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];\n    var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];\n    for (var i = 0; i < height; i += 1) {\n        for (var j = 0; j < width; j += 1) {\n            var n = i * width + j;\n            var prob = segmentation[n];\n            if (prob === 1) {\n                var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);\n                if (kMin >= 0) {\n                    dataArrays[kMin][n] = 1;\n                }\n            }\n        }\n    }\n    return dataArrays;\n}\nfunction decodeMultiplePartMasksCPU(segmentation, longOffsets, partSegmentaion, posesAboveScore, height, width, stride, _a, padding, refineSteps, numKptForMatching) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (numKptForMatching === void 0) { numKptForMatching = 5; }\n    var dataArrays = posesAboveScore.map(function (x) { return new Int32Array(height * width).fill(-1); });\n    var padT = padding.top, padL = padding.left;\n    var _b = getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];\n    var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];\n    for (var i = 0; i < height; i += 1) {\n        for (var j = 0; j < width; j += 1) {\n            var n = i * width + j;\n            var prob = segmentation[n];\n            if (prob === 1) {\n                var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);\n                if (kMin >= 0) {\n                    dataArrays[kMin][n] = partSegmentaion[n];\n                }\n            }\n        }\n    }\n    return dataArrays;\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, _a, padding, refineSteps, minKptScore, maxNumPeople) {\n    var inHeight = _a[0], inWidth = _a[1];\n    // The height/width of the image/canvas itself.\n    var _b = segmentation.shape, origHeight = _b[0], origWidth = _b[1];\n    // The height/width of the output of the model.\n    var _c = longOffsets.shape.slice(0, 2), outHeight = _c[0], outWidth = _c[1];\n    var shapedLongOffsets = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.reshape(longOffsets, [outHeight, outWidth, 2, NUM_KEYPOINTS]);\n    // Make pose tensor of shape [MAX_NUM_PEOPLE, NUM_KEYPOINTS, 3] where\n    // the last 3 coordinates correspond to the score, h and w coordinate of that\n    // keypoint.\n    var poseVals = new Float32Array(maxNumPeople * NUM_KEYPOINTS * 3).fill(0.0);\n    for (var i = 0; i < posesAboveScore.length; i++) {\n        var poseOffset = i * NUM_KEYPOINTS * 3;\n        var pose = posesAboveScore[i];\n        for (var kp = 0; kp < NUM_KEYPOINTS; kp++) {\n            var keypoint = pose.keypoints[kp];\n            var offset = poseOffset + kp * 3;\n            poseVals[offset] = keypoint.score;\n            poseVals[offset + 1] = keypoint.position.y;\n            poseVals[offset + 2] = keypoint.position.x;\n        }\n    }\n    var _d = getScale([height, width], [inHeight, inWidth], padding), scaleX = _d[0], scaleY = _d[1];\n    var posesTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tensor(poseVals, [maxNumPeople, NUM_KEYPOINTS, 3]);\n    var padT = padding.top, padL = padding.left;\n    var program = {\n        variableNames: ['segmentation', 'longOffsets', 'poses'],\n        outputShape: [origHeight, origWidth],\n        userCode: \"\\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\\n    }\\n\\n    float convertToPositionInOutputFloat(\\n        int pos, int pad, float scale, int stride) {\\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\\n    }\\n\\n    float dist(float x1, float y1, float x2, float y2) {\\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\\n    }\\n\\n    float sampleLongOffsets(float h, float w, int d, int k) {\\n      float fh = fract(h);\\n      float fw = fract(w);\\n      int clH = int(ceil(h));\\n      int clW = int(ceil(w));\\n      int flH = int(floor(h));\\n      int flW = int(floor(w));\\n      float o11 = getLongOffsets(flH, flW, d, k);\\n      float o12 = getLongOffsets(flH, clW, d, k);\\n      float o21 = getLongOffsets(clH, flW, d, k);\\n      float o22 = getLongOffsets(clH, clW, d, k);\\n      float o1 = mix(o11, o12, fw);\\n      float o2 = mix(o21, o22, fw);\\n      return mix(o1, o2, fh);\\n    }\\n\\n    int findNearestPose(int h, int w) {\\n      float prob = getSegmentation(h, w);\\n      if (prob < 1.0) {\\n        return -1;\\n      }\\n\\n      // Done(Tyler): convert from output space h/w to strided space.\\n      float stridedH = convertToPositionInOutputFloat(\\n        h, \".concat(padT, \", \").concat(scaleY, \", \").concat(stride, \");\\n      float stridedW = convertToPositionInOutputFloat(\\n        w, \").concat(padL, \", \").concat(scaleX, \", \").concat(stride, \");\\n\\n      float minDist = 1000000.0;\\n      int iMin = -1;\\n      for (int i = 0; i < \").concat(maxNumPeople, \"; i++) {\\n        float curDistSum = 0.0;\\n        int numKpt = 0;\\n        for (int k = 0; k < \").concat(NUM_KEYPOINTS, \"; k++) {\\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\\n\\n          float y = float(h) + dy;\\n          float x = float(w) + dx;\\n\\n          for (int s = 0; s < \").concat(refineSteps, \"; s++) {\\n            int yRounded = round(min(y, float(\").concat(height - 1.0, \")));\\n            int xRounded = round(min(x, float(\").concat(width - 1.0, \")));\\n\\n            float yStrided = convertToPositionInOutputFloat(\\n              yRounded, \").concat(padT, \", \").concat(scaleY, \", \").concat(stride, \");\\n            float xStrided = convertToPositionInOutputFloat(\\n              xRounded, \").concat(padL, \", \").concat(scaleX, \", \").concat(stride, \");\\n\\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\\n\\n            y = y + dy;\\n            x = x + dx;\\n          }\\n\\n          float poseScore = getPoses(i, k, 0);\\n          float poseY = getPoses(i, k, 1);\\n          float poseX = getPoses(i, k, 2);\\n          if (poseScore > \").concat(minKptScore, \") {\\n            numKpt = numKpt + 1;\\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\\n          }\\n        }\\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\\n          minDist = curDistSum / float(numKpt);\\n          iMin = i;\\n        }\\n      }\\n      return iMin;\\n    }\\n\\n    void main() {\\n        ivec2 coords = getOutputCoords();\\n        int nearestPose = findNearestPose(coords[0], coords[1]);\\n        setOutput(float(nearestPose));\\n      }\\n  \")\n    };\n    var webglBackend = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.backend();\n    return webglBackend.compileAndRun(program, [segmentation, shapedLongOffsets, posesTensor]);\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction toPersonKSegmentation(segmentation, k) {\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.equal(segmentation, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.scalar(k)), 'int32'); });\n}\nfunction toPersonKPartSegmentation(segmentation, bodyParts, k) {\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () { return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sub(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.mul(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.cast(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.equal(segmentation, _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.scalar(k)), 'int32'), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.add(bodyParts, 1)), 1); });\n}\nfunction isWebGlBackend() {\n    return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.getBackend)() === 'webgl';\n}\nfunction decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, stride, _a, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (minPoseScore === void 0) { minPoseScore = 0.2; }\n    if (refineSteps === void 0) { refineSteps = 8; }\n    if (minKeypointScore === void 0) { minKeypointScore = 0.3; }\n    if (maxNumPeople === void 0) { maxNumPeople = 10; }\n    return __awaiter(this, void 0, void 0, function () {\n        var posesAboveScore, personSegmentationsData, personSegmentations, segmentationsData, longOffsetsData;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    posesAboveScore = poses.filter(function (pose) { return pose.score >= minPoseScore; });\n                    if (!isWebGlBackend()) return [3 /*break*/, 2];\n                    personSegmentations = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                        var masksTensorInfo = decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);\n                        var masksTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.engine().makeTensorFromDataId(masksTensorInfo.dataId, masksTensorInfo.shape, masksTensorInfo.dtype);\n                        return posesAboveScore.map(function (_, k) { return toPersonKSegmentation(masksTensor, k); });\n                    });\n                    return [4 /*yield*/, Promise.all(personSegmentations.map(function (mask) { return mask.data(); }))];\n                case 1:\n                    personSegmentationsData =\n                        (_b.sent());\n                    personSegmentations.forEach(function (x) { return x.dispose(); });\n                    return [3 /*break*/, 5];\n                case 2: return [4 /*yield*/, segmentation.data()];\n                case 3:\n                    segmentationsData = _b.sent();\n                    return [4 /*yield*/, longOffsets.data()];\n                case 4:\n                    longOffsetsData = _b.sent();\n                    personSegmentationsData = decodeMultipleMasksCPU(segmentationsData, longOffsetsData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);\n                    _b.label = 5;\n                case 5: return [2 /*return*/, personSegmentationsData.map(function (data, i) { return ({ data: data, pose: posesAboveScore[i], width: width, height: height }); })];\n            }\n        });\n    });\n}\nfunction decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, stride, _a, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (minPoseScore === void 0) { minPoseScore = 0.2; }\n    if (refineSteps === void 0) { refineSteps = 8; }\n    if (minKeypointScore === void 0) { minKeypointScore = 0.3; }\n    if (maxNumPeople === void 0) { maxNumPeople = 10; }\n    return __awaiter(this, void 0, void 0, function () {\n        var posesAboveScore, partSegmentationsByPersonData, partSegmentations, segmentationsData, longOffsetsData, partSegmentaionData;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    posesAboveScore = poses.filter(function (pose) { return pose.score >= minPoseScore; });\n                    if (!isWebGlBackend()) return [3 /*break*/, 2];\n                    partSegmentations = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                        var masksTensorInfo = decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);\n                        var masksTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.engine().makeTensorFromDataId(masksTensorInfo.dataId, masksTensorInfo.shape, masksTensorInfo.dtype);\n                        return posesAboveScore.map(function (_, k) {\n                            return toPersonKPartSegmentation(masksTensor, partSegmentation, k);\n                        });\n                    });\n                    return [4 /*yield*/, Promise.all(partSegmentations.map(function (x) { return x.data(); }))];\n                case 1:\n                    partSegmentationsByPersonData =\n                        (_b.sent());\n                    partSegmentations.forEach(function (x) { return x.dispose(); });\n                    return [3 /*break*/, 6];\n                case 2: return [4 /*yield*/, segmentation.data()];\n                case 3:\n                    segmentationsData = _b.sent();\n                    return [4 /*yield*/, longOffsets.data()];\n                case 4:\n                    longOffsetsData = _b.sent();\n                    return [4 /*yield*/, partSegmentation.data()];\n                case 5:\n                    partSegmentaionData = _b.sent();\n                    partSegmentationsByPersonData = decodeMultiplePartMasksCPU(segmentationsData, longOffsetsData, partSegmentaionData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);\n                    _b.label = 6;\n                case 6: return [2 /*return*/, partSegmentationsByPersonData.map(function (data, k) { return ({ pose: posesAboveScore[k], data: data, height: height, width: width }); })];\n            }\n        });\n    });\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// algorithm based on Coursera Lecture from Algorithms, Part 1:\n// https://www.coursera.org/learn/algorithms-part1/lecture/ZjoSM/heapsort\nfunction half(k) {\n    return Math.floor(k / 2);\n}\nvar MaxHeap = /** @class */ (function () {\n    function MaxHeap(maxSize, getElementValue) {\n        this.priorityQueue = new Array(maxSize);\n        this.numberOfElements = -1;\n        this.getElementValue = getElementValue;\n    }\n    MaxHeap.prototype.enqueue = function (x) {\n        this.priorityQueue[++this.numberOfElements] = x;\n        this.swim(this.numberOfElements);\n    };\n    MaxHeap.prototype.dequeue = function () {\n        var max = this.priorityQueue[0];\n        this.exchange(0, this.numberOfElements--);\n        this.sink(0);\n        this.priorityQueue[this.numberOfElements + 1] = null;\n        return max;\n    };\n    MaxHeap.prototype.empty = function () {\n        return this.numberOfElements === -1;\n    };\n    MaxHeap.prototype.size = function () {\n        return this.numberOfElements + 1;\n    };\n    MaxHeap.prototype.all = function () {\n        return this.priorityQueue.slice(0, this.numberOfElements + 1);\n    };\n    MaxHeap.prototype.max = function () {\n        return this.priorityQueue[0];\n    };\n    MaxHeap.prototype.swim = function (k) {\n        while (k > 0 && this.less(half(k), k)) {\n            this.exchange(k, half(k));\n            k = half(k);\n        }\n    };\n    MaxHeap.prototype.sink = function (k) {\n        while (2 * k <= this.numberOfElements) {\n            var j = 2 * k;\n            if (j < this.numberOfElements && this.less(j, j + 1)) {\n                j++;\n            }\n            if (!this.less(k, j)) {\n                break;\n            }\n            this.exchange(k, j);\n            k = j;\n        }\n    };\n    MaxHeap.prototype.getValueAt = function (i) {\n        return this.getElementValue(this.priorityQueue[i]);\n    };\n    MaxHeap.prototype.less = function (i, j) {\n        return this.getValueAt(i) < this.getValueAt(j);\n    };\n    MaxHeap.prototype.exchange = function (i, j) {\n        var t = this.priorityQueue[i];\n        this.priorityQueue[i] = this.priorityQueue[j];\n        this.priorityQueue[j] = t;\n    };\n    return MaxHeap;\n}());\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores) {\n    var _a = scores.shape, height = _a[0], width = _a[1];\n    var localMaximum = true;\n    var yStart = Math.max(heatmapY - localMaximumRadius, 0);\n    var yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);\n    for (var yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {\n        var xStart = Math.max(heatmapX - localMaximumRadius, 0);\n        var xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);\n        for (var xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {\n            if (scores.get(yCurrent, xCurrent, keypointId) > score) {\n                localMaximum = false;\n                break;\n            }\n        }\n        if (!localMaximum) {\n            break;\n        }\n    }\n    return localMaximum;\n}\n/**\n * Builds a priority queue with part candidate positions for a specific image in\n * the batch. For this we find all local maxima in the score maps with score\n * values above a threshold. We create a single priority queue across all parts.\n */\nfunction buildPartWithScoreQueue(scoreThreshold, localMaximumRadius, scores) {\n    var _a = scores.shape, height = _a[0], width = _a[1], numKeypoints = _a[2];\n    var queue = new MaxHeap(height * width * numKeypoints, function (_a) {\n        var score = _a.score;\n        return score;\n    });\n    for (var heatmapY = 0; heatmapY < height; ++heatmapY) {\n        for (var heatmapX = 0; heatmapX < width; ++heatmapX) {\n            for (var keypointId = 0; keypointId < numKeypoints; ++keypointId) {\n                var score = scores.get(heatmapY, heatmapX, keypointId);\n                // Only consider parts with score greater or equal to threshold as\n                // root candidates.\n                if (score < scoreThreshold) {\n                    continue;\n                }\n                // Only consider keypoints whose score is maximum in a local window.\n                if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores)) {\n                    queue.enqueue({ score: score, part: { heatmapY: heatmapY, heatmapX: heatmapX, id: keypointId } });\n                }\n            }\n        }\n    }\n    return queue;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar parentChildrenTuples = POSE_CHAIN.map(function (_a) {\n    var parentJoinName = _a[0], childJoinName = _a[1];\n    return ([PART_IDS[parentJoinName], PART_IDS[childJoinName]]);\n});\nvar parentToChildEdges = parentChildrenTuples.map(function (_a) {\n    var childJointId = _a[1];\n    return childJointId;\n});\nvar childToParentEdges = parentChildrenTuples.map(function (_a) {\n    var parentJointId = _a[0];\n    return parentJointId;\n});\nfunction getDisplacement(edgeId, point, displacements) {\n    var numEdges = displacements.shape[2] / 2;\n    return {\n        y: displacements.get(point.y, point.x, edgeId),\n        x: displacements.get(point.y, point.x, numEdges + edgeId)\n    };\n}\nfunction getStridedIndexNearPoint(point, outputStride, height, width) {\n    return {\n        y: clamp(Math.round(point.y / outputStride), 0, height - 1),\n        x: clamp(Math.round(point.x / outputStride), 0, width - 1)\n    };\n}\n/**\n * We get a new keypoint along the `edgeId` for the pose instance, assuming\n * that the position of the `idSource` part is already known. For this, we\n * follow the displacement vector from the source to target part (stored in\n * the `i`-t channel of the displacement tensor). The displaced keypoint\n * vector is refined using the offset vector by `offsetRefineStep` times.\n */\nfunction traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements, offsetRefineStep) {\n    if (offsetRefineStep === void 0) { offsetRefineStep = 2; }\n    var _a = scoresBuffer.shape, height = _a[0], width = _a[1];\n    // Nearest neighbor interpolation for the source->target displacements.\n    var sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, outputStride, height, width);\n    var displacement = getDisplacement(edgeId, sourceKeypointIndices, displacements);\n    var displacedPoint = addVectors(sourceKeypoint.position, displacement);\n    var targetKeypoint = displacedPoint;\n    for (var i = 0; i < offsetRefineStep; i++) {\n        var targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n        var offsetPoint = getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId, offsets);\n        targetKeypoint = addVectors({\n            x: targetKeypointIndices.x * outputStride,\n            y: targetKeypointIndices.y * outputStride\n        }, { x: offsetPoint.x, y: offsetPoint.y });\n    }\n    var targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n    var score = scoresBuffer.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);\n    return { position: targetKeypoint, part: PART_NAMES[targetKeypointId], score: score };\n}\n/**\n * Follows the displacement fields to decode the full pose of the object\n * instance given the position of a part that acts as root.\n *\n * @return An array of decoded keypoints and their scores for a single pose\n */\nfunction decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {\n    var numParts = scores.shape[2];\n    var numEdges = parentToChildEdges.length;\n    var instanceKeypoints = new Array(numParts);\n    // Start a new detection instance at the position of the root.\n    var rootPart = root.part, rootScore = root.score;\n    var rootPoint = getImageCoords(rootPart, outputStride, offsets);\n    instanceKeypoints[rootPart.id] = {\n        score: rootScore,\n        part: PART_NAMES[rootPart.id],\n        position: rootPoint\n    };\n    // Decode the part positions upwards in the tree, following the backward\n    // displacements.\n    for (var edge = numEdges - 1; edge >= 0; --edge) {\n        var sourceKeypointId = parentToChildEdges[edge];\n        var targetKeypointId = childToParentEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);\n        }\n    }\n    // Decode the part positions downwards in the tree, following the forward\n    // displacements.\n    for (var edge = 0; edge < numEdges; ++edge) {\n        var sourceKeypointId = childToParentEdges[edge];\n        var targetKeypointId = parentToChildEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);\n        }\n    }\n    return instanceKeypoints;\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, _a, keypointId) {\n    var x = _a.x, y = _a.y;\n    return poses.some(function (_a) {\n        var keypoints = _a.keypoints;\n        var correspondingKeypoint = keypoints[keypointId].position;\n        return squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\n            squaredNmsRadius;\n    });\n}\n/* Score the newly proposed object instance without taking into account\n * the scores of the parts that overlap with any previously detected\n * instance.\n */\nfunction getInstanceScore(existingPoses, squaredNmsRadius, instanceKeypoints) {\n    var notOverlappedKeypointScores = instanceKeypoints.reduce(function (result, _a, keypointId) {\n        var position = _a.position, score = _a.score;\n        if (!withinNmsRadiusOfCorrespondingPoint(existingPoses, squaredNmsRadius, position, keypointId)) {\n            result += score;\n        }\n        return result;\n    }, 0.0);\n    return notOverlappedKeypointScores /= instanceKeypoints.length;\n}\n// A point (y, x) is considered as root part candidate if its score is a\n// maximum in a window |y - y'| <= kLocalMaximumRadius, |x - x'| <=\n// kLocalMaximumRadius.\nvar kLocalMaximumRadius = 1;\n/**\n * Detects multiple poses and finds their parts from part scores and\n * displacement vectors. It returns up to `maxDetections` object instance\n * detections in decreasing root score order. It works as follows: We first\n * create a priority queue with local part score maxima above\n * `scoreThreshold`, considering all parts at the same time. Then we\n * iteratively pull the top  element of the queue (in decreasing score order)\n * and treat it as a root candidate for a new object instance. To avoid\n * duplicate detections, we reject the root candidate if it is within a disk\n * of `nmsRadius` pixels from the corresponding part of a previously detected\n * instance, which is a form of part-based non-maximum suppression (NMS). If\n * the root candidate passes the NMS check, we start a new object instance\n * detection, treating the corresponding part as root and finding the\n * positions of the remaining parts by following the displacement vectors\n * along the tree-structured part graph. We assign to the newly detected\n * instance a score equal to the sum of scores of its parts which have not\n * been claimed by a previous instance (i.e., those at least `nmsRadius`\n * pixels away from the corresponding part of all previously detected\n * instances), divided by the total number of parts `numParts`.\n *\n * @param heatmapScores 3-D tensor with shape `[height, width, numParts]`.\n * The value of heatmapScores[y, x, k]` is the score of placing the `k`-th\n * object part at position `(y, x)`.\n *\n * @param offsets 3-D tensor with shape `[height, width, numParts * 2]`.\n * The value of [offsets[y, x, k], offsets[y, x, k + numParts]]` is the\n * short range offset vector of the `k`-th  object part at heatmap\n * position `(y, x)`.\n *\n * @param displacementsFwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the forward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param displacementsBwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the backward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param outputStride The output stride that was used when feed-forwarding\n * through the PoseNet model.  Must be 32, 16, or 8.\n *\n * @param maxPoseDetections Maximum number of returned instance detections per\n * image.\n *\n * @param scoreThreshold Only return instance detections that have root part\n * score greater or equal to this value. Defaults to 0.5.\n *\n * @param nmsRadius Non-maximum suppression part distance. It needs to be\n * strictly positive. Two parts suppress each other if they are less than\n * `nmsRadius` pixels away. Defaults to 20.\n *\n * @return An array of poses and their scores, each containing keypoints and\n * the corresponding keypoint scores.\n */\nfunction decodeMultiplePoses(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, outputStride, maxPoseDetections, scoreThreshold, nmsRadius) {\n    if (scoreThreshold === void 0) { scoreThreshold = 0.5; }\n    if (nmsRadius === void 0) { nmsRadius = 20; }\n    var poses = [];\n    var queue = buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius, scoresBuffer);\n    var squaredNmsRadius = nmsRadius * nmsRadius;\n    // Generate at most maxDetections object instances per image in\n    // decreasing root part score order.\n    while (poses.length < maxPoseDetections && !queue.empty()) {\n        // The top element in the queue is the next root candidate.\n        var root = queue.dequeue();\n        // Part-based non-maximum suppression: We reject a root candidate if it\n        // is within a disk of `nmsRadius` pixels from the corresponding part of\n        // a previously detected instance.\n        var rootImageCoords = getImageCoords(root.part, outputStride, offsetsBuffer);\n        if (withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\n            continue;\n        }\n        // Start a new detection instance at the position of the root.\n        var keypoints = decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);\n        var score = getInstanceScore(poses, squaredNmsRadius, keypoints);\n        poses.push({ keypoints: keypoints, score: score });\n    }\n    return poses;\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar imageNetMean = [-123.15, -115.90, -103.06];\nvar ResNet = /** @class */ (function (_super) {\n    __extends(ResNet, _super);\n    function ResNet() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResNet.prototype.preprocessInput = function (input) {\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.add(input, imageNetMean);\n    };\n    ResNet.prototype.nameOutputResults = function (results) {\n        var displacementBwd = results[0], displacementFwd = results[1], heatmap = results[2], longOffsets = results[3], offsets = results[4], partHeatmaps = results[5], segmentation = results[6], partOffsets = results[7];\n        return {\n            offsets: offsets,\n            segmentation: segmentation,\n            partHeatmaps: partHeatmaps,\n            longOffsets: longOffsets,\n            heatmap: heatmap,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            partOffsets: partOffsets\n        };\n    };\n    return ResNet;\n}(BaseModel));\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar RESNET50_BASE_URL = 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/';\nvar MOBILENET_BASE_URL = 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/';\n// The BodyPix 2.0 ResNet50 models use the latest TensorFlow.js 1.0 model\n// format.\nfunction resNet50SavedModel(stride, quantBytes) {\n    var graphJson = \"model-stride\".concat(stride, \".json\");\n    // quantBytes=4 corresponding to the non-quantized full-precision SavedModel.\n    if (quantBytes === 4) {\n        return RESNET50_BASE_URL + \"float/\" + graphJson;\n    }\n    else {\n        return RESNET50_BASE_URL + \"quant\".concat(quantBytes, \"/\") + graphJson;\n    }\n}\n// The BodyPix 2.0 MobileNetV1 models use the latest TensorFlow.js 1.0 model\n// format.\nfunction mobileNetSavedModel(stride, multiplier, quantBytes) {\n    var toStr = { 1.0: '100', 0.75: '075', 0.50: '050' };\n    var graphJson = \"model-stride\".concat(stride, \".json\");\n    // quantBytes=4 corresponding to the non-quantized full-precision SavedModel.\n    if (quantBytes === 4) {\n        return MOBILENET_BASE_URL + \"float/\".concat(toStr[multiplier], \"/\") + graphJson;\n    }\n    else {\n        return MOBILENET_BASE_URL + \"quant\".concat(quantBytes, \"/\").concat(toStr[multiplier], \"/\") +\n            graphJson;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nvar _a;\nfunction getSizeFromImageLikeElement(input) {\n    if ('offsetHeight' in input && input.offsetHeight !== 0\n        && 'offsetWidth' in input && input.offsetWidth !== 0) {\n        return [input.offsetHeight, input.offsetWidth];\n    }\n    else if (input.height != null && input.width != null) {\n        return [input.height, input.width];\n    }\n    else {\n        throw new Error(\"HTMLImageElement must have height and width attributes set.\");\n    }\n}\nfunction getSizeFromVideoElement(input) {\n    if (input.hasAttribute('height') && input.hasAttribute('width')) {\n        // Prioritizes user specified height and width.\n        // We can't test the .height and .width properties directly,\n        // because they evaluate to 0 if unset.\n        return [input.height, input.width];\n    }\n    else {\n        return [input.videoHeight, input.videoWidth];\n    }\n}\nfunction getInputSize(input) {\n    if ((typeof (HTMLCanvasElement) !== 'undefined' &&\n        input instanceof HTMLCanvasElement) ||\n        (typeof (OffscreenCanvas) !== 'undefined' &&\n            input instanceof OffscreenCanvas) ||\n        (typeof (HTMLImageElement) !== 'undefined' &&\n            input instanceof HTMLImageElement)) {\n        return getSizeFromImageLikeElement(input);\n    }\n    else if (typeof (ImageData) !== 'undefined' && input instanceof ImageData) {\n        return [input.height, input.width];\n    }\n    else if (typeof (HTMLVideoElement) !== 'undefined' &&\n        input instanceof HTMLVideoElement) {\n        return getSizeFromVideoElement(input);\n    }\n    else if (input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n        return [input.shape[0], input.shape[1]];\n    }\n    else {\n        throw new Error(\"error: Unknown input type: \".concat(input, \".\"));\n    }\n}\nfunction isValidInputResolution(resolution, outputStride) {\n    return (resolution - 1) % outputStride === 0;\n}\nfunction toValidInputResolution(inputResolution, outputStride) {\n    if (isValidInputResolution(inputResolution, outputStride)) {\n        return inputResolution;\n    }\n    return Math.floor(inputResolution / outputStride) * outputStride + 1;\n}\nvar INTERNAL_RESOLUTION_STRING_OPTIONS = {\n    low: 'low',\n    medium: 'medium',\n    high: 'high',\n    full: 'full'\n};\nvar INTERNAL_RESOLUTION_PERCENTAGES = (_a = {},\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.low] = 0.25,\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.medium] = 0.5,\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.high] = 0.75,\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.full] = 1.0,\n    _a);\nvar MIN_INTERNAL_RESOLUTION = 0.1;\nvar MAX_INTERNAL_RESOLUTION = 2.0;\nfunction toInternalResolutionPercentage(internalResolution) {\n    if (typeof internalResolution === 'string') {\n        var result = INTERNAL_RESOLUTION_PERCENTAGES[internalResolution];\n        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.assert(typeof result === 'number', function () { return \"string value of inputResolution must be one of \".concat(Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS)\n            .join(','), \" but was \").concat(internalResolution, \".\"); });\n        return result;\n    }\n    else {\n        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.util.assert(typeof internalResolution === 'number' &&\n            internalResolution <= MAX_INTERNAL_RESOLUTION &&\n            internalResolution >= MIN_INTERNAL_RESOLUTION, function () {\n            return \"inputResolution must be a string or number between \".concat(MIN_INTERNAL_RESOLUTION, \" and \").concat(MAX_INTERNAL_RESOLUTION, \", but \") +\n                \"was \".concat(internalResolution);\n        });\n        return internalResolution;\n    }\n}\nfunction toInputResolutionHeightAndWidth(internalResolution, outputStride, _a) {\n    var inputHeight = _a[0], inputWidth = _a[1];\n    var internalResolutionPercentage = toInternalResolutionPercentage(internalResolution);\n    return [\n        toValidInputResolution(inputHeight * internalResolutionPercentage, outputStride),\n        toValidInputResolution(inputWidth * internalResolutionPercentage, outputStride)\n    ];\n}\nfunction toInputTensor(input) {\n    // TODO: tf.browser.fromPixels types to support OffscreenCanvas\n    // @ts-ignore\n    return input instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.Tensor ? input : _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.browser.fromPixels(input);\n}\nfunction resizeAndPadTo(imageTensor, _a, flipHorizontal) {\n    var targetH = _a[0], targetW = _a[1];\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var _b = imageTensor.shape, height = _b[0], width = _b[1];\n    var targetAspect = targetW / targetH;\n    var aspect = width / height;\n    var resizeW;\n    var resizeH;\n    var padL;\n    var padR;\n    var padT;\n    var padB;\n    if (aspect > targetAspect) {\n        // resize to have the larger dimension match the shape.\n        resizeW = targetW;\n        resizeH = Math.ceil(resizeW / aspect);\n        var padHeight = targetH - resizeH;\n        padL = 0;\n        padR = 0;\n        padT = Math.floor(padHeight / 2);\n        padB = targetH - (resizeH + padT);\n    }\n    else {\n        resizeH = targetH;\n        resizeW = Math.ceil(targetH * aspect);\n        var padWidth = targetW - resizeW;\n        padL = Math.floor(padWidth / 2);\n        padR = targetW - (resizeW + padL);\n        padT = 0;\n        padB = 0;\n    }\n    var resizedAndPadded = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        // resize to have largest dimension match image\n        var resized;\n        if (flipHorizontal) {\n            resized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image.resizeBilinear(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.reverse(imageTensor, 1), [resizeH, resizeW]);\n        }\n        else {\n            resized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image.resizeBilinear(imageTensor, [resizeH, resizeW]);\n        }\n        var padded = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.pad3d(resized, [[padT, padB], [padL, padR], [0, 0]]);\n        return padded;\n    });\n    return { resizedAndPadded: resizedAndPadded, paddedBy: [[padT, padB], [padL, padR]] };\n}\nfunction scaleAndCropToInputTensorShape(tensor, _a, _b, _c, applySigmoidActivation) {\n    var inputTensorHeight = _a[0], inputTensorWidth = _a[1];\n    var resizedAndPaddedHeight = _b[0], resizedAndPaddedWidth = _b[1];\n    var _d = _c[0], padT = _d[0], padB = _d[1], _e = _c[1], padL = _e[0], padR = _e[1];\n    if (applySigmoidActivation === void 0) { applySigmoidActivation = false; }\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        var inResizedAndPadded = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image.resizeBilinear(tensor, [resizedAndPaddedHeight, resizedAndPaddedWidth], true);\n        if (applySigmoidActivation) {\n            inResizedAndPadded = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.sigmoid(inResizedAndPadded);\n        }\n        return removePaddingAndResizeBack(inResizedAndPadded, [inputTensorHeight, inputTensorWidth], [[padT, padB], [padL, padR]]);\n    });\n}\nfunction removePaddingAndResizeBack(resizedAndPadded, _a, _b) {\n    var originalHeight = _a[0], originalWidth = _a[1];\n    var _c = _b[0], padT = _c[0], padB = _c[1], _d = _b[1], padL = _d[0], padR = _d[1];\n    return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        var batchedImage = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.expandDims(resizedAndPadded);\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image\n            .cropAndResize(batchedImage, [[\n                padT / (originalHeight + padT + padB - 1.0),\n                padL / (originalWidth + padL + padR - 1.0),\n                (padT + originalHeight - 1.0) /\n                    (originalHeight + padT + padB - 1.0),\n                (padL + originalWidth - 1.0) / (originalWidth + padL + padR - 1.0)\n            ]], [0], [originalHeight, originalWidth]), [0]);\n    });\n}\nfunction padAndResizeTo(input, _a) {\n    var targetH = _a[0], targetW = _a[1];\n    var _b = getInputSize(input), height = _b[0], width = _b[1];\n    var targetAspect = targetW / targetH;\n    var aspect = width / height;\n    var _c = [0, 0, 0, 0], padT = _c[0], padB = _c[1], padL = _c[2], padR = _c[3];\n    if (aspect < targetAspect) {\n        // pads the width\n        padT = 0;\n        padB = 0;\n        padL = Math.round(0.5 * (targetAspect * height - width));\n        padR = Math.round(0.5 * (targetAspect * height - width));\n    }\n    else {\n        // pads the height\n        padT = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n        padB = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n        padL = 0;\n        padR = 0;\n    }\n    var resized = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n        var imageTensor = toInputTensor(input);\n        imageTensor = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);\n        return _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.image.resizeBilinear(imageTensor, [targetH, targetW]);\n    });\n    return { resized: resized, padding: { top: padT, left: padL, right: padR, bottom: padB } };\n}\nfunction toTensorBuffers3D(tensors) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, Promise.all(tensors.map(function (tensor) { return tensor.buffer(); }))];\n        });\n    });\n}\nfunction scalePose(pose, scaleY, scaleX, offsetY, offsetX) {\n    if (offsetY === void 0) { offsetY = 0; }\n    if (offsetX === void 0) { offsetX = 0; }\n    return {\n        score: pose.score,\n        keypoints: pose.keypoints.map(function (_a) {\n            var score = _a.score, part = _a.part, position = _a.position;\n            return ({\n                score: score,\n                part: part,\n                position: {\n                    x: position.x * scaleX + offsetX,\n                    y: position.y * scaleY + offsetY\n                }\n            });\n        })\n    };\n}\nfunction scalePoses(poses, scaleY, scaleX, offsetY, offsetX) {\n    if (offsetY === void 0) { offsetY = 0; }\n    if (offsetX === void 0) { offsetX = 0; }\n    if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {\n        return poses;\n    }\n    return poses.map(function (pose) { return scalePose(pose, scaleY, scaleX, offsetY, offsetX); });\n}\nfunction flipPoseHorizontal(pose, imageWidth) {\n    return {\n        score: pose.score,\n        keypoints: pose.keypoints.map(function (_a) {\n            var score = _a.score, part = _a.part, position = _a.position;\n            return ({\n                score: score,\n                part: part,\n                position: { x: imageWidth - 1 - position.x, y: position.y }\n            });\n        })\n    };\n}\nfunction flipPosesHorizontal(poses, imageWidth) {\n    if (imageWidth <= 0) {\n        return poses;\n    }\n    return poses.map(function (pose) { return flipPoseHorizontal(pose, imageWidth); });\n}\nfunction scaleAndFlipPoses(poses, _a, _b, padding, flipHorizontal) {\n    var height = _a[0], width = _a[1];\n    var inputResolutionHeight = _b[0], inputResolutionWidth = _b[1];\n    var scaleY = (height + padding.top + padding.bottom) / (inputResolutionHeight);\n    var scaleX = (width + padding.left + padding.right) / (inputResolutionWidth);\n    var scaledPoses = scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);\n    if (flipHorizontal) {\n        return flipPosesHorizontal(scaledPoses, width);\n    }\n    else {\n        return scaledPoses;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar APPLY_SIGMOID_ACTIVATION = true;\nvar FLIP_POSES_AFTER_SCALING = false;\n// The default configuration for loading MobileNetV1 based BodyPix.\n//\n// (And for references, the default configuration for loading ResNet\n// based PoseNet is also included).\n//\n// ```\n// const RESNET_CONFIG = {\n//   architecture: 'ResNet50',\n//   outputStride: 32,\n//   quantBytes: 4,\n// } as ModelConfig;\n// ```\nvar MOBILENET_V1_CONFIG = {\n    architecture: 'MobileNetV1',\n    outputStride: 16,\n    quantBytes: 4,\n    multiplier: 0.75,\n};\nvar VALID_ARCHITECTURE = ['MobileNetV1', 'ResNet50'];\nvar VALID_STRIDE = {\n    'MobileNetV1': [8, 16, 32],\n    'ResNet50': [32, 16]\n};\nvar VALID_MULTIPLIER = {\n    'MobileNetV1': [0.50, 0.75, 1.0],\n    'ResNet50': [1.0]\n};\nvar VALID_QUANT_BYTES = [1, 2, 4];\nfunction validateModelConfig(config) {\n    config = config || MOBILENET_V1_CONFIG;\n    if (config.architecture == null) {\n        config.architecture = 'MobileNetV1';\n    }\n    if (VALID_ARCHITECTURE.indexOf(config.architecture) < 0) {\n        throw new Error(\"Invalid architecture \".concat(config.architecture, \". \") +\n            \"Should be one of \".concat(VALID_ARCHITECTURE));\n    }\n    if (config.outputStride == null) {\n        config.outputStride = 16;\n    }\n    if (VALID_STRIDE[config.architecture].indexOf(config.outputStride) < 0) {\n        throw new Error(\"Invalid outputStride \".concat(config.outputStride, \". \") +\n            \"Should be one of \".concat(VALID_STRIDE[config.architecture], \" \") +\n            \"for architecture \".concat(config.architecture, \".\"));\n    }\n    if (config.multiplier == null) {\n        config.multiplier = 1.0;\n    }\n    if (VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier) < 0) {\n        throw new Error(\"Invalid multiplier \".concat(config.multiplier, \". \") +\n            \"Should be one of \".concat(VALID_MULTIPLIER[config.architecture], \" \") +\n            \"for architecture \".concat(config.architecture, \".\"));\n    }\n    if (config.quantBytes == null) {\n        config.quantBytes = 4;\n    }\n    if (VALID_QUANT_BYTES.indexOf(config.quantBytes) < 0) {\n        throw new Error(\"Invalid quantBytes \".concat(config.quantBytes, \". \") +\n            \"Should be one of \".concat(VALID_QUANT_BYTES, \" \") +\n            \"for architecture \".concat(config.architecture, \".\"));\n    }\n    return config;\n}\nvar PERSON_INFERENCE_CONFIG = {\n    flipHorizontal: false,\n    internalResolution: 'medium',\n    segmentationThreshold: 0.7,\n    maxDetections: 10,\n    scoreThreshold: 0.4,\n    nmsRadius: 20,\n};\nvar MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = {\n    flipHorizontal: false,\n    internalResolution: 'medium',\n    segmentationThreshold: 0.7,\n    maxDetections: 10,\n    scoreThreshold: 0.4,\n    nmsRadius: 20,\n    minKeypointScore: 0.3,\n    refineSteps: 10\n};\nfunction validatePersonInferenceConfig(config) {\n    var segmentationThreshold = config.segmentationThreshold, maxDetections = config.maxDetections, scoreThreshold = config.scoreThreshold, nmsRadius = config.nmsRadius;\n    if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n        throw new Error(\"segmentationThreshold \".concat(segmentationThreshold, \". \") +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (maxDetections <= 0) {\n        throw new Error(\"Invalid maxDetections \".concat(maxDetections, \". \") +\n            \"Should be > 0\");\n    }\n    if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n        throw new Error(\"Invalid scoreThreshold \".concat(scoreThreshold, \". \") +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (nmsRadius <= 0) {\n        throw new Error(\"Invalid nmsRadius \".concat(nmsRadius, \".\"));\n    }\n}\nfunction validateMultiPersonInstanceInferenceConfig(config) {\n    var segmentationThreshold = config.segmentationThreshold, maxDetections = config.maxDetections, scoreThreshold = config.scoreThreshold, nmsRadius = config.nmsRadius, minKeypointScore = config.minKeypointScore, refineSteps = config.refineSteps;\n    if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n        throw new Error(\"segmentationThreshold \".concat(segmentationThreshold, \". \") +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (maxDetections <= 0) {\n        throw new Error(\"Invalid maxDetections \".concat(maxDetections, \". \") +\n            \"Should be > 0\");\n    }\n    if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n        throw new Error(\"Invalid scoreThreshold \".concat(scoreThreshold, \". \") +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (nmsRadius <= 0) {\n        throw new Error(\"Invalid nmsRadius \".concat(nmsRadius, \".\"));\n    }\n    if (minKeypointScore < 0 || minKeypointScore > 1) {\n        throw new Error(\"Invalid minKeypointScore \".concat(minKeypointScore, \".\") +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (refineSteps <= 0 || refineSteps > 20) {\n        throw new Error(\"Invalid refineSteps \".concat(refineSteps, \".\") +\n            \"Should be in range [1, 20]\");\n    }\n}\nvar BodyPix = /** @class */ (function () {\n    function BodyPix(net) {\n        this.baseModel = net;\n    }\n    BodyPix.prototype.predictForPersonSegmentation = function (input) {\n        var _a = this.baseModel.predict(input), segmentation = _a.segmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n        return {\n            segmentLogits: segmentation,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n        };\n    };\n    BodyPix.prototype.predictForPersonSegmentationAndPart = function (input) {\n        var _a = this.baseModel.predict(input), segmentation = _a.segmentation, partHeatmaps = _a.partHeatmaps, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n        return {\n            segmentLogits: segmentation,\n            partHeatmapLogits: partHeatmaps,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n        };\n    };\n    BodyPix.prototype.predictForMultiPersonInstanceSegmentationAndPart = function (input) {\n        var _a = this.baseModel.predict(input), segmentation = _a.segmentation, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, partHeatmaps = _a.partHeatmaps;\n        return {\n            segmentLogits: segmentation,\n            longOffsets: longOffsets,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            partHeatmaps: partHeatmaps\n        };\n    };\n    /**\n     * Given an image with people, returns a dictionary of all intermediate\n     * tensors including: 1) a binary array with 1 for the pixels that are part of\n     * the person, and 0 otherwise, 2) heatmapScores, 3) offsets, and 4) paddings.\n     *\n     * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n     * The input image to feed through the network.\n     *\n     * @param internalResolution Defaults to 'medium'. The internal resolution\n     * that the input is resized to before inference. The larger the\n     * internalResolution the more accurate the model at the cost of slower\n     * prediction times. Available values are 'low', 'medium', 'high', 'full', or\n     * a percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n     * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n     *\n     * @param segmentationThreshold The minimum that segmentation values must have\n     * to be considered part of the person. Affects the generation of the\n     * segmentation mask.\n     *\n     * @return A dictionary containing `segmentation`, `heatmapScores`, `offsets`,\n     * and `padding`:\n     * - `segmentation`: A 2d Tensor with 1 for the pixels that are part of the\n     * person, and 0 otherwise. The width and height correspond to the same\n     * dimensions of the input image.\n     * - `heatmapScores`: A 3d Tensor of the keypoint heatmaps used by\n     * pose estimation decoding.\n     * - `offsets`: A 3d Tensor of the keypoint offsets used by pose\n     * estimation decoding.\n     * - `displacementFwd`: A 3d Tensor of the keypoint forward displacement used\n     * by pose estimation decoding.\n     * - `displacementBwd`: A 3d Tensor of the keypoint backward displacement used\n     * by pose estimation decoding.\n     * - `padding`: The padding (unit pixels) being applied to the input image\n     * before it is fed into the model.\n     */\n    BodyPix.prototype.segmentPersonActivation = function (input, internalResolution, segmentationThreshold) {\n        var _this = this;\n        if (segmentationThreshold === void 0) { segmentationThreshold = 0.5; }\n        var _a = getInputSize(input), height = _a[0], width = _a[1];\n        var internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);\n        var _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n        var _c = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n            var _a = _this.predictForPersonSegmentation(resized), segmentLogits = _a.segmentLogits, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n            var _b = resized.shape, resizedHeight = _b[0], resizedWidth = _b[1];\n            var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n            return {\n                segmentation: toMaskTensor(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(scaledSegmentScores), segmentationThreshold),\n                heatmapScores: heatmapScores,\n                offsets: offsets,\n                displacementFwd: displacementFwd,\n                displacementBwd: displacementBwd,\n            };\n        }), segmentation = _c.segmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;\n        resized.dispose();\n        return {\n            segmentation: segmentation,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            padding: padding,\n            internalResolutionHeightAndWidth: internalResolutionHeightAndWidth\n        };\n    };\n    /**\n     * Given an image with many people, returns a PersonSegmentation dictionary\n     * that contains the segmentation mask for all people and a single pose.\n     *\n     * Note: The segmentation mask returned by this method covers all people but\n     * the pose works well for one person. If you want to estimate instance-level\n     * multiple person segmentation & pose for each person, use\n     * `segmentMultiPerson` instead.\n     *\n     * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n     * The input image to feed through the network.\n     *\n     * @param config PersonInferenceConfig object that contains\n     * parameters for the BodyPix inference using person decoding.\n     *\n     * @return A SemanticPersonSegmentation dictionary that contains height,\n     * width, the flattened binary segmentation mask and the poses for all people.\n     * The width and height correspond to the same dimensions of the input image.\n     * - `height`: The height of the segmentation data in pixel unit.\n     * - `width`: The width of the segmentation data in pixel unit.\n     * - `data`: The flattened Uint8Array of segmentation data. 1 means the pixel\n     * belongs to a person and 0 means the pixel doesn't belong to a person. The\n     * size of the array is equal to `height` x `width` in row-major order.\n     * - `allPoses`: The 2d poses of all people.\n     */\n    BodyPix.prototype.segmentPerson = function (input, config) {\n        if (config === void 0) { config = PERSON_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, segmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, result, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        config = __assign(__assign({}, PERSON_INFERENCE_CONFIG), config);\n                        validatePersonInferenceConfig(config);\n                        _a = this.segmentPersonActivation(input, config.internalResolution, config.segmentationThreshold), segmentation = _a.segmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding, internalResolutionHeightAndWidth = _a.internalResolutionHeightAndWidth;\n                        _b = segmentation.shape, height = _b[0], width = _b[1];\n                        return [4 /*yield*/, segmentation.data()];\n                    case 1:\n                        result = _c.sent();\n                        segmentation.dispose();\n                        return [4 /*yield*/, toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];\n                    case 2:\n                        tensorBuffers = _c.sent();\n                        scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];\n                        poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        heatmapScores.dispose();\n                        offsets.dispose();\n                        displacementFwd.dispose();\n                        displacementBwd.dispose();\n                        return [2 /*return*/, { height: height, width: width, data: result, allPoses: poses }];\n                }\n            });\n        });\n    };\n    /**\n     * Given an image with multiple people, returns an *array* of\n     * PersonSegmentation object. Each element in the array corresponding to one\n     * of the people in the input image. In other words, it predicts\n     * instance-level multiple person segmentation & pose for each person.\n     *\n     * The model does standard ImageNet pre-processing before inferring through\n     * the model. The image pixels should have values [0-255].\n     *\n     * @param input\n     * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n     * image to feed through the network.\n     *\n     * @param config MultiPersonInferenceConfig object that contains\n     * parameters for the BodyPix inference using multi-person decoding.\n     *\n     * @return An array of PersonSegmentation object, each containing a width,\n     * height, a binary array (1 for the pixels that are part of the\n     * person, and 0 otherwise) and 2D pose. The array size corresponds to the\n     * number of pixels in the image. The width and height correspond to the\n     * dimensions of the image the binary array is shaped to, which are the same\n     * dimensions of the input image.\n     */\n    BodyPix.prototype.segmentMultiPerson = function (input, config) {\n        if (config === void 0) { config = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;\n            var _this = this;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        config = __assign(__assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), config);\n                        validateMultiPersonInstanceInferenceConfig(config);\n                        _a = getInputSize(input), height = _a[0], width = _a[1];\n                        internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(config.internalResolution, this.baseModel.outputStride, [height, width]);\n                        _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n                        _c = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                            var _a = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a.segmentLogits, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n                            var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            var scaledLongOffsets;\n                            {\n                                scaledLongOffsets = longOffsets;\n                            }\n                            var segmentation = toMaskTensor(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(scaledSegmentScores), config.segmentationThreshold);\n                            return {\n                                segmentation: segmentation,\n                                longOffsets: scaledLongOffsets,\n                                heatmapScoresRaw: heatmapScores,\n                                offsetsRaw: offsets,\n                                displacementFwdRaw: displacementFwd,\n                                displacementBwdRaw: displacementBwd,\n                            };\n                        }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw;\n                        return [4 /*yield*/, toTensorBuffers3D([heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw])];\n                    case 1:\n                        tensorBuffers = _d.sent();\n                        scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];\n                        poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        return [4 /*yield*/, decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config.scoreThreshold, config.refineSteps, config.minKeypointScore, config.maxDetections)];\n                    case 2:\n                        instanceMasks = _d.sent();\n                        resized.dispose();\n                        segmentation.dispose();\n                        longOffsets.dispose();\n                        heatmapScoresRaw.dispose();\n                        offsetsRaw.dispose();\n                        displacementFwdRaw.dispose();\n                        displacementBwdRaw.dispose();\n                        return [2 /*return*/, instanceMasks];\n                }\n            });\n        });\n    };\n    /**\n     * Given an image with many people, returns a dictionary containing: height,\n     * width, a tensor with a part id from 0-24 for the pixels that are\n     * part of a corresponding body part, and -1 otherwise. This does standard\n     * ImageNet pre-processing before inferring through the model.  The image\n     * should pixels should have values [0-255].\n     *\n     * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n     * The input image to feed through the network.\n     *\n     * @param internalResolution Defaults to 'medium'. The internal resolution\n     * percentage that the input is resized to before inference. The larger the\n     * internalResolution the more accurate the model at the cost of slower\n     * prediction times. Available values are 'low', 'medium', 'high', 'full', or\n     * a percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n     * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n     *\n     * @param segmentationThreshold The minimum that segmentation values must have\n     * to be considered part of the person.  Affects the clipping of the colored\n     * part image.\n     *\n     * @return  A dictionary containing `partSegmentation`, `heatmapScores`,\n     * `offsets`, and `padding`:\n     * - `partSegmentation`: A 2d Tensor with a part id from 0-24 for\n     * the pixels that are part of a corresponding body part, and -1 otherwise.\n     * - `heatmapScores`: A 3d Tensor of the keypoint heatmaps used by\n     * single-person pose estimation decoding.\n     * - `offsets`: A 3d Tensor of the keypoint offsets used by single-person pose\n     * estimation decoding.\n     * - `displacementFwd`: A 3d Tensor of the keypoint forward displacement\n     * used by pose estimation decoding.\n     * - `displacementBwd`: A 3d Tensor of the keypoint backward displacement used\n     * by pose estimation decoding.\n     * - `padding`: The padding (unit pixels) being applied to the input image\n     * before it is fed into the model.\n     */\n    BodyPix.prototype.segmentPersonPartsActivation = function (input, internalResolution, segmentationThreshold) {\n        var _this = this;\n        if (segmentationThreshold === void 0) { segmentationThreshold = 0.5; }\n        var _a = getInputSize(input), height = _a[0], width = _a[1];\n        var internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);\n        var _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n        var _c = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n            var _a = _this.predictForPersonSegmentationAndPart(resized), segmentLogits = _a.segmentLogits, partHeatmapLogits = _a.partHeatmapLogits, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n            var _b = resized.shape, resizedHeight = _b[0], resizedWidth = _b[1];\n            var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n            var scaledPartHeatmapScore = scaleAndCropToInputTensorShape(partHeatmapLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n            var segmentation = toMaskTensor(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(scaledSegmentScores), segmentationThreshold);\n            return {\n                partSegmentation: decodePartSegmentation(segmentation, scaledPartHeatmapScore),\n                heatmapScores: heatmapScores,\n                offsets: offsets,\n                displacementFwd: displacementFwd,\n                displacementBwd: displacementBwd,\n            };\n        }), partSegmentation = _c.partSegmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;\n        resized.dispose();\n        return {\n            partSegmentation: partSegmentation,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            padding: padding,\n            internalResolutionHeightAndWidth: internalResolutionHeightAndWidth\n        };\n    };\n    /**\n     * Given an image with many people, returns a PartSegmentation dictionary that\n     * contains the body part segmentation mask for all people and a single pose.\n     *\n     * Note: The body part segmentation mask returned by this method covers all\n     * people but the pose works well when there is one person. If you want to\n     * estimate instance-level multiple person body part segmentation & pose for\n     * each person, use `segmentMultiPersonParts` instead.\n     *\n     * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n     * The input image to feed through the network.\n     *\n     * @param config PersonInferenceConfig object that contains\n     * parameters for the BodyPix inference using single person decoding.\n     *\n     * @return A SemanticPartSegmentation dictionary that contains height, width,\n     * the flattened binary segmentation mask and the pose for the person. The\n     * width and height correspond to the same dimensions of the input image.\n     * - `height`: The height of the person part segmentation data in pixel unit.\n     * - `width`: The width of the person part segmentation data in pixel unit.\n     * - `data`: The flattened Int32Array of person part segmentation data with a\n     * part id from 0-24 for the pixels that are part of a corresponding body\n     * part, and -1 otherwise. The size of the array is equal to `height` x\n     * `width` in row-major order.\n     * - `allPoses`: The 2d poses of all people.\n     */\n    BodyPix.prototype.segmentPersonParts = function (input, config) {\n        if (config === void 0) { config = PERSON_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, partSegmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, data, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        config = __assign(__assign({}, PERSON_INFERENCE_CONFIG), config);\n                        validatePersonInferenceConfig(config);\n                        _a = this.segmentPersonPartsActivation(input, config.internalResolution, config.segmentationThreshold), partSegmentation = _a.partSegmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding, internalResolutionHeightAndWidth = _a.internalResolutionHeightAndWidth;\n                        _b = partSegmentation.shape, height = _b[0], width = _b[1];\n                        return [4 /*yield*/, partSegmentation.data()];\n                    case 1:\n                        data = _c.sent();\n                        partSegmentation.dispose();\n                        return [4 /*yield*/, toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];\n                    case 2:\n                        tensorBuffers = _c.sent();\n                        scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];\n                        poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        heatmapScores.dispose();\n                        offsets.dispose();\n                        displacementFwd.dispose();\n                        displacementBwd.dispose();\n                        return [2 /*return*/, { height: height, width: width, data: data, allPoses: poses }];\n                }\n            });\n        });\n    };\n    /**\n     * Given an image with multiple people, returns an *array* of PartSegmentation\n     * object. Each element in the array corresponding to one\n     * of the people in the input image. In other words, it predicts\n     * instance-level multiple person body part segmentation & pose for each\n     * person.\n     *\n     * This does standard ImageNet pre-processing before inferring through\n     * the model. The image pixels should have values [0-255].\n     *\n     * @param input\n     * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n     * image to feed through the network.\n     *\n     * @param config MultiPersonInferenceConfig object that contains\n     * parameters for the BodyPix inference using multi-person decoding.\n     *\n     * @return An array of PartSegmentation object, each containing a width,\n     * height, a flattened array (with part id from 0-24 for the pixels that are\n     * part of a corresponding body part, and -1 otherwise) and 2D pose. The width\n     * and height correspond to the dimensions of the image. Each flattened part\n     * segmentation array size is equal to `height` x `width`.\n     */\n    BodyPix.prototype.segmentMultiPersonParts = function (input, config) {\n        if (config === void 0) { config = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, partSegmentation, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;\n            var _this = this;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        config = __assign(__assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), config);\n                        validateMultiPersonInstanceInferenceConfig(config);\n                        _a = getInputSize(input), height = _a[0], width = _a[1];\n                        internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(config.internalResolution, this.baseModel.outputStride, [height, width]);\n                        _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n                        _c = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.tidy(function () {\n                            var _a = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a.segmentLogits, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, partHeatmaps = _a.partHeatmaps;\n                            // decoding with scaling.\n                            var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            // decoding with scaling.\n                            var scaledPartSegmentationScores = scaleAndCropToInputTensorShape(partHeatmaps, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            var scaledLongOffsets = longOffsets;\n                            var segmentation = toMaskTensor(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__.squeeze(scaledSegmentScores), config.segmentationThreshold);\n                            var partSegmentation = decodeOnlyPartSegmentation(scaledPartSegmentationScores);\n                            return {\n                                segmentation: segmentation,\n                                longOffsets: scaledLongOffsets,\n                                heatmapScoresRaw: heatmapScores,\n                                offsetsRaw: offsets,\n                                displacementFwdRaw: displacementFwd,\n                                displacementBwdRaw: displacementBwd,\n                                partSegmentation: partSegmentation\n                            };\n                        }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw, partSegmentation = _c.partSegmentation;\n                        return [4 /*yield*/, toTensorBuffers3D([heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw])];\n                    case 1:\n                        tensorBuffers = _d.sent();\n                        scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];\n                        poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        return [4 /*yield*/, decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config.scoreThreshold, config.refineSteps, config.minKeypointScore, config.maxDetections)];\n                    case 2:\n                        instanceMasks = _d.sent();\n                        resized.dispose();\n                        segmentation.dispose();\n                        longOffsets.dispose();\n                        heatmapScoresRaw.dispose();\n                        offsetsRaw.dispose();\n                        displacementFwdRaw.dispose();\n                        displacementBwdRaw.dispose();\n                        partSegmentation.dispose();\n                        return [2 /*return*/, instanceMasks];\n                }\n            });\n        });\n    };\n    BodyPix.prototype.dispose = function () {\n        this.baseModel.dispose();\n    };\n    return BodyPix;\n}());\n/**\n * Loads the MobileNet BodyPix model.\n */\nfunction loadMobileNet(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var outputStride, quantBytes, multiplier, url, graphModel, mobilenet;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    outputStride = config.outputStride;\n                    quantBytes = config.quantBytes;\n                    multiplier = config.multiplier;\n                    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ == null) {\n                        throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" +\n                            \"also include @tensorflow/tfjs on the page before using this\\n        model.\");\n                    }\n                    url = mobileNetSavedModel(outputStride, multiplier, quantBytes);\n                    return [4 /*yield*/, _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_0__.loadGraphModel(config.modelUrl || url)];\n                case 1:\n                    graphModel = _a.sent();\n                    mobilenet = new MobileNet(graphModel, outputStride);\n                    return [2 /*return*/, new BodyPix(mobilenet)];\n            }\n        });\n    });\n}\n/**\n * Loads the ResNet BodyPix model.\n */\nfunction loadResNet(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var outputStride, quantBytes, url, graphModel, resnet;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    outputStride = config.outputStride;\n                    quantBytes = config.quantBytes;\n                    if (_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_1__ == null) {\n                        throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" +\n                            \"also include @tensorflow/tfjs on the page before using this\\n        model.\");\n                    }\n                    url = resNet50SavedModel(outputStride, quantBytes);\n                    return [4 /*yield*/, _tensorflow_tfjs_converter__WEBPACK_IMPORTED_MODULE_0__.loadGraphModel(config.modelUrl || url)];\n                case 1:\n                    graphModel = _a.sent();\n                    resnet = new ResNet(graphModel, outputStride);\n                    return [2 /*return*/, new BodyPix(resnet)];\n            }\n        });\n    });\n}\n/**\n * Loads the BodyPix model instance from a checkpoint, with the ResNet\n * or MobileNet architecture. The model to be loaded is configurable using the\n * config dictionary ModelConfig. Please find more details in the\n * documentation of the ModelConfig.\n *\n * @param config ModelConfig dictionary that contains parameters for\n * the BodyPix loading process. Please find more details of each parameters\n * in the documentation of the ModelConfig interface. The predefined\n * `MOBILENET_V1_CONFIG` and `RESNET_CONFIG` can also be used as references\n * for defining your customized config.\n */\nfunction load(config) {\n    if (config === void 0) { config = MOBILENET_V1_CONFIG; }\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            config = validateModelConfig(config);\n            if (config.architecture === 'ResNet50') {\n                return [2 /*return*/, loadResNet(config)];\n            }\n            else if (config.architecture === 'MobileNetV1') {\n                return [2 /*return*/, loadMobileNet(config)];\n            }\n            else {\n                return [2 /*return*/, null];\n            }\n        });\n    });\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// method copied from bGlur in https://codepen.io/zhaojun/pen/zZmRQe\nfunction cpuBlur(canvas, image, blur) {\n    var ctx = canvas.getContext('2d');\n    var sum = 0;\n    var delta = 5;\n    var alphaLeft = 1 / (2 * Math.PI * delta * delta);\n    var step = blur < 3 ? 1 : 2;\n    for (var y = -blur; y <= blur; y += step) {\n        for (var x = -blur; x <= blur; x += step) {\n            var weight = alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta));\n            sum += weight;\n        }\n    }\n    for (var y = -blur; y <= blur; y += step) {\n        for (var x = -blur; x <= blur; x += step) {\n            ctx.globalAlpha = alphaLeft *\n                Math.exp(-(x * x + y * y) / (2 * delta * delta)) / sum * blur;\n            ctx.drawImage(image, x, y);\n        }\n    }\n    ctx.globalAlpha = 1;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar offScreenCanvases = {};\nfunction isSafari() {\n    return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent));\n}\nfunction assertSameDimensions(_a, _b, nameA, nameB) {\n    var widthA = _a.width, heightA = _a.height;\n    var widthB = _b.width, heightB = _b.height;\n    if (widthA !== widthB || heightA !== heightB) {\n        throw new Error(\"error: dimensions must match. \".concat(nameA, \" has dimensions \").concat(widthA, \"x\").concat(heightA, \", \").concat(nameB, \" has dimensions \").concat(widthB, \"x\").concat(heightB));\n    }\n}\nfunction flipCanvasHorizontal(canvas) {\n    var ctx = canvas.getContext('2d');\n    ctx.scale(-1, 1);\n    ctx.translate(-canvas.width, 0);\n}\nfunction drawWithCompositing(ctx, image, compositeOperation) {\n    ctx.globalCompositeOperation = compositeOperation;\n    ctx.drawImage(image, 0, 0);\n}\nfunction createOffScreenCanvas() {\n    if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else if (typeof OffscreenCanvas !== 'undefined') {\n        return new OffscreenCanvas(0, 0);\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction ensureOffscreenCanvasCreated(id) {\n    if (!offScreenCanvases[id]) {\n        offScreenCanvases[id] = createOffScreenCanvas();\n    }\n    return offScreenCanvases[id];\n}\nfunction drawAndBlurImageOnCanvas(image, blurAmount, canvas) {\n    var height = image.height, width = image.width;\n    var ctx = canvas.getContext('2d');\n    canvas.width = width;\n    canvas.height = height;\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    if (isSafari()) {\n        cpuBlur(canvas, image, blurAmount);\n    }\n    else {\n        // tslint:disable:no-any\n        ctx.filter = \"blur(\".concat(blurAmount, \"px)\");\n        ctx.drawImage(image, 0, 0, width, height);\n    }\n    ctx.restore();\n}\nfunction drawAndBlurImageOnOffScreenCanvas(image, blurAmount, offscreenCanvasName) {\n    var canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);\n    if (blurAmount === 0) {\n        renderImageToCanvas(image, canvas);\n    }\n    else {\n        drawAndBlurImageOnCanvas(image, blurAmount, canvas);\n    }\n    return canvas;\n}\nfunction renderImageToCanvas(image, canvas) {\n    var width = image.width, height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(image, 0, 0, width, height);\n}\n/**\n * Draw an image on a canvas\n */\nfunction renderImageDataToCanvas(image, canvas) {\n    canvas.width = image.width;\n    canvas.height = image.height;\n    var ctx = canvas.getContext('2d');\n    ctx.putImageData(image, 0, 0);\n}\nfunction renderImageDataToOffScreenCanvas(image, canvasName) {\n    var canvas = ensureOffscreenCanvasCreated(canvasName);\n    renderImageDataToCanvas(image, canvas);\n    return canvas;\n}\n/**\n * Given the output from estimating multi-person segmentation, generates an\n * image with foreground and background color at each pixel determined by the\n * corresponding binary segmentation value at the pixel from the output.  In\n * other words, pixels where there is a person will be colored with foreground\n * color and where there is not a person will be colored with background color.\n *\n * @param personOrPartSegmentation The output from\n * `segmentPerson`, `segmentMultiPerson`,\n * `segmentPersonParts` or `segmentMultiPersonParts`. They can\n * be SemanticPersonSegmentation object, an array of PersonSegmentation object,\n * SemanticPartSegmentation object, or an array of PartSegmentation object.\n *\n * @param foreground Default to {r:0, g:0, b:0, a: 0}. The foreground color\n * (r,g,b,a) for visualizing pixels that belong to people.\n *\n * @param background Default to {r:0, g:0, b:0, a: 255}. The background color\n * (r,g,b,a) for visualizing pixels that don't belong to people.\n *\n * @param drawContour Default to false. Whether to draw the contour around each\n * person's segmentation mask or body part mask.\n *\n * @param foregroundIds Default to [1]. The integer values that represent\n * foreground. For person segmentation, 1 is the foreground. For body part\n * segmentation, it can be a subset of all body parts ids.\n *\n * @returns An ImageData with the same width and height of\n * all the PersonSegmentation in multiPersonSegmentation, with opacity and\n * transparency at each pixel determined by the corresponding binary\n * segmentation value at the pixel from the output.\n */\nfunction toMask(personOrPartSegmentation, foreground, background, drawContour, foregroundIds) {\n    if (foreground === void 0) { foreground = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n    }; }\n    if (background === void 0) { background = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    }; }\n    if (drawContour === void 0) { drawContour = false; }\n    if (foregroundIds === void 0) { foregroundIds = [1]; }\n    if (Array.isArray(personOrPartSegmentation) &&\n        personOrPartSegmentation.length === 0) {\n        return null;\n    }\n    var multiPersonOrPartSegmentation;\n    if (!Array.isArray(personOrPartSegmentation)) {\n        multiPersonOrPartSegmentation = [personOrPartSegmentation];\n    }\n    else {\n        multiPersonOrPartSegmentation = personOrPartSegmentation;\n    }\n    var _a = multiPersonOrPartSegmentation[0], width = _a.width, height = _a.height;\n    var bytes = new Uint8ClampedArray(width * height * 4);\n    function drawStroke(bytes, row, column, width, radius, color) {\n        if (color === void 0) { color = { r: 0, g: 255, b: 255, a: 255 }; }\n        for (var i = -radius; i <= radius; i++) {\n            for (var j = -radius; j <= radius; j++) {\n                if (i !== 0 && j !== 0) {\n                    var n = (row + i) * width + (column + j);\n                    bytes[4 * n + 0] = color.r;\n                    bytes[4 * n + 1] = color.g;\n                    bytes[4 * n + 2] = color.b;\n                    bytes[4 * n + 3] = color.a;\n                }\n            }\n        }\n    }\n    function isSegmentationBoundary(segmentationData, row, column, width, foregroundIds, radius) {\n        if (foregroundIds === void 0) { foregroundIds = [1]; }\n        if (radius === void 0) { radius = 1; }\n        var numberBackgroundPixels = 0;\n        for (var i = -radius; i <= radius; i++) {\n            var _loop_2 = function (j) {\n                if (i !== 0 && j !== 0) {\n                    var n_1 = (row + i) * width + (column + j);\n                    if (!foregroundIds.some(function (id) { return id === segmentationData[n_1]; })) {\n                        numberBackgroundPixels += 1;\n                    }\n                }\n            };\n            for (var j = -radius; j <= radius; j++) {\n                _loop_2(j);\n            }\n        }\n        return numberBackgroundPixels > 0;\n    }\n    for (var i = 0; i < height; i += 1) {\n        var _loop_1 = function (j) {\n            var n = i * width + j;\n            bytes[4 * n + 0] = background.r;\n            bytes[4 * n + 1] = background.g;\n            bytes[4 * n + 2] = background.b;\n            bytes[4 * n + 3] = background.a;\n            var _loop_3 = function (k) {\n                if (foregroundIds.some(function (id) { return id === multiPersonOrPartSegmentation[k].data[n]; })) {\n                    bytes[4 * n] = foreground.r;\n                    bytes[4 * n + 1] = foreground.g;\n                    bytes[4 * n + 2] = foreground.b;\n                    bytes[4 * n + 3] = foreground.a;\n                    var isBoundary = isSegmentationBoundary(multiPersonOrPartSegmentation[k].data, i, j, width, foregroundIds);\n                    if (drawContour && i - 1 >= 0 && i + 1 < height && j - 1 >= 0 &&\n                        j + 1 < width && isBoundary) {\n                        drawStroke(bytes, i, j, width, 1);\n                    }\n                }\n            };\n            for (var k = 0; k < multiPersonOrPartSegmentation.length; k++) {\n                _loop_3(k);\n            }\n        };\n        for (var j = 0; j < width; j += 1) {\n            _loop_1(j);\n        }\n    }\n    return new ImageData(bytes, width, height);\n}\nvar RAINBOW_PART_COLORS = [\n    [110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167],\n    [238, 67, 149], [255, 78, 125], [255, 94, 99], [255, 115, 75],\n    [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64],\n    [175, 240, 91], [135, 245, 87], [96, 247, 96], [64, 243, 115],\n    [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213],\n    [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]\n];\n/**\n * Given the output from person body part segmentation (or multi-person\n * instance body part segmentation) and an array of colors indexed by part id,\n * generates an image with the corresponding color for each part at each pixel,\n * and white pixels where there is no part.\n *\n * @param partSegmentation The output from segmentPersonParts\n * or segmentMultiPersonParts. The former is a SemanticPartSegmentation\n * object and later is an array of PartSegmentation object.\n *\n * @param partColors A multi-dimensional array of rgb colors indexed by\n * part id.  Must have 24 colors, one for every part.\n *\n * @returns An ImageData with the same width and height of all the element in\n * multiPersonPartSegmentation, with the corresponding color for each part at\n * each pixel, and black pixels where there is no part.\n */\nfunction toColoredPartMask(partSegmentation, partColors) {\n    if (partColors === void 0) { partColors = RAINBOW_PART_COLORS; }\n    if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n        return null;\n    }\n    var multiPersonPartSegmentation;\n    if (!Array.isArray(partSegmentation)) {\n        multiPersonPartSegmentation = [partSegmentation];\n    }\n    else {\n        multiPersonPartSegmentation = partSegmentation;\n    }\n    var _a = multiPersonPartSegmentation[0], width = _a.width, height = _a.height;\n    var bytes = new Uint8ClampedArray(width * height * 4);\n    for (var i = 0; i < height * width; ++i) {\n        // invert mask.  Invert the segmentation mask.\n        var j = i * 4;\n        bytes[j + 0] = 255;\n        bytes[j + 1] = 255;\n        bytes[j + 2] = 255;\n        bytes[j + 3] = 255;\n        for (var k = 0; k < multiPersonPartSegmentation.length; k++) {\n            var partId = multiPersonPartSegmentation[k].data[i];\n            if (partId !== -1) {\n                var color = partColors[partId];\n                if (!color) {\n                    throw new Error(\"No color could be found for part id \".concat(partId));\n                }\n                bytes[j + 0] = color[0];\n                bytes[j + 1] = color[1];\n                bytes[j + 2] = color[2];\n                bytes[j + 3] = 255;\n            }\n        }\n    }\n    return new ImageData(bytes, width, height);\n}\nvar CANVAS_NAMES = {\n    blurred: 'blurred',\n    blurredMask: 'blurred-mask',\n    mask: 'mask',\n    lowresPartMask: 'lowres-part-mask',\n};\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toMask or toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n */\nfunction drawMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var _a = getInputSize(image), height = _a[0], width = _a[1];\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    ctx.drawImage(image, 0, 0);\n    ctx.globalAlpha = maskOpacity;\n    if (maskImage) {\n        assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n        var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n        var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n        ctx.drawImage(blurredMask, 0, 0, width, height);\n    }\n    ctx.restore();\n}\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * pixelated mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n *\n * @param pixelCellWidth The width of each pixel cell. Default to 10 px.\n */\nfunction drawPixelatedMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal, pixelCellWidth) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    if (pixelCellWidth === void 0) { pixelCellWidth = 10.0; }\n    var _a = getInputSize(image), height = _a[0], width = _a[1];\n    assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n    var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n    var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n    canvas.width = blurredMask.width;\n    canvas.height = blurredMask.height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    var offscreenCanvas = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);\n    var offscreenCanvasCtx = offscreenCanvas\n        .getContext('2d');\n    offscreenCanvas.width = blurredMask.width * (1.0 / pixelCellWidth);\n    offscreenCanvas.height = blurredMask.height * (1.0 / pixelCellWidth);\n    offscreenCanvasCtx.drawImage(blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0, 0, canvas.width, canvas.height);\n    // Draws vertical grid lines that are `pixelCellWidth` apart from each other.\n    for (var i = 0; i < offscreenCanvas.width; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffffff';\n        ctx.moveTo(pixelCellWidth * i, 0);\n        ctx.lineTo(pixelCellWidth * i, canvas.height);\n        ctx.stroke();\n    }\n    // Draws horizontal grid lines that are `pixelCellWidth` apart from each\n    // other.\n    for (var i = 0; i < offscreenCanvas.height; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffffff';\n        ctx.moveTo(0, pixelCellWidth * i);\n        ctx.lineTo(canvas.width, pixelCellWidth * i);\n        ctx.stroke();\n    }\n    ctx.globalAlpha = 1.0 - maskOpacity;\n    ctx.drawImage(image, 0, 0, blurredMask.width, blurredMask.height);\n    ctx.restore();\n}\nfunction createPersonMask(multiPersonSegmentation, edgeBlurAmount) {\n    var backgroundMaskImage = toMask(multiPersonSegmentation, { r: 0, g: 0, b: 0, a: 255 }, { r: 0, g: 0, b: 0, a: 0 });\n    var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n    if (edgeBlurAmount === 0) {\n        return backgroundMask;\n    }\n    else {\n        return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n    }\n}\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param personSegmentation A SemanticPersonSegmentation or an array of\n * PersonSegmentation object.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nfunction drawBokehEffect(canvas, image, multiPersonSegmentation, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var blurredImage = drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n    canvas.width = blurredImage.width;\n    canvas.height = blurredImage.height;\n    var ctx = canvas.getContext('2d');\n    if (Array.isArray(multiPersonSegmentation) &&\n        multiPersonSegmentation.length === 0) {\n        ctx.drawImage(blurredImage, 0, 0);\n        return;\n    }\n    var personMask = createPersonMask(multiPersonSegmentation, edgeBlurAmount);\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    // draw the original image on the final canvas\n    var _a = getInputSize(image), height = _a[0], width = _a[1];\n    ctx.drawImage(image, 0, 0, width, height);\n    // \"destination-in\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // crop what's not the person using the mask from the original image\n    drawWithCompositing(ctx, personMask, 'destination-in');\n    // \"destination-over\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // draw the blurred background on top of the original image where it doesn't\n    // overlap.\n    drawWithCompositing(ctx, blurredImage, 'destination-over');\n    ctx.restore();\n}\nfunction createBodyPartMask(multiPersonPartSegmentation, bodyPartIdsToMask, edgeBlurAmount) {\n    var backgroundMaskImage = toMask(multiPersonPartSegmentation, { r: 0, g: 0, b: 0, a: 0 }, { r: 0, g: 0, b: 0, a: 255 }, true, bodyPartIdsToMask);\n    var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n    if (edgeBlurAmount === 0) {\n        return backgroundMask;\n    }\n    else {\n        return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n    }\n}\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param partSegmentation A SemanticPartSegmentation or an array of\n * PartSegmentation object.\n *\n * @param bodyPartIdsToBlur Default to [0, 1] (left-face and right-face). An\n * array of body part ids to blur. Each must be one of the 24 body part ids.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nfunction blurBodyPart(canvas, image, partSegmentation, bodyPartIdsToBlur, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (bodyPartIdsToBlur === void 0) { bodyPartIdsToBlur = [0, 1]; }\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var blurredImage = drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n    canvas.width = blurredImage.width;\n    canvas.height = blurredImage.height;\n    var ctx = canvas.getContext('2d');\n    if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n        ctx.drawImage(blurredImage, 0, 0);\n        return;\n    }\n    var bodyPartMask = createBodyPartMask(partSegmentation, bodyPartIdsToBlur, edgeBlurAmount);\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    // draw the original image on the final canvas\n    var _a = getInputSize(image), height = _a[0], width = _a[1];\n    ctx.drawImage(image, 0, 0, width, height);\n    // \"destination-in\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // crop what's not the person using the mask from the original image\n    drawWithCompositing(ctx, bodyPartMask, 'destination-in');\n    // \"destination-over\" - \"The existing canvas content is kept where both the\n    // new shape and existing canvas content overlap. Everything else is made\n    // transparent.\"\n    // draw the blurred background on top of the original image where it doesn't\n    // overlap.\n    drawWithCompositing(ctx, blurredImage, 'destination-over');\n    ctx.restore();\n}\n\n/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nvar PART_CHANNELS = [\n    'left_face',\n    'right_face',\n    'left_upper_arm_front',\n    'left_upper_arm_back',\n    'right_upper_arm_front',\n    'right_upper_arm_back',\n    'left_lower_arm_front',\n    'left_lower_arm_back',\n    'right_lower_arm_front',\n    'right_lower_arm_back',\n    'left_hand',\n    'right_hand',\n    'torso_front',\n    'torso_back',\n    'left_upper_leg_front',\n    'left_upper_leg_back',\n    'right_upper_leg_front',\n    'right_upper_leg_back',\n    'left_lower_leg_front',\n    'left_lower_leg_back',\n    'right_lower_leg_front',\n    'right_lower_leg_back',\n    'left_feet',\n    'right_feet'\n];\n\n/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nvar version = '2.2.1';\n\n\n//# sourceMappingURL=body-pix.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JvZHktcGl4L2Rpc3QvYm9keS1waXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDtBQUNUO0FBQ087O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFn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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJEQUEyRDtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOENBQThDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMERBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUEyQztBQUMzQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU0TTtBQUM1TSIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmN5L0RldmVsb3BtZW50L0FydC9jYWxvcmllLWFpLWFwcC9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3ctbW9kZWxzL2JvZHktcGl4L2Rpc3QvYm9keS1waXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGZjb252IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyJztcbmltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQgeyBnZXRCYWNrZW5kIH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogVGFrZXMgdGhlIHNpZ21vaWQgb2YgdGhlIHBhcnQgaGVhdG1hcCBvdXRwdXQgYW5kIGdlbmVyYXRlcyBhIDJkIG9uZS1ob3RcbiAqIHRlbnNvciB3aXRoIG9uZXMgd2hlcmUgdGhlIHBhcnQncyBzY29yZSBoYXMgdGhlIG1heGltdW0gdmFsdWUuXG4gKlxuICogQHBhcmFtIHBhcnRIZWF0bWFwU2NvcmVzXG4gKi9cbmZ1bmN0aW9uIHRvRmxhdHRlbmVkT25lSG90UGFydE1hcChwYXJ0SGVhdG1hcFNjb3Jlcykge1xuICAgIHZhciBudW1QYXJ0cyA9IHBhcnRIZWF0bWFwU2NvcmVzLnNoYXBlWzJdO1xuICAgIHZhciBwYXJ0TWFwTG9jYXRpb25zID0gdGYuYXJnTWF4KHBhcnRIZWF0bWFwU2NvcmVzLCAyKTtcbiAgICB2YXIgcGFydE1hcEZsYXR0ZW5lZCA9IHRmLnJlc2hhcGUocGFydE1hcExvY2F0aW9ucywgWy0xXSk7XG4gICAgcmV0dXJuIHRmLm9uZUhvdChwYXJ0TWFwRmxhdHRlbmVkLCBudW1QYXJ0cyk7XG59XG5mdW5jdGlvbiBjbGlwQnlNYXNrMmQoaW1hZ2UsIG1hc2spIHtcbiAgICByZXR1cm4gdGYubXVsKGltYWdlLCBtYXNrKTtcbn1cbi8qKlxuICogVGFrZXMgdGhlIHNpZ21vaWQgb2YgdGhlIHNlZ21lbnRhdGlvbiBvdXRwdXQsIGFuZCBnZW5lcmF0ZXMgYSBzZWdtZW50YXRpb25cbiAqIG1hc2sgd2l0aCBhIDEgb3IgMCBhdCBlYWNoIHBpeGVsIHdoZXJlIHRoZXJlIGlzIGEgcGVyc29uIG9yIG5vdCBhIHBlcnNvbi4gVGhlXG4gKiBzZWdtZW50YXRpb24gdGhyZXNob2xkIGRldGVybWluZXMgdGhlIHRocmVzaG9sZCBvZiBhIHNjb3JlIGZvciBhIHBpeGVsIGZvciBpdFxuICogdG8gYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGEgcGVyc29uLlxuICogQHBhcmFtIHNlZ21lbnRTY29yZXMgQSAzZC10ZW5zb3Igb2YgdGhlIHNpZ21vaWQgb2YgdGhlIHNlZ21lbnRhdGlvbiBvdXRwdXQuXG4gKiBAcGFyYW0gc2VnbWVudGF0aW9uVGhyZXNob2xkIFRoZSBtaW5pbXVtIHRoYXQgc2VnbWVudGF0aW9uIHZhbHVlcyBtdXN0IGhhdmVcbiAqIHRvIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcGVyc29uLiAgQWZmZWN0cyB0aGUgZ2VuZXJhdGlvbiBvZiB0aGVcbiAqIHNlZ21lbnRhdGlvbiBtYXNrIGFuZCB0aGUgY2xpcHBpbmcgb2YgdGhlIGNvbG9yZWQgcGFydCBpbWFnZS5cbiAqXG4gKiBAcmV0dXJucyBBIHNlZ21lbnRhdGlvbiBtYXNrIHdpdGggYSAxIG9yIDAgYXQgZWFjaCBwaXhlbCB3aGVyZSB0aGVyZSBpcyBhXG4gKiBwZXJzb24gb3Igbm90IGEgcGVyc29uLlxuICovXG5mdW5jdGlvbiB0b01hc2tUZW5zb3Ioc2VnbWVudFNjb3JlcywgdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGYuY2FzdCh0Zi5ncmVhdGVyKHNlZ21lbnRTY29yZXMsIHRmLnNjYWxhcih0aHJlc2hvbGQpKSwgJ2ludDMyJyk7XG4gICAgfSk7XG59XG4vKipcbiAqIFRha2VzIHRoZSBzaWdtb2lkIG9mIHRoZSBwZXJzb24gYW5kIHBhcnQgbWFwIG91dHB1dCwgYW5kIHJldHVybnMgYSAyZCB0ZW5zb3JcbiAqIG9mIGFuIGltYWdlIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXQgZWFjaCBwaXhlbCBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogcGFydCB3aXRoIHRoZSBoaWdoZXN0IHZhbHVlLiBUaGVzZSBwYXJ0IGlkcyBhcmUgY2xpcHBlZCBieSB0aGUgc2VnbWVudGF0aW9uXG4gKiBtYXNrLiBXaGVyZXZlciB0aGUgYSBwaXhlbCBpcyBjbGlwcGVkIGJ5IHRoZSBzZWdtZW50YXRpb24gbWFzaywgaXRzIHZhbHVlXG4gKiB3aWxsIHNldCB0byAtMSwgaW5kaWNhdGluZyB0aGF0IHRoZXJlIGlzIG5vIHBhcnQgaW4gdGhhdCBwaXhlbC5cbiAqIEBwYXJhbSBzZWdtZW50U2NvcmVzIEEgM2QtdGVuc29yIG9mIHRoZSBzaWdtb2lkIG9mIHRoZSBzZWdtZW50YXRpb24gb3V0cHV0LlxuICogQHBhcmFtIHBhcnRIZWF0bWFwU2NvcmVzIEEgM2QtdGVuc29yIG9mIHRoZSBzaWdtb2lkIG9mIHRoZSBwYXJ0IGhlYXRtYXBcbiAqIG91dHB1dC4gVGhlIHRoaXJkIGRpbWVuc2lvbiBjb3JyZXNwb25kcyB0byB0aGUgcGFydC5cbiAqXG4gKiBAcmV0dXJucyBBIDJkIHRlbnNvciBvZiBhbiBpbWFnZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGF0IGVhY2ggcGl4ZWxcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBhcnQgd2l0aCB0aGUgaGlnaGVzdCB2YWx1ZS4gVGhlc2UgcGFydCBpZHMgYXJlIGNsaXBwZWRcbiAqIGJ5IHRoZSBzZWdtZW50YXRpb24gbWFzay4gIEl0IHdpbGwgaGF2ZSB2YWx1ZXMgb2YgLTEgZm9yIHBpeGVscyB0aGF0IGFyZVxuICogb3V0c2lkZSBvZiB0aGUgYm9keSBhbmQgZG8gbm90IGhhdmUgYSBjb3JyZXNwb25kaW5nIHBhcnQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhcnRTZWdtZW50YXRpb24oc2VnbWVudGF0aW9uTWFzaywgcGFydEhlYXRtYXBTY29yZXMpIHtcbiAgICB2YXIgX2EgPSBwYXJ0SGVhdG1hcFNjb3Jlcy5zaGFwZSwgcGFydE1hcEhlaWdodCA9IF9hWzBdLCBwYXJ0TWFwV2lkdGggPSBfYVsxXSwgbnVtUGFydHMgPSBfYVsyXTtcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmbGF0dGVuZWRNYXAgPSB0b0ZsYXR0ZW5lZE9uZUhvdFBhcnRNYXAocGFydEhlYXRtYXBTY29yZXMpO1xuICAgICAgICB2YXIgcGFydE51bWJlcnMgPSB0Zi5leHBhbmREaW1zKHRmLnJhbmdlKDAsIG51bVBhcnRzLCAxLCAnaW50MzInKSwgMSk7XG4gICAgICAgIHZhciBwYXJ0TWFwRmxhdHRlbmVkID0gdGYuY2FzdCh0Zi5tYXRNdWwoZmxhdHRlbmVkTWFwLCBwYXJ0TnVtYmVycyksICdpbnQzMicpO1xuICAgICAgICB2YXIgcGFydE1hcCA9IHRmLnJlc2hhcGUocGFydE1hcEZsYXR0ZW5lZCwgW3BhcnRNYXBIZWlnaHQsIHBhcnRNYXBXaWR0aF0pO1xuICAgICAgICB2YXIgcGFydE1hcFNoaWZ0ZWRVcEZvckNsaXBwaW5nID0gdGYuYWRkKHBhcnRNYXAsIHRmLnNjYWxhcigxLCAnaW50MzInKSk7XG4gICAgICAgIHJldHVybiB0Zi5zdWIoY2xpcEJ5TWFzazJkKHBhcnRNYXBTaGlmdGVkVXBGb3JDbGlwcGluZywgc2VnbWVudGF0aW9uTWFzayksIHRmLnNjYWxhcigxLCAnaW50MzInKSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWNvZGVPbmx5UGFydFNlZ21lbnRhdGlvbihwYXJ0SGVhdG1hcFNjb3Jlcykge1xuICAgIHZhciBfYSA9IHBhcnRIZWF0bWFwU2NvcmVzLnNoYXBlLCBwYXJ0TWFwSGVpZ2h0ID0gX2FbMF0sIHBhcnRNYXBXaWR0aCA9IF9hWzFdLCBudW1QYXJ0cyA9IF9hWzJdO1xuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZsYXR0ZW5lZE1hcCA9IHRvRmxhdHRlbmVkT25lSG90UGFydE1hcChwYXJ0SGVhdG1hcFNjb3Jlcyk7XG4gICAgICAgIHZhciBwYXJ0TnVtYmVycyA9IHRmLmV4cGFuZERpbXModGYucmFuZ2UoMCwgbnVtUGFydHMsIDEsICdpbnQzMicpLCAxKTtcbiAgICAgICAgdmFyIHBhcnRNYXBGbGF0dGVuZWQgPSB0Zi5jYXN0KHRmLm1hdE11bChmbGF0dGVuZWRNYXAsIHBhcnROdW1iZXJzKSwgJ2ludDMyJyk7XG4gICAgICAgIHJldHVybiB0Zi5yZXNoYXBlKHBhcnRNYXBGbGF0dGVuZWQsIFtwYXJ0TWFwSGVpZ2h0LCBwYXJ0TWFwV2lkdGhdKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLyoqXG4gKiBCb2R5UGl4IHN1cHBvcnRzIHVzaW5nIHZhcmlvdXMgY29udm9sdXRpb24gbmV1cmFsIG5ldHdvcmsgbW9kZWxzXG4gKiAoZS5nLiBSZXNOZXQgYW5kIE1vYmlsZU5ldFYxKSBhcyBpdHMgdW5kZXJseWluZyBiYXNlIG1vZGVsLlxuICogVGhlIGZvbGxvd2luZyBCYXNlTW9kZWwgaW50ZXJmYWNlIGRlZmluZXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3JcbiAqIGNyZWF0aW5nIHN1Y2ggQm9keVBpeCBiYXNlIG1vZGVscy4gQ3VycmVudGx5IGJvdGggTW9iaWxlTmV0IChpblxuICogLi9tb2JpbGVuZXQudHMpIGFuZCBSZXNOZXQgKGluIC4vcmVzbmV0LnRzKSBpbXBsZW1lbnRzIHRoZSBCYXNlTW9kZWxcbiAqIGludGVyZmFjZS4gTmV3IGJhc2UgbW9kZWxzIHRoYXQgY29uZm9ybSB0byB0aGUgQmFzZU1vZGVsIGludGVyZmFjZSBjYW4gYmVcbiAqIGFkZGVkIHRvIEJvZHlQaXguXG4gKi9cbnZhciBCYXNlTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZU1vZGVsKG1vZGVsLCBvdXRwdXRTdHJpZGUpIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLm91dHB1dFN0cmlkZSA9IG91dHB1dFN0cmlkZTtcbiAgICAgICAgdmFyIGlucHV0U2hhcGUgPSB0aGlzLm1vZGVsLmlucHV0c1swXS5zaGFwZTtcbiAgICAgICAgdGYudXRpbC5hc3NlcnQoKGlucHV0U2hhcGVbMV0gPT09IC0xKSAmJiAoaW5wdXRTaGFwZVsyXSA9PT0gLTEpLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIklucHV0IHNoYXBlIFtcIi5jb25jYXQoaW5wdXRTaGFwZVsxXSwgXCIsIFwiKS5jb25jYXQoaW5wdXRTaGFwZVsyXSwgXCJdIFwiKSArXG4gICAgICAgICAgICBcIm11c3QgYm90aCBiZSBlcXVhbCB0byBvciAtMVwiOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlZGljdHMgaW50ZXJtZWRpYXRlIFRlbnNvciByZXByZXNlbnRhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IFJHQiBpbWFnZSBvZiB0aGUgYmFzZSBtb2RlbC5cbiAgICAgKiBBIFRlbnNvciBvZiBzaGFwZTogW2BpbnB1dFJlc29sdXRpb25gLCBgaW5wdXRSZXNvbHV0aW9uYCwgM10uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgZGljdGlvbmFyeSBvZiBiYXNlIG1vZGVsJ3MgaW50ZXJtZWRpYXRlIHByZWRpY3Rpb25zLlxuICAgICAqIFRoZSByZXR1cm5lZCBkaWN0aW9uYXJ5IHNob3VsZCBjb250YWlucyB0aGUgZm9sbG93aW5nIGVsZW1lbnRzOlxuICAgICAqIC0gaGVhdG1hcFNjb3JlczogQSBUZW5zb3IzRCB0aGF0IHJlcHJlc2VudHMgdGhlIGtleXBvaW50IGhlYXRtYXAgc2NvcmVzLlxuICAgICAqIC0gb2Zmc2V0czogQSBUZW5zb3IzRCB0aGF0IHJlcHJlc2VudHMgdGhlIG9mZnNldHMuXG4gICAgICogLSBkaXNwbGFjZW1lbnRGd2Q6IEEgVGVuc29yM0QgdGhhdCByZXByZXNlbnRzIHRoZSBmb3J3YXJkIGRpc3BsYWNlbWVudC5cbiAgICAgKiAtIGRpc3BsYWNlbWVudEJ3ZDogQSBUZW5zb3IzRCB0aGF0IHJlcHJlc2VudHMgdGhlIGJhY2t3YXJkIGRpc3BsYWNlbWVudC5cbiAgICAgKiAtIHNlZ21lbnRhdGlvbjogQSBUZW5zb3IzRCB0aGF0IHJlcHJlc2VudHMgdGhlIHNlZ21lbnRhdGlvbiBvZiBhbGxcbiAgICAgKiBwZW9wbGUuXG4gICAgICogLSBsb25nT2Zmc2V0czogQSBUZW5zb3IzRCB0aGF0IHJlcHJlc2VudHMgdGhlIGxvbmcgb2Zmc2V0cyB1c2VkIGZvclxuICAgICAqIGluc3RhbmNlIGdyb3VwaW5nLlxuICAgICAqIC0gcGFydEhlYXRtYXBzOiBBIFRlbnNvcjNEIHRoYXQgcmVwcmVzZW50cyB0aGUgYm9keSBwYXJ0IHNlZ21lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBCYXNlTW9kZWwucHJvdG90eXBlLnByZWRpY3QgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFzRmxvYXQgPSBfdGhpcy5wcmVwcm9jZXNzSW5wdXQodGYuY2FzdChpbnB1dCwgJ2Zsb2F0MzInKSk7XG4gICAgICAgICAgICB2YXIgYXNCYXRjaCA9IHRmLmV4cGFuZERpbXMoYXNGbG9hdCwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF90aGlzLm1vZGVsLnByZWRpY3QoYXNCYXRjaCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0czNkID0gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHkpIHsgcmV0dXJuIHRmLnNxdWVlemUoeSwgWzBdKTsgfSk7XG4gICAgICAgICAgICB2YXIgbmFtZWRSZXN1bHRzID0gX3RoaXMubmFtZU91dHB1dFJlc3VsdHMocmVzdWx0czNkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVhdG1hcFNjb3JlczogdGYuc2lnbW9pZChuYW1lZFJlc3VsdHMuaGVhdG1hcCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0czogbmFtZWRSZXN1bHRzLm9mZnNldHMsXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50RndkOiBuYW1lZFJlc3VsdHMuZGlzcGxhY2VtZW50RndkLFxuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudEJ3ZDogbmFtZWRSZXN1bHRzLmRpc3BsYWNlbWVudEJ3ZCxcbiAgICAgICAgICAgICAgICBzZWdtZW50YXRpb246IG5hbWVkUmVzdWx0cy5zZWdtZW50YXRpb24sXG4gICAgICAgICAgICAgICAgcGFydEhlYXRtYXBzOiBuYW1lZFJlc3VsdHMucGFydEhlYXRtYXBzLFxuICAgICAgICAgICAgICAgIGxvbmdPZmZzZXRzOiBuYW1lZFJlc3VsdHMubG9uZ09mZnNldHMsXG4gICAgICAgICAgICAgICAgcGFydE9mZnNldHM6IG5hbWVkUmVzdWx0cy5wYXJ0T2Zmc2V0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlcyB0aGUgQ1BVIGFuZCBHUFUgbWVtb3J5IGFsbG9jYXRlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgQmFzZU1vZGVsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vZGVsLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBCYXNlTW9kZWw7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgTW9iaWxlTmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb2JpbGVOZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9iaWxlTmV0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1vYmlsZU5ldC5wcm90b3R5cGUucHJlcHJvY2Vzc0lucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGl4ZWxzIFswLCAyNTVdIHRvIGJlIGJldHdlZW4gWy0xLCAxXS5cbiAgICAgICAgcmV0dXJuIHRmLnRpZHkoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGYuc3ViKHRmLmRpdihpbnB1dCwgMTI3LjUpLCAxLjApOyB9KTtcbiAgICB9O1xuICAgIE1vYmlsZU5ldC5wcm90b3R5cGUubmFtZU91dHB1dFJlc3VsdHMgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IHJlc3VsdHNbMF0sIHNlZ21lbnRhdGlvbiA9IHJlc3VsdHNbMV0sIHBhcnRIZWF0bWFwcyA9IHJlc3VsdHNbMl0sIGxvbmdPZmZzZXRzID0gcmVzdWx0c1szXSwgaGVhdG1hcCA9IHJlc3VsdHNbNF0sIGRpc3BsYWNlbWVudEZ3ZCA9IHJlc3VsdHNbNV0sIGRpc3BsYWNlbWVudEJ3ZCA9IHJlc3VsdHNbNl0sIHBhcnRPZmZzZXRzID0gcmVzdWx0c1s3XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICBzZWdtZW50YXRpb246IHNlZ21lbnRhdGlvbixcbiAgICAgICAgICAgIHBhcnRIZWF0bWFwczogcGFydEhlYXRtYXBzLFxuICAgICAgICAgICAgbG9uZ09mZnNldHM6IGxvbmdPZmZzZXRzLFxuICAgICAgICAgICAgaGVhdG1hcDogaGVhdG1hcCxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZ3ZDogZGlzcGxhY2VtZW50RndkLFxuICAgICAgICAgICAgZGlzcGxhY2VtZW50QndkOiBkaXNwbGFjZW1lbnRCd2QsXG4gICAgICAgICAgICBwYXJ0T2Zmc2V0czogcGFydE9mZnNldHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBNb2JpbGVOZXQ7XG59KEJhc2VNb2RlbCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgUEFSVF9OQU1FUyA9IFtcbiAgICAnbm9zZScsICdsZWZ0RXllJywgJ3JpZ2h0RXllJywgJ2xlZnRFYXInLCAncmlnaHRFYXInLCAnbGVmdFNob3VsZGVyJyxcbiAgICAncmlnaHRTaG91bGRlcicsICdsZWZ0RWxib3cnLCAncmlnaHRFbGJvdycsICdsZWZ0V3Jpc3QnLCAncmlnaHRXcmlzdCcsXG4gICAgJ2xlZnRIaXAnLCAncmlnaHRIaXAnLCAnbGVmdEtuZWUnLCAncmlnaHRLbmVlJywgJ2xlZnRBbmtsZScsICdyaWdodEFua2xlJ1xuXTtcbnZhciBOVU1fS0VZUE9JTlRTID0gUEFSVF9OQU1FUy5sZW5ndGg7XG52YXIgUEFSVF9JRFMgPSBQQVJUX05BTUVTLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBqb2ludE5hbWUsIGkpIHtcbiAgICByZXN1bHRbam9pbnROYW1lXSA9IGk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0sIHt9KTtcbnZhciBDT05ORUNURURfUEFSVF9OQU1FUyA9IFtcbiAgICBbJ2xlZnRIaXAnLCAnbGVmdFNob3VsZGVyJ10sIFsnbGVmdEVsYm93JywgJ2xlZnRTaG91bGRlciddLFxuICAgIFsnbGVmdEVsYm93JywgJ2xlZnRXcmlzdCddLCBbJ2xlZnRIaXAnLCAnbGVmdEtuZWUnXSxcbiAgICBbJ2xlZnRLbmVlJywgJ2xlZnRBbmtsZSddLCBbJ3JpZ2h0SGlwJywgJ3JpZ2h0U2hvdWxkZXInXSxcbiAgICBbJ3JpZ2h0RWxib3cnLCAncmlnaHRTaG91bGRlciddLCBbJ3JpZ2h0RWxib3cnLCAncmlnaHRXcmlzdCddLFxuICAgIFsncmlnaHRIaXAnLCAncmlnaHRLbmVlJ10sIFsncmlnaHRLbmVlJywgJ3JpZ2h0QW5rbGUnXSxcbiAgICBbJ2xlZnRTaG91bGRlcicsICdyaWdodFNob3VsZGVyJ10sIFsnbGVmdEhpcCcsICdyaWdodEhpcCddXG5dO1xuLypcbiAqIERlZmluZSB0aGUgc2tlbGV0b24uIFRoaXMgZGVmaW5lcyB0aGUgcGFyZW50LT5jaGlsZCByZWxhdGlvbnNoaXBzIG9mIG91clxuICogdHJlZS4gQXJiaXRyYXJpbHkgdGhpcyBkZWZpbmVzIHRoZSBub3NlIGFzIHRoZSByb290IG9mIHRoZSB0cmVlLCBob3dldmVyXG4gKiBzaW5jZSB3ZSB3aWxsIGluZmVyIHRoZSBkaXNwbGFjZW1lbnQgZm9yIGJvdGggcGFyZW50LT5jaGlsZCBhbmRcbiAqIGNoaWxkLT5wYXJlbnQsIHdlIGNhbiBkZWZpbmUgdGhlIHRyZWUgcm9vdCBhcyBhbnkgbm9kZS5cbiAqL1xudmFyIFBPU0VfQ0hBSU4gPSBbXG4gICAgWydub3NlJywgJ2xlZnRFeWUnXSwgWydsZWZ0RXllJywgJ2xlZnRFYXInXSwgWydub3NlJywgJ3JpZ2h0RXllJ10sXG4gICAgWydyaWdodEV5ZScsICdyaWdodEVhciddLCBbJ25vc2UnLCAnbGVmdFNob3VsZGVyJ10sXG4gICAgWydsZWZ0U2hvdWxkZXInLCAnbGVmdEVsYm93J10sIFsnbGVmdEVsYm93JywgJ2xlZnRXcmlzdCddLFxuICAgIFsnbGVmdFNob3VsZGVyJywgJ2xlZnRIaXAnXSwgWydsZWZ0SGlwJywgJ2xlZnRLbmVlJ10sXG4gICAgWydsZWZ0S25lZScsICdsZWZ0QW5rbGUnXSwgWydub3NlJywgJ3JpZ2h0U2hvdWxkZXInXSxcbiAgICBbJ3JpZ2h0U2hvdWxkZXInLCAncmlnaHRFbGJvdyddLCBbJ3JpZ2h0RWxib3cnLCAncmlnaHRXcmlzdCddLFxuICAgIFsncmlnaHRTaG91bGRlcicsICdyaWdodEhpcCddLCBbJ3JpZ2h0SGlwJywgJ3JpZ2h0S25lZSddLFxuICAgIFsncmlnaHRLbmVlJywgJ3JpZ2h0QW5rbGUnXVxuXTtcbkNPTk5FQ1RFRF9QQVJUX05BTUVTLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgam9pbnROYW1lQSA9IF9hWzBdLCBqb2ludE5hbWVCID0gX2FbMV07XG4gICAgcmV0dXJuIChbUEFSVF9JRFNbam9pbnROYW1lQV0sIFBBUlRfSURTW2pvaW50TmFtZUJdXSk7XG59KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoX2EsIF9iLCBwYWRkaW5nKSB7XG4gICAgdmFyIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xuICAgIHZhciBpbnB1dFJlc29sdXRpb25ZID0gX2JbMF0sIGlucHV0UmVzb2x1dGlvblggPSBfYlsxXTtcbiAgICB2YXIgcGFkVCA9IHBhZGRpbmcudG9wLCBwYWRCID0gcGFkZGluZy5ib3R0b20sIHBhZEwgPSBwYWRkaW5nLmxlZnQsIHBhZFIgPSBwYWRkaW5nLnJpZ2h0O1xuICAgIHZhciBzY2FsZVkgPSBpbnB1dFJlc29sdXRpb25ZIC8gKHBhZFQgKyBwYWRCICsgaGVpZ2h0KTtcbiAgICB2YXIgc2NhbGVYID0gaW5wdXRSZXNvbHV0aW9uWCAvIChwYWRMICsgcGFkUiArIHdpZHRoKTtcbiAgICByZXR1cm4gW3NjYWxlWCwgc2NhbGVZXTtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldFBvaW50KHksIHgsIGtleXBvaW50LCBvZmZzZXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeTogb2Zmc2V0cy5nZXQoeSwgeCwga2V5cG9pbnQpLFxuICAgICAgICB4OiBvZmZzZXRzLmdldCh5LCB4LCBrZXlwb2ludCArIE5VTV9LRVlQT0lOVFMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEltYWdlQ29vcmRzKHBhcnQsIG91dHB1dFN0cmlkZSwgb2Zmc2V0cykge1xuICAgIHZhciBoZWF0bWFwWSA9IHBhcnQuaGVhdG1hcFksIGhlYXRtYXBYID0gcGFydC5oZWF0bWFwWCwga2V5cG9pbnQgPSBwYXJ0LmlkO1xuICAgIHZhciBfYSA9IGdldE9mZnNldFBvaW50KGhlYXRtYXBZLCBoZWF0bWFwWCwga2V5cG9pbnQsIG9mZnNldHMpLCB5ID0gX2EueSwgeCA9IF9hLng7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcGFydC5oZWF0bWFwWCAqIG91dHB1dFN0cmlkZSArIHgsXG4gICAgICAgIHk6IHBhcnQuaGVhdG1hcFkgKiBvdXRwdXRTdHJpZGUgKyB5XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNsYW1wKGEsIG1pbiwgbWF4KSB7XG4gICAgaWYgKGEgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgaWYgKGEgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoeTEsIHgxLCB5MiwgeDIpIHtcbiAgICB2YXIgZHkgPSB5MiAtIHkxO1xuICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgcmV0dXJuIGR5ICogZHkgKyBkeCAqIGR4O1xufVxuZnVuY3Rpb24gYWRkVmVjdG9ycyhhLCBiKSB7XG4gICAgcmV0dXJuIHsgeDogYS54ICsgYi54LCB5OiBhLnkgKyBiLnkgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZURpc3RhbmNlKGVtYmVkZGluZywgcG9zZSwgbWluUGFydFNjb3JlKSB7XG4gICAgaWYgKG1pblBhcnRTY29yZSA9PT0gdm9pZCAwKSB7IG1pblBhcnRTY29yZSA9IDAuMzsgfVxuICAgIHZhciBkaXN0YW5jZSA9IDAuMDtcbiAgICB2YXIgbnVtS3B0ID0gMDtcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IGVtYmVkZGluZy5sZW5ndGg7IHArKykge1xuICAgICAgICBpZiAocG9zZS5rZXlwb2ludHNbcF0uc2NvcmUgPiBtaW5QYXJ0U2NvcmUpIHtcbiAgICAgICAgICAgIG51bUtwdCArPSAxO1xuICAgICAgICAgICAgZGlzdGFuY2UgKz0gTWF0aC5wb3coKGVtYmVkZGluZ1twXS54IC0gcG9zZS5rZXlwb2ludHNbcF0ucG9zaXRpb24ueCksIDIpICtcbiAgICAgICAgICAgICAgICBNYXRoLnBvdygoZW1iZWRkaW5nW3BdLnkgLSBwb3NlLmtleXBvaW50c1twXS5wb3NpdGlvbi55KSwgMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bUtwdCA9PT0gMCkge1xuICAgICAgICBkaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZSAvIG51bUtwdDtcbiAgICB9XG4gICAgcmV0dXJuIGRpc3RhbmNlO1xufVxuZnVuY3Rpb24gY29udmVydFRvUG9zaXRpb25Jbk91cHV0KHBvc2l0aW9uLCBfYSwgX2IsIHN0cmlkZSkge1xuICAgIHZhciBwYWRUID0gX2FbMF0sIHBhZEwgPSBfYVsxXTtcbiAgICB2YXIgc2NhbGVYID0gX2JbMF0sIHNjYWxlWSA9IF9iWzFdO1xuICAgIHZhciB5ID0gTWF0aC5yb3VuZCgoKHBhZFQgKyBwb3NpdGlvbi55ICsgMS4wKSAqIHNjYWxlWSAtIDEuMCkgLyBzdHJpZGUpO1xuICAgIHZhciB4ID0gTWF0aC5yb3VuZCgoKHBhZEwgKyBwb3NpdGlvbi54ICsgMS4wKSAqIHNjYWxlWCAtIDEuMCkgLyBzdHJpZGUpO1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cbmZ1bmN0aW9uIGdldEVtYmVkZGluZyhsb2NhdGlvbiwga2V5cG9pbnRJbmRleCwgY29udmVydFRvUG9zaXRpb24sIG91dHB1dFJlc29sdXRpb25YLCBsb25nT2Zmc2V0cywgcmVmaW5lU3RlcHMsIF9hKSB7XG4gICAgdmFyIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xuICAgIHZhciBuZXdMb2NhdGlvbiA9IGNvbnZlcnRUb1Bvc2l0aW9uKGxvY2F0aW9uKTtcbiAgICB2YXIgbm4gPSBuZXdMb2NhdGlvbi55ICogb3V0cHV0UmVzb2x1dGlvblggKyBuZXdMb2NhdGlvbi54O1xuICAgIHZhciBkeSA9IGxvbmdPZmZzZXRzW05VTV9LRVlQT0lOVFMgKiAoMiAqIG5uKSArIGtleXBvaW50SW5kZXhdO1xuICAgIHZhciBkeCA9IGxvbmdPZmZzZXRzW05VTV9LRVlQT0lOVFMgKiAoMiAqIG5uICsgMSkgKyBrZXlwb2ludEluZGV4XTtcbiAgICB2YXIgeSA9IGxvY2F0aW9uLnkgKyBkeTtcbiAgICB2YXIgeCA9IGxvY2F0aW9uLnggKyBkeDtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHJlZmluZVN0ZXBzOyB0KyspIHtcbiAgICAgICAgeSA9IE1hdGgubWluKHksIGhlaWdodCAtIDEpO1xuICAgICAgICB4ID0gTWF0aC5taW4oeCwgd2lkdGggLSAxKTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGNvbnZlcnRUb1Bvc2l0aW9uKHsgeDogeCwgeTogeSB9KTtcbiAgICAgICAgdmFyIG5uXzEgPSBuZXdQb3MueSAqIG91dHB1dFJlc29sdXRpb25YICsgbmV3UG9zLng7XG4gICAgICAgIGR5ID0gbG9uZ09mZnNldHNbTlVNX0tFWVBPSU5UUyAqICgyICogbm5fMSkgKyBrZXlwb2ludEluZGV4XTtcbiAgICAgICAgZHggPSBsb25nT2Zmc2V0c1tOVU1fS0VZUE9JTlRTICogKDIgKiBubl8xICsgMSkgKyBrZXlwb2ludEluZGV4XTtcbiAgICAgICAgeSA9IHkgKyBkeTtcbiAgICAgICAgeCA9IHggKyBkeDtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hFbWJlZGRpbmdUb0luc3RhbmNlKGxvY2F0aW9uLCBsb25nT2Zmc2V0cywgcG9zZXMsIG51bUtwdEZvck1hdGNoaW5nLCBfYSwgX2IsIG91dHB1dFJlc29sdXRpb25YLCBfYywgc3RyaWRlLCByZWZpbmVTdGVwcykge1xuICAgIHZhciBwYWRUID0gX2FbMF0sIHBhZEwgPSBfYVsxXTtcbiAgICB2YXIgc2NhbGVYID0gX2JbMF0sIHNjYWxlWSA9IF9iWzFdO1xuICAgIHZhciBoZWlnaHQgPSBfY1swXSwgd2lkdGggPSBfY1sxXTtcbiAgICB2YXIgZW1iZWQgPSBbXTtcbiAgICB2YXIgY29udmVydFRvUG9zaXRpb24gPSBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICByZXR1cm4gY29udmVydFRvUG9zaXRpb25Jbk91cHV0KHBhaXIsIFtwYWRULCBwYWRMXSwgW3NjYWxlWCwgc2NhbGVZXSwgc3RyaWRlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGtleXBvaW50c0luZGV4ID0gMDsga2V5cG9pbnRzSW5kZXggPCBudW1LcHRGb3JNYXRjaGluZzsga2V5cG9pbnRzSW5kZXgrKykge1xuICAgICAgICB2YXIgZW1iZWRkaW5nID0gZ2V0RW1iZWRkaW5nKGxvY2F0aW9uLCBrZXlwb2ludHNJbmRleCwgY29udmVydFRvUG9zaXRpb24sIG91dHB1dFJlc29sdXRpb25YLCBsb25nT2Zmc2V0cywgcmVmaW5lU3RlcHMsIFtoZWlnaHQsIHdpZHRoXSk7XG4gICAgICAgIGVtYmVkLnB1c2goZW1iZWRkaW5nKTtcbiAgICB9XG4gICAgdmFyIGtNaW4gPSAtMTtcbiAgICB2YXIga01pbkRpc3QgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBkaXN0ID0gY29tcHV0ZURpc3RhbmNlKGVtYmVkLCBwb3Nlc1trXSk7XG4gICAgICAgIGlmIChkaXN0IDwga01pbkRpc3QpIHtcbiAgICAgICAgICAgIGtNaW4gPSBrO1xuICAgICAgICAgICAga01pbkRpc3QgPSBkaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrTWluO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0UmVzb2x1dGlvbihfYSwgc3RyaWRlKSB7XG4gICAgdmFyIGlucHV0UmVzb2x1dGlvblkgPSBfYVswXSwgaW5wdXRSZXNvbHV0aW9uWCA9IF9hWzFdO1xuICAgIHZhciBvdXRwdXRSZXNvbHV0aW9uWCA9IE1hdGgucm91bmQoKGlucHV0UmVzb2x1dGlvblggLSAxLjApIC8gc3RyaWRlICsgMS4wKTtcbiAgICB2YXIgb3V0cHV0UmVzb2x1dGlvblkgPSBNYXRoLnJvdW5kKChpbnB1dFJlc29sdXRpb25ZIC0gMS4wKSAvIHN0cmlkZSArIDEuMCk7XG4gICAgcmV0dXJuIFtvdXRwdXRSZXNvbHV0aW9uWCwgb3V0cHV0UmVzb2x1dGlvblldO1xufVxuZnVuY3Rpb24gZGVjb2RlTXVsdGlwbGVNYXNrc0NQVShzZWdtZW50YXRpb24sIGxvbmdPZmZzZXRzLCBwb3Nlc0Fib3ZlU2NvcmUsIGhlaWdodCwgd2lkdGgsIHN0cmlkZSwgX2EsIHBhZGRpbmcsIHJlZmluZVN0ZXBzLCBudW1LcHRGb3JNYXRjaGluZykge1xuICAgIHZhciBpbkhlaWdodCA9IF9hWzBdLCBpbldpZHRoID0gX2FbMV07XG4gICAgaWYgKG51bUtwdEZvck1hdGNoaW5nID09PSB2b2lkIDApIHsgbnVtS3B0Rm9yTWF0Y2hpbmcgPSA1OyB9XG4gICAgdmFyIGRhdGFBcnJheXMgPSBwb3Nlc0Fib3ZlU2NvcmUubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBuZXcgVWludDhBcnJheShoZWlnaHQgKiB3aWR0aCkuZmlsbCgwKTsgfSk7XG4gICAgdmFyIHBhZFQgPSBwYWRkaW5nLnRvcCwgcGFkTCA9IHBhZGRpbmcubGVmdDtcbiAgICB2YXIgX2IgPSBnZXRTY2FsZShbaGVpZ2h0LCB3aWR0aF0sIFtpbkhlaWdodCwgaW5XaWR0aF0sIHBhZGRpbmcpLCBzY2FsZVggPSBfYlswXSwgc2NhbGVZID0gX2JbMV07XG4gICAgdmFyIG91dHB1dFJlc29sdXRpb25YID0gZ2V0T3V0cHV0UmVzb2x1dGlvbihbaW5IZWlnaHQsIGluV2lkdGhdLCBzdHJpZGUpWzBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0OyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgICAgICB2YXIgcHJvYiA9IHNlZ21lbnRhdGlvbltuXTtcbiAgICAgICAgICAgIGlmIChwcm9iID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtNaW4gPSBtYXRjaEVtYmVkZGluZ1RvSW5zdGFuY2UoeyB4OiBqLCB5OiBpIH0sIGxvbmdPZmZzZXRzLCBwb3Nlc0Fib3ZlU2NvcmUsIG51bUtwdEZvck1hdGNoaW5nLCBbcGFkVCwgcGFkTF0sIFtzY2FsZVgsIHNjYWxlWV0sIG91dHB1dFJlc29sdXRpb25YLCBbaGVpZ2h0LCB3aWR0aF0sIHN0cmlkZSwgcmVmaW5lU3RlcHMpO1xuICAgICAgICAgICAgICAgIGlmIChrTWluID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUFycmF5c1trTWluXVtuXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhQXJyYXlzO1xufVxuZnVuY3Rpb24gZGVjb2RlTXVsdGlwbGVQYXJ0TWFza3NDUFUoc2VnbWVudGF0aW9uLCBsb25nT2Zmc2V0cywgcGFydFNlZ21lbnRhaW9uLCBwb3Nlc0Fib3ZlU2NvcmUsIGhlaWdodCwgd2lkdGgsIHN0cmlkZSwgX2EsIHBhZGRpbmcsIHJlZmluZVN0ZXBzLCBudW1LcHRGb3JNYXRjaGluZykge1xuICAgIHZhciBpbkhlaWdodCA9IF9hWzBdLCBpbldpZHRoID0gX2FbMV07XG4gICAgaWYgKG51bUtwdEZvck1hdGNoaW5nID09PSB2b2lkIDApIHsgbnVtS3B0Rm9yTWF0Y2hpbmcgPSA1OyB9XG4gICAgdmFyIGRhdGFBcnJheXMgPSBwb3Nlc0Fib3ZlU2NvcmUubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBuZXcgSW50MzJBcnJheShoZWlnaHQgKiB3aWR0aCkuZmlsbCgtMSk7IH0pO1xuICAgIHZhciBwYWRUID0gcGFkZGluZy50b3AsIHBhZEwgPSBwYWRkaW5nLmxlZnQ7XG4gICAgdmFyIF9iID0gZ2V0U2NhbGUoW2hlaWdodCwgd2lkdGhdLCBbaW5IZWlnaHQsIGluV2lkdGhdLCBwYWRkaW5nKSwgc2NhbGVYID0gX2JbMF0sIHNjYWxlWSA9IF9iWzFdO1xuICAgIHZhciBvdXRwdXRSZXNvbHV0aW9uWCA9IGdldE91dHB1dFJlc29sdXRpb24oW2luSGVpZ2h0LCBpbldpZHRoXSwgc3RyaWRlKVswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlaWdodDsgaSArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIG4gPSBpICogd2lkdGggKyBqO1xuICAgICAgICAgICAgdmFyIHByb2IgPSBzZWdtZW50YXRpb25bbl07XG4gICAgICAgICAgICBpZiAocHJvYiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBrTWluID0gbWF0Y2hFbWJlZGRpbmdUb0luc3RhbmNlKHsgeDogaiwgeTogaSB9LCBsb25nT2Zmc2V0cywgcG9zZXNBYm92ZVNjb3JlLCBudW1LcHRGb3JNYXRjaGluZywgW3BhZFQsIHBhZExdLCBbc2NhbGVYLCBzY2FsZVldLCBvdXRwdXRSZXNvbHV0aW9uWCwgW2hlaWdodCwgd2lkdGhdLCBzdHJpZGUsIHJlZmluZVN0ZXBzKTtcbiAgICAgICAgICAgICAgICBpZiAoa01pbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFBcnJheXNba01pbl1bbl0gPSBwYXJ0U2VnbWVudGFpb25bbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhQXJyYXlzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBkZWNvZGVNdWx0aXBsZU1hc2tzV2ViR2woc2VnbWVudGF0aW9uLCBsb25nT2Zmc2V0cywgcG9zZXNBYm92ZVNjb3JlLCBoZWlnaHQsIHdpZHRoLCBzdHJpZGUsIF9hLCBwYWRkaW5nLCByZWZpbmVTdGVwcywgbWluS3B0U2NvcmUsIG1heE51bVBlb3BsZSkge1xuICAgIHZhciBpbkhlaWdodCA9IF9hWzBdLCBpbldpZHRoID0gX2FbMV07XG4gICAgLy8gVGhlIGhlaWdodC93aWR0aCBvZiB0aGUgaW1hZ2UvY2FudmFzIGl0c2VsZi5cbiAgICB2YXIgX2IgPSBzZWdtZW50YXRpb24uc2hhcGUsIG9yaWdIZWlnaHQgPSBfYlswXSwgb3JpZ1dpZHRoID0gX2JbMV07XG4gICAgLy8gVGhlIGhlaWdodC93aWR0aCBvZiB0aGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICB2YXIgX2MgPSBsb25nT2Zmc2V0cy5zaGFwZS5zbGljZSgwLCAyKSwgb3V0SGVpZ2h0ID0gX2NbMF0sIG91dFdpZHRoID0gX2NbMV07XG4gICAgdmFyIHNoYXBlZExvbmdPZmZzZXRzID0gdGYucmVzaGFwZShsb25nT2Zmc2V0cywgW291dEhlaWdodCwgb3V0V2lkdGgsIDIsIE5VTV9LRVlQT0lOVFNdKTtcbiAgICAvLyBNYWtlIHBvc2UgdGVuc29yIG9mIHNoYXBlIFtNQVhfTlVNX1BFT1BMRSwgTlVNX0tFWVBPSU5UUywgM10gd2hlcmVcbiAgICAvLyB0aGUgbGFzdCAzIGNvb3JkaW5hdGVzIGNvcnJlc3BvbmQgdG8gdGhlIHNjb3JlLCBoIGFuZCB3IGNvb3JkaW5hdGUgb2YgdGhhdFxuICAgIC8vIGtleXBvaW50LlxuICAgIHZhciBwb3NlVmFscyA9IG5ldyBGbG9hdDMyQXJyYXkobWF4TnVtUGVvcGxlICogTlVNX0tFWVBPSU5UUyAqIDMpLmZpbGwoMC4wKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2VzQWJvdmVTY29yZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcG9zZU9mZnNldCA9IGkgKiBOVU1fS0VZUE9JTlRTICogMztcbiAgICAgICAgdmFyIHBvc2UgPSBwb3Nlc0Fib3ZlU2NvcmVbaV07XG4gICAgICAgIGZvciAodmFyIGtwID0gMDsga3AgPCBOVU1fS0VZUE9JTlRTOyBrcCsrKSB7XG4gICAgICAgICAgICB2YXIga2V5cG9pbnQgPSBwb3NlLmtleXBvaW50c1trcF07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcG9zZU9mZnNldCArIGtwICogMztcbiAgICAgICAgICAgIHBvc2VWYWxzW29mZnNldF0gPSBrZXlwb2ludC5zY29yZTtcbiAgICAgICAgICAgIHBvc2VWYWxzW29mZnNldCArIDFdID0ga2V5cG9pbnQucG9zaXRpb24ueTtcbiAgICAgICAgICAgIHBvc2VWYWxzW29mZnNldCArIDJdID0ga2V5cG9pbnQucG9zaXRpb24ueDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2QgPSBnZXRTY2FsZShbaGVpZ2h0LCB3aWR0aF0sIFtpbkhlaWdodCwgaW5XaWR0aF0sIHBhZGRpbmcpLCBzY2FsZVggPSBfZFswXSwgc2NhbGVZID0gX2RbMV07XG4gICAgdmFyIHBvc2VzVGVuc29yID0gdGYudGVuc29yKHBvc2VWYWxzLCBbbWF4TnVtUGVvcGxlLCBOVU1fS0VZUE9JTlRTLCAzXSk7XG4gICAgdmFyIHBhZFQgPSBwYWRkaW5nLnRvcCwgcGFkTCA9IHBhZGRpbmcubGVmdDtcbiAgICB2YXIgcHJvZ3JhbSA9IHtcbiAgICAgICAgdmFyaWFibGVOYW1lczogWydzZWdtZW50YXRpb24nLCAnbG9uZ09mZnNldHMnLCAncG9zZXMnXSxcbiAgICAgICAgb3V0cHV0U2hhcGU6IFtvcmlnSGVpZ2h0LCBvcmlnV2lkdGhdLFxuICAgICAgICB1c2VyQ29kZTogXCJcXG4gICAgaW50IGNvbnZlcnRUb1Bvc2l0aW9uSW5PdXRwdXQoaW50IHBvcywgaW50IHBhZCwgZmxvYXQgc2NhbGUsIGludCBzdHJpZGUpIHtcXG4gICAgICByZXR1cm4gcm91bmQoKChmbG9hdChwb3MgKyBwYWQpICsgMS4wKSAqIHNjYWxlIC0gMS4wKSAvIGZsb2F0KHN0cmlkZSkpO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGNvbnZlcnRUb1Bvc2l0aW9uSW5PdXRwdXRGbG9hdChcXG4gICAgICAgIGludCBwb3MsIGludCBwYWQsIGZsb2F0IHNjYWxlLCBpbnQgc3RyaWRlKSB7XFxuICAgICAgcmV0dXJuICgoZmxvYXQocG9zICsgcGFkKSArIDEuMCkgKiBzY2FsZSAtIDEuMCkgLyBmbG9hdChzdHJpZGUpO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGRpc3QoZmxvYXQgeDEsIGZsb2F0IHkxLCBmbG9hdCB4MiwgZmxvYXQgeTIpIHtcXG4gICAgICByZXR1cm4gcG93KHgxIC0geDIsIDIuMCkgKyBwb3coeTEgLSB5MiwgMi4wKTtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBzYW1wbGVMb25nT2Zmc2V0cyhmbG9hdCBoLCBmbG9hdCB3LCBpbnQgZCwgaW50IGspIHtcXG4gICAgICBmbG9hdCBmaCA9IGZyYWN0KGgpO1xcbiAgICAgIGZsb2F0IGZ3ID0gZnJhY3Qodyk7XFxuICAgICAgaW50IGNsSCA9IGludChjZWlsKGgpKTtcXG4gICAgICBpbnQgY2xXID0gaW50KGNlaWwodykpO1xcbiAgICAgIGludCBmbEggPSBpbnQoZmxvb3IoaCkpO1xcbiAgICAgIGludCBmbFcgPSBpbnQoZmxvb3IodykpO1xcbiAgICAgIGZsb2F0IG8xMSA9IGdldExvbmdPZmZzZXRzKGZsSCwgZmxXLCBkLCBrKTtcXG4gICAgICBmbG9hdCBvMTIgPSBnZXRMb25nT2Zmc2V0cyhmbEgsIGNsVywgZCwgayk7XFxuICAgICAgZmxvYXQgbzIxID0gZ2V0TG9uZ09mZnNldHMoY2xILCBmbFcsIGQsIGspO1xcbiAgICAgIGZsb2F0IG8yMiA9IGdldExvbmdPZmZzZXRzKGNsSCwgY2xXLCBkLCBrKTtcXG4gICAgICBmbG9hdCBvMSA9IG1peChvMTEsIG8xMiwgZncpO1xcbiAgICAgIGZsb2F0IG8yID0gbWl4KG8yMSwgbzIyLCBmdyk7XFxuICAgICAgcmV0dXJuIG1peChvMSwgbzIsIGZoKTtcXG4gICAgfVxcblxcbiAgICBpbnQgZmluZE5lYXJlc3RQb3NlKGludCBoLCBpbnQgdykge1xcbiAgICAgIGZsb2F0IHByb2IgPSBnZXRTZWdtZW50YXRpb24oaCwgdyk7XFxuICAgICAgaWYgKHByb2IgPCAxLjApIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gRG9uZShUeWxlcik6IGNvbnZlcnQgZnJvbSBvdXRwdXQgc3BhY2UgaC93IHRvIHN0cmlkZWQgc3BhY2UuXFxuICAgICAgZmxvYXQgc3RyaWRlZEggPSBjb252ZXJ0VG9Qb3NpdGlvbkluT3V0cHV0RmxvYXQoXFxuICAgICAgICBoLCBcIi5jb25jYXQocGFkVCwgXCIsIFwiKS5jb25jYXQoc2NhbGVZLCBcIiwgXCIpLmNvbmNhdChzdHJpZGUsIFwiKTtcXG4gICAgICBmbG9hdCBzdHJpZGVkVyA9IGNvbnZlcnRUb1Bvc2l0aW9uSW5PdXRwdXRGbG9hdChcXG4gICAgICAgIHcsIFwiKS5jb25jYXQocGFkTCwgXCIsIFwiKS5jb25jYXQoc2NhbGVYLCBcIiwgXCIpLmNvbmNhdChzdHJpZGUsIFwiKTtcXG5cXG4gICAgICBmbG9hdCBtaW5EaXN0ID0gMTAwMDAwMC4wO1xcbiAgICAgIGludCBpTWluID0gLTE7XFxuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIikuY29uY2F0KG1heE51bVBlb3BsZSwgXCI7IGkrKykge1xcbiAgICAgICAgZmxvYXQgY3VyRGlzdFN1bSA9IDAuMDtcXG4gICAgICAgIGludCBudW1LcHQgPSAwO1xcbiAgICAgICAgZm9yIChpbnQgayA9IDA7IGsgPCBcIikuY29uY2F0KE5VTV9LRVlQT0lOVFMsIFwiOyBrKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHkgPSBzYW1wbGVMb25nT2Zmc2V0cyhzdHJpZGVkSCwgc3RyaWRlZFcsIDAsIGspO1xcbiAgICAgICAgICBmbG9hdCBkeCA9IHNhbXBsZUxvbmdPZmZzZXRzKHN0cmlkZWRILCBzdHJpZGVkVywgMSwgayk7XFxuXFxuICAgICAgICAgIGZsb2F0IHkgPSBmbG9hdChoKSArIGR5O1xcbiAgICAgICAgICBmbG9hdCB4ID0gZmxvYXQodykgKyBkeDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgcyA9IDA7IHMgPCBcIikuY29uY2F0KHJlZmluZVN0ZXBzLCBcIjsgcysrKSB7XFxuICAgICAgICAgICAgaW50IHlSb3VuZGVkID0gcm91bmQobWluKHksIGZsb2F0KFwiKS5jb25jYXQoaGVpZ2h0IC0gMS4wLCBcIikpKTtcXG4gICAgICAgICAgICBpbnQgeFJvdW5kZWQgPSByb3VuZChtaW4oeCwgZmxvYXQoXCIpLmNvbmNhdCh3aWR0aCAtIDEuMCwgXCIpKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgeVN0cmlkZWQgPSBjb252ZXJ0VG9Qb3NpdGlvbkluT3V0cHV0RmxvYXQoXFxuICAgICAgICAgICAgICB5Um91bmRlZCwgXCIpLmNvbmNhdChwYWRULCBcIiwgXCIpLmNvbmNhdChzY2FsZVksIFwiLCBcIikuY29uY2F0KHN0cmlkZSwgXCIpO1xcbiAgICAgICAgICAgIGZsb2F0IHhTdHJpZGVkID0gY29udmVydFRvUG9zaXRpb25Jbk91dHB1dEZsb2F0KFxcbiAgICAgICAgICAgICAgeFJvdW5kZWQsIFwiKS5jb25jYXQocGFkTCwgXCIsIFwiKS5jb25jYXQoc2NhbGVYLCBcIiwgXCIpLmNvbmNhdChzdHJpZGUsIFwiKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeSA9IHNhbXBsZUxvbmdPZmZzZXRzKHlTdHJpZGVkLCB4U3RyaWRlZCwgMCwgayk7XFxuICAgICAgICAgICAgZmxvYXQgZHggPSBzYW1wbGVMb25nT2Zmc2V0cyh5U3RyaWRlZCwgeFN0cmlkZWQsIDEsIGspO1xcblxcbiAgICAgICAgICAgIHkgPSB5ICsgZHk7XFxuICAgICAgICAgICAgeCA9IHggKyBkeDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCBwb3NlU2NvcmUgPSBnZXRQb3NlcyhpLCBrLCAwKTtcXG4gICAgICAgICAgZmxvYXQgcG9zZVkgPSBnZXRQb3NlcyhpLCBrLCAxKTtcXG4gICAgICAgICAgZmxvYXQgcG9zZVggPSBnZXRQb3NlcyhpLCBrLCAyKTtcXG4gICAgICAgICAgaWYgKHBvc2VTY29yZSA+IFwiKS5jb25jYXQobWluS3B0U2NvcmUsIFwiKSB7XFxuICAgICAgICAgICAgbnVtS3B0ID0gbnVtS3B0ICsgMTtcXG4gICAgICAgICAgICBjdXJEaXN0U3VtID0gY3VyRGlzdFN1bSArIGRpc3QoeCwgeSwgcG9zZVgsIHBvc2VZKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG51bUtwdCA+IDAgJiYgY3VyRGlzdFN1bSAvIGZsb2F0KG51bUtwdCkgPCBtaW5EaXN0KSB7XFxuICAgICAgICAgIG1pbkRpc3QgPSBjdXJEaXN0U3VtIC8gZmxvYXQobnVtS3B0KTtcXG4gICAgICAgICAgaU1pbiA9IGk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpTWluO1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IG5lYXJlc3RQb3NlID0gZmluZE5lYXJlc3RQb3NlKGNvb3Jkc1swXSwgY29vcmRzWzFdKTtcXG4gICAgICAgIHNldE91dHB1dChmbG9hdChuZWFyZXN0UG9zZSkpO1xcbiAgICAgIH1cXG4gIFwiKVxuICAgIH07XG4gICAgdmFyIHdlYmdsQmFja2VuZCA9IHRmLmJhY2tlbmQoKTtcbiAgICByZXR1cm4gd2ViZ2xCYWNrZW5kLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3NlZ21lbnRhdGlvbiwgc2hhcGVkTG9uZ09mZnNldHMsIHBvc2VzVGVuc29yXSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmZ1bmN0aW9uIHRvUGVyc29uS1NlZ21lbnRhdGlvbihzZWdtZW50YXRpb24sIGspIHtcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiB0Zi5jYXN0KHRmLmVxdWFsKHNlZ21lbnRhdGlvbiwgdGYuc2NhbGFyKGspKSwgJ2ludDMyJyk7IH0pO1xufVxuZnVuY3Rpb24gdG9QZXJzb25LUGFydFNlZ21lbnRhdGlvbihzZWdtZW50YXRpb24sIGJvZHlQYXJ0cywgaykge1xuICAgIHJldHVybiB0Zi50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRmLnN1Yih0Zi5tdWwodGYuY2FzdCh0Zi5lcXVhbChzZWdtZW50YXRpb24sIHRmLnNjYWxhcihrKSksICdpbnQzMicpLCB0Zi5hZGQoYm9keVBhcnRzLCAxKSksIDEpOyB9KTtcbn1cbmZ1bmN0aW9uIGlzV2ViR2xCYWNrZW5kKCkge1xuICAgIHJldHVybiBnZXRCYWNrZW5kKCkgPT09ICd3ZWJnbCc7XG59XG5mdW5jdGlvbiBkZWNvZGVQZXJzb25JbnN0YW5jZU1hc2tzKHNlZ21lbnRhdGlvbiwgbG9uZ09mZnNldHMsIHBvc2VzLCBoZWlnaHQsIHdpZHRoLCBzdHJpZGUsIF9hLCBwYWRkaW5nLCBtaW5Qb3NlU2NvcmUsIHJlZmluZVN0ZXBzLCBtaW5LZXlwb2ludFNjb3JlLCBtYXhOdW1QZW9wbGUpIHtcbiAgICB2YXIgaW5IZWlnaHQgPSBfYVswXSwgaW5XaWR0aCA9IF9hWzFdO1xuICAgIGlmIChtaW5Qb3NlU2NvcmUgPT09IHZvaWQgMCkgeyBtaW5Qb3NlU2NvcmUgPSAwLjI7IH1cbiAgICBpZiAocmVmaW5lU3RlcHMgPT09IHZvaWQgMCkgeyByZWZpbmVTdGVwcyA9IDg7IH1cbiAgICBpZiAobWluS2V5cG9pbnRTY29yZSA9PT0gdm9pZCAwKSB7IG1pbktleXBvaW50U2NvcmUgPSAwLjM7IH1cbiAgICBpZiAobWF4TnVtUGVvcGxlID09PSB2b2lkIDApIHsgbWF4TnVtUGVvcGxlID0gMTA7IH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3Nlc0Fib3ZlU2NvcmUsIHBlcnNvblNlZ21lbnRhdGlvbnNEYXRhLCBwZXJzb25TZWdtZW50YXRpb25zLCBzZWdtZW50YXRpb25zRGF0YSwgbG9uZ09mZnNldHNEYXRhO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBwb3Nlc0Fib3ZlU2NvcmUgPSBwb3Nlcy5maWx0ZXIoZnVuY3Rpb24gKHBvc2UpIHsgcmV0dXJuIHBvc2Uuc2NvcmUgPj0gbWluUG9zZVNjb3JlOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1dlYkdsQmFja2VuZCgpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uU2VnbWVudGF0aW9ucyA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tzVGVuc29ySW5mbyA9IGRlY29kZU11bHRpcGxlTWFza3NXZWJHbChzZWdtZW50YXRpb24sIGxvbmdPZmZzZXRzLCBwb3Nlc0Fib3ZlU2NvcmUsIGhlaWdodCwgd2lkdGgsIHN0cmlkZSwgW2luSGVpZ2h0LCBpbldpZHRoXSwgcGFkZGluZywgcmVmaW5lU3RlcHMsIG1pbktleXBvaW50U2NvcmUsIG1heE51bVBlb3BsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFza3NUZW5zb3IgPSB0Zi5lbmdpbmUoKS5tYWtlVGVuc29yRnJvbURhdGFJZChtYXNrc1RlbnNvckluZm8uZGF0YUlkLCBtYXNrc1RlbnNvckluZm8uc2hhcGUsIG1hc2tzVGVuc29ySW5mby5kdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zZXNBYm92ZVNjb3JlLm1hcChmdW5jdGlvbiAoXywgaykgeyByZXR1cm4gdG9QZXJzb25LU2VnbWVudGF0aW9uKG1hc2tzVGVuc29yLCBrKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChwZXJzb25TZWdtZW50YXRpb25zLm1hcChmdW5jdGlvbiAobWFzaykgeyByZXR1cm4gbWFzay5kYXRhKCk7IH0pKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBwZXJzb25TZWdtZW50YXRpb25zRGF0YSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2Iuc2VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uU2VnbWVudGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgc2VnbWVudGF0aW9uLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50YXRpb25zRGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbG9uZ09mZnNldHMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGxvbmdPZmZzZXRzRGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uU2VnbWVudGF0aW9uc0RhdGEgPSBkZWNvZGVNdWx0aXBsZU1hc2tzQ1BVKHNlZ21lbnRhdGlvbnNEYXRhLCBsb25nT2Zmc2V0c0RhdGEsIHBvc2VzQWJvdmVTY29yZSwgaGVpZ2h0LCB3aWR0aCwgc3RyaWRlLCBbaW5IZWlnaHQsIGluV2lkdGhdLCBwYWRkaW5nLCByZWZpbmVTdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBwZXJzb25TZWdtZW50YXRpb25zRGF0YS5tYXAoZnVuY3Rpb24gKGRhdGEsIGkpIHsgcmV0dXJuICh7IGRhdGE6IGRhdGEsIHBvc2U6IHBvc2VzQWJvdmVTY29yZVtpXSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTsgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBlcnNvbkluc3RhbmNlUGFydE1hc2tzKHNlZ21lbnRhdGlvbiwgbG9uZ09mZnNldHMsIHBhcnRTZWdtZW50YXRpb24sIHBvc2VzLCBoZWlnaHQsIHdpZHRoLCBzdHJpZGUsIF9hLCBwYWRkaW5nLCBtaW5Qb3NlU2NvcmUsIHJlZmluZVN0ZXBzLCBtaW5LZXlwb2ludFNjb3JlLCBtYXhOdW1QZW9wbGUpIHtcbiAgICB2YXIgaW5IZWlnaHQgPSBfYVswXSwgaW5XaWR0aCA9IF9hWzFdO1xuICAgIGlmIChtaW5Qb3NlU2NvcmUgPT09IHZvaWQgMCkgeyBtaW5Qb3NlU2NvcmUgPSAwLjI7IH1cbiAgICBpZiAocmVmaW5lU3RlcHMgPT09IHZvaWQgMCkgeyByZWZpbmVTdGVwcyA9IDg7IH1cbiAgICBpZiAobWluS2V5cG9pbnRTY29yZSA9PT0gdm9pZCAwKSB7IG1pbktleXBvaW50U2NvcmUgPSAwLjM7IH1cbiAgICBpZiAobWF4TnVtUGVvcGxlID09PSB2b2lkIDApIHsgbWF4TnVtUGVvcGxlID0gMTA7IH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb3Nlc0Fib3ZlU2NvcmUsIHBhcnRTZWdtZW50YXRpb25zQnlQZXJzb25EYXRhLCBwYXJ0U2VnbWVudGF0aW9ucywgc2VnbWVudGF0aW9uc0RhdGEsIGxvbmdPZmZzZXRzRGF0YSwgcGFydFNlZ21lbnRhaW9uRGF0YTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcG9zZXNBYm92ZVNjb3JlID0gcG9zZXMuZmlsdGVyKGZ1bmN0aW9uIChwb3NlKSB7IHJldHVybiBwb3NlLnNjb3JlID49IG1pblBvc2VTY29yZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNXZWJHbEJhY2tlbmQoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIHBhcnRTZWdtZW50YXRpb25zID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFza3NUZW5zb3JJbmZvID0gZGVjb2RlTXVsdGlwbGVNYXNrc1dlYkdsKHNlZ21lbnRhdGlvbiwgbG9uZ09mZnNldHMsIHBvc2VzQWJvdmVTY29yZSwgaGVpZ2h0LCB3aWR0aCwgc3RyaWRlLCBbaW5IZWlnaHQsIGluV2lkdGhdLCBwYWRkaW5nLCByZWZpbmVTdGVwcywgbWluS2V5cG9pbnRTY29yZSwgbWF4TnVtUGVvcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXNrc1RlbnNvciA9IHRmLmVuZ2luZSgpLm1ha2VUZW5zb3JGcm9tRGF0YUlkKG1hc2tzVGVuc29ySW5mby5kYXRhSWQsIG1hc2tzVGVuc29ySW5mby5zaGFwZSwgbWFza3NUZW5zb3JJbmZvLmR0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3Nlc0Fib3ZlU2NvcmUubWFwKGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvUGVyc29uS1BhcnRTZWdtZW50YXRpb24obWFza3NUZW5zb3IsIHBhcnRTZWdtZW50YXRpb24sIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChwYXJ0U2VnbWVudGF0aW9ucy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguZGF0YSgpOyB9KSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcGFydFNlZ21lbnRhdGlvbnNCeVBlcnNvbkRhdGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9iLnNlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRTZWdtZW50YXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBzZWdtZW50YXRpb24uZGF0YSgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbnNEYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsb25nT2Zmc2V0cy5kYXRhKCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbG9uZ09mZnNldHNEYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwYXJ0U2VnbWVudGF0aW9uLmRhdGEoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBwYXJ0U2VnbWVudGFpb25EYXRhID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0U2VnbWVudGF0aW9uc0J5UGVyc29uRGF0YSA9IGRlY29kZU11bHRpcGxlUGFydE1hc2tzQ1BVKHNlZ21lbnRhdGlvbnNEYXRhLCBsb25nT2Zmc2V0c0RhdGEsIHBhcnRTZWdtZW50YWlvbkRhdGEsIHBvc2VzQWJvdmVTY29yZSwgaGVpZ2h0LCB3aWR0aCwgc3RyaWRlLCBbaW5IZWlnaHQsIGluV2lkdGhdLCBwYWRkaW5nLCByZWZpbmVTdGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCBwYXJ0U2VnbWVudGF0aW9uc0J5UGVyc29uRGF0YS5tYXAoZnVuY3Rpb24gKGRhdGEsIGspIHsgcmV0dXJuICh7IHBvc2U6IHBvc2VzQWJvdmVTY29yZVtrXSwgZGF0YTogZGF0YSwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aCB9KTsgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuLy8gYWxnb3JpdGhtIGJhc2VkIG9uIENvdXJzZXJhIExlY3R1cmUgZnJvbSBBbGdvcml0aG1zLCBQYXJ0IDE6XG4vLyBodHRwczovL3d3dy5jb3Vyc2VyYS5vcmcvbGVhcm4vYWxnb3JpdGhtcy1wYXJ0MS9sZWN0dXJlL1pqb1NNL2hlYXBzb3J0XG5mdW5jdGlvbiBoYWxmKGspIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihrIC8gMik7XG59XG52YXIgTWF4SGVhcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXhIZWFwKG1heFNpemUsIGdldEVsZW1lbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLnByaW9yaXR5UXVldWUgPSBuZXcgQXJyYXkobWF4U2l6ZSk7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZFbGVtZW50cyA9IC0xO1xuICAgICAgICB0aGlzLmdldEVsZW1lbnRWYWx1ZSA9IGdldEVsZW1lbnRWYWx1ZTtcbiAgICB9XG4gICAgTWF4SGVhcC5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMucHJpb3JpdHlRdWV1ZVsrK3RoaXMubnVtYmVyT2ZFbGVtZW50c10gPSB4O1xuICAgICAgICB0aGlzLnN3aW0odGhpcy5udW1iZXJPZkVsZW1lbnRzKTtcbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnByaW9yaXR5UXVldWVbMF07XG4gICAgICAgIHRoaXMuZXhjaGFuZ2UoMCwgdGhpcy5udW1iZXJPZkVsZW1lbnRzLS0pO1xuICAgICAgICB0aGlzLnNpbmsoMCk7XG4gICAgICAgIHRoaXMucHJpb3JpdHlRdWV1ZVt0aGlzLm51bWJlck9mRWxlbWVudHMgKyAxXSA9IG51bGw7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfTtcbiAgICBNYXhIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyT2ZFbGVtZW50cyA9PT0gLTE7XG4gICAgfTtcbiAgICBNYXhIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJPZkVsZW1lbnRzICsgMTtcbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlRdWV1ZS5zbGljZSgwLCB0aGlzLm51bWJlck9mRWxlbWVudHMgKyAxKTtcbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlRdWV1ZVswXTtcbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLnN3aW0gPSBmdW5jdGlvbiAoaykge1xuICAgICAgICB3aGlsZSAoayA+IDAgJiYgdGhpcy5sZXNzKGhhbGYoayksIGspKSB7XG4gICAgICAgICAgICB0aGlzLmV4Y2hhbmdlKGssIGhhbGYoaykpO1xuICAgICAgICAgICAgayA9IGhhbGYoayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLnNpbmsgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICB3aGlsZSAoMiAqIGsgPD0gdGhpcy5udW1iZXJPZkVsZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgaiA9IDIgKiBrO1xuICAgICAgICAgICAgaWYgKGogPCB0aGlzLm51bWJlck9mRWxlbWVudHMgJiYgdGhpcy5sZXNzKGosIGogKyAxKSkge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sZXNzKGssIGopKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4Y2hhbmdlKGssIGopO1xuICAgICAgICAgICAgayA9IGo7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLmdldFZhbHVlQXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50VmFsdWUodGhpcy5wcmlvcml0eVF1ZXVlW2ldKTtcbiAgICB9O1xuICAgIE1heEhlYXAucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0KGkpIDwgdGhpcy5nZXRWYWx1ZUF0KGopO1xuICAgIH07XG4gICAgTWF4SGVhcC5wcm90b3R5cGUuZXhjaGFuZ2UgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICB2YXIgdCA9IHRoaXMucHJpb3JpdHlRdWV1ZVtpXTtcbiAgICAgICAgdGhpcy5wcmlvcml0eVF1ZXVlW2ldID0gdGhpcy5wcmlvcml0eVF1ZXVlW2pdO1xuICAgICAgICB0aGlzLnByaW9yaXR5UXVldWVbal0gPSB0O1xuICAgIH07XG4gICAgcmV0dXJuIE1heEhlYXA7XG59KCkpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiBzY29yZUlzTWF4aW11bUluTG9jYWxXaW5kb3coa2V5cG9pbnRJZCwgc2NvcmUsIGhlYXRtYXBZLCBoZWF0bWFwWCwgbG9jYWxNYXhpbXVtUmFkaXVzLCBzY29yZXMpIHtcbiAgICB2YXIgX2EgPSBzY29yZXMuc2hhcGUsIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xuICAgIHZhciBsb2NhbE1heGltdW0gPSB0cnVlO1xuICAgIHZhciB5U3RhcnQgPSBNYXRoLm1heChoZWF0bWFwWSAtIGxvY2FsTWF4aW11bVJhZGl1cywgMCk7XG4gICAgdmFyIHlFbmQgPSBNYXRoLm1pbihoZWF0bWFwWSArIGxvY2FsTWF4aW11bVJhZGl1cyArIDEsIGhlaWdodCk7XG4gICAgZm9yICh2YXIgeUN1cnJlbnQgPSB5U3RhcnQ7IHlDdXJyZW50IDwgeUVuZDsgKyt5Q3VycmVudCkge1xuICAgICAgICB2YXIgeFN0YXJ0ID0gTWF0aC5tYXgoaGVhdG1hcFggLSBsb2NhbE1heGltdW1SYWRpdXMsIDApO1xuICAgICAgICB2YXIgeEVuZCA9IE1hdGgubWluKGhlYXRtYXBYICsgbG9jYWxNYXhpbXVtUmFkaXVzICsgMSwgd2lkdGgpO1xuICAgICAgICBmb3IgKHZhciB4Q3VycmVudCA9IHhTdGFydDsgeEN1cnJlbnQgPCB4RW5kOyArK3hDdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoc2NvcmVzLmdldCh5Q3VycmVudCwgeEN1cnJlbnQsIGtleXBvaW50SWQpID4gc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbE1heGltdW0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxvY2FsTWF4aW11bSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsTWF4aW11bTtcbn1cbi8qKlxuICogQnVpbGRzIGEgcHJpb3JpdHkgcXVldWUgd2l0aCBwYXJ0IGNhbmRpZGF0ZSBwb3NpdGlvbnMgZm9yIGEgc3BlY2lmaWMgaW1hZ2UgaW5cbiAqIHRoZSBiYXRjaC4gRm9yIHRoaXMgd2UgZmluZCBhbGwgbG9jYWwgbWF4aW1hIGluIHRoZSBzY29yZSBtYXBzIHdpdGggc2NvcmVcbiAqIHZhbHVlcyBhYm92ZSBhIHRocmVzaG9sZC4gV2UgY3JlYXRlIGEgc2luZ2xlIHByaW9yaXR5IHF1ZXVlIGFjcm9zcyBhbGwgcGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUGFydFdpdGhTY29yZVF1ZXVlKHNjb3JlVGhyZXNob2xkLCBsb2NhbE1heGltdW1SYWRpdXMsIHNjb3Jlcykge1xuICAgIHZhciBfYSA9IHNjb3Jlcy5zaGFwZSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV0sIG51bUtleXBvaW50cyA9IF9hWzJdO1xuICAgIHZhciBxdWV1ZSA9IG5ldyBNYXhIZWFwKGhlaWdodCAqIHdpZHRoICogbnVtS2V5cG9pbnRzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHNjb3JlID0gX2Euc2NvcmU7XG4gICAgICAgIHJldHVybiBzY29yZTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBoZWF0bWFwWSA9IDA7IGhlYXRtYXBZIDwgaGVpZ2h0OyArK2hlYXRtYXBZKSB7XG4gICAgICAgIGZvciAodmFyIGhlYXRtYXBYID0gMDsgaGVhdG1hcFggPCB3aWR0aDsgKytoZWF0bWFwWCkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cG9pbnRJZCA9IDA7IGtleXBvaW50SWQgPCBudW1LZXlwb2ludHM7ICsra2V5cG9pbnRJZCkge1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IHNjb3Jlcy5nZXQoaGVhdG1hcFksIGhlYXRtYXBYLCBrZXlwb2ludElkKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHBhcnRzIHdpdGggc2NvcmUgZ3JlYXRlciBvciBlcXVhbCB0byB0aHJlc2hvbGQgYXNcbiAgICAgICAgICAgICAgICAvLyByb290IGNhbmRpZGF0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlIDwgc2NvcmVUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIga2V5cG9pbnRzIHdob3NlIHNjb3JlIGlzIG1heGltdW0gaW4gYSBsb2NhbCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlSXNNYXhpbXVtSW5Mb2NhbFdpbmRvdyhrZXlwb2ludElkLCBzY29yZSwgaGVhdG1hcFksIGhlYXRtYXBYLCBsb2NhbE1heGltdW1SYWRpdXMsIHNjb3JlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUuZW5xdWV1ZSh7IHNjb3JlOiBzY29yZSwgcGFydDogeyBoZWF0bWFwWTogaGVhdG1hcFksIGhlYXRtYXBYOiBoZWF0bWFwWCwgaWQ6IGtleXBvaW50SWQgfSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgcGFyZW50Q2hpbGRyZW5UdXBsZXMgPSBQT1NFX0NIQUlOLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcGFyZW50Sm9pbk5hbWUgPSBfYVswXSwgY2hpbGRKb2luTmFtZSA9IF9hWzFdO1xuICAgIHJldHVybiAoW1BBUlRfSURTW3BhcmVudEpvaW5OYW1lXSwgUEFSVF9JRFNbY2hpbGRKb2luTmFtZV1dKTtcbn0pO1xudmFyIHBhcmVudFRvQ2hpbGRFZGdlcyA9IHBhcmVudENoaWxkcmVuVHVwbGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRKb2ludElkID0gX2FbMV07XG4gICAgcmV0dXJuIGNoaWxkSm9pbnRJZDtcbn0pO1xudmFyIGNoaWxkVG9QYXJlbnRFZGdlcyA9IHBhcmVudENoaWxkcmVuVHVwbGVzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcGFyZW50Sm9pbnRJZCA9IF9hWzBdO1xuICAgIHJldHVybiBwYXJlbnRKb2ludElkO1xufSk7XG5mdW5jdGlvbiBnZXREaXNwbGFjZW1lbnQoZWRnZUlkLCBwb2ludCwgZGlzcGxhY2VtZW50cykge1xuICAgIHZhciBudW1FZGdlcyA9IGRpc3BsYWNlbWVudHMuc2hhcGVbMl0gLyAyO1xuICAgIHJldHVybiB7XG4gICAgICAgIHk6IGRpc3BsYWNlbWVudHMuZ2V0KHBvaW50LnksIHBvaW50LngsIGVkZ2VJZCksXG4gICAgICAgIHg6IGRpc3BsYWNlbWVudHMuZ2V0KHBvaW50LnksIHBvaW50LngsIG51bUVkZ2VzICsgZWRnZUlkKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTdHJpZGVkSW5kZXhOZWFyUG9pbnQocG9pbnQsIG91dHB1dFN0cmlkZSwgaGVpZ2h0LCB3aWR0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHk6IGNsYW1wKE1hdGgucm91bmQocG9pbnQueSAvIG91dHB1dFN0cmlkZSksIDAsIGhlaWdodCAtIDEpLFxuICAgICAgICB4OiBjbGFtcChNYXRoLnJvdW5kKHBvaW50LnggLyBvdXRwdXRTdHJpZGUpLCAwLCB3aWR0aCAtIDEpXG4gICAgfTtcbn1cbi8qKlxuICogV2UgZ2V0IGEgbmV3IGtleXBvaW50IGFsb25nIHRoZSBgZWRnZUlkYCBmb3IgdGhlIHBvc2UgaW5zdGFuY2UsIGFzc3VtaW5nXG4gKiB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYGlkU291cmNlYCBwYXJ0IGlzIGFscmVhZHkga25vd24uIEZvciB0aGlzLCB3ZVxuICogZm9sbG93IHRoZSBkaXNwbGFjZW1lbnQgdmVjdG9yIGZyb20gdGhlIHNvdXJjZSB0byB0YXJnZXQgcGFydCAoc3RvcmVkIGluXG4gKiB0aGUgYGlgLXQgY2hhbm5lbCBvZiB0aGUgZGlzcGxhY2VtZW50IHRlbnNvcikuIFRoZSBkaXNwbGFjZWQga2V5cG9pbnRcbiAqIHZlY3RvciBpcyByZWZpbmVkIHVzaW5nIHRoZSBvZmZzZXQgdmVjdG9yIGJ5IGBvZmZzZXRSZWZpbmVTdGVwYCB0aW1lcy5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUb1RhcmdldEtleXBvaW50KGVkZ2VJZCwgc291cmNlS2V5cG9pbnQsIHRhcmdldEtleXBvaW50SWQsIHNjb3Jlc0J1ZmZlciwgb2Zmc2V0cywgb3V0cHV0U3RyaWRlLCBkaXNwbGFjZW1lbnRzLCBvZmZzZXRSZWZpbmVTdGVwKSB7XG4gICAgaWYgKG9mZnNldFJlZmluZVN0ZXAgPT09IHZvaWQgMCkgeyBvZmZzZXRSZWZpbmVTdGVwID0gMjsgfVxuICAgIHZhciBfYSA9IHNjb3Jlc0J1ZmZlci5zaGFwZSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgLy8gTmVhcmVzdCBuZWlnaGJvciBpbnRlcnBvbGF0aW9uIGZvciB0aGUgc291cmNlLT50YXJnZXQgZGlzcGxhY2VtZW50cy5cbiAgICB2YXIgc291cmNlS2V5cG9pbnRJbmRpY2VzID0gZ2V0U3RyaWRlZEluZGV4TmVhclBvaW50KHNvdXJjZUtleXBvaW50LnBvc2l0aW9uLCBvdXRwdXRTdHJpZGUsIGhlaWdodCwgd2lkdGgpO1xuICAgIHZhciBkaXNwbGFjZW1lbnQgPSBnZXREaXNwbGFjZW1lbnQoZWRnZUlkLCBzb3VyY2VLZXlwb2ludEluZGljZXMsIGRpc3BsYWNlbWVudHMpO1xuICAgIHZhciBkaXNwbGFjZWRQb2ludCA9IGFkZFZlY3RvcnMoc291cmNlS2V5cG9pbnQucG9zaXRpb24sIGRpc3BsYWNlbWVudCk7XG4gICAgdmFyIHRhcmdldEtleXBvaW50ID0gZGlzcGxhY2VkUG9pbnQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRSZWZpbmVTdGVwOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldEtleXBvaW50SW5kaWNlcyA9IGdldFN0cmlkZWRJbmRleE5lYXJQb2ludCh0YXJnZXRLZXlwb2ludCwgb3V0cHV0U3RyaWRlLCBoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgdmFyIG9mZnNldFBvaW50ID0gZ2V0T2Zmc2V0UG9pbnQodGFyZ2V0S2V5cG9pbnRJbmRpY2VzLnksIHRhcmdldEtleXBvaW50SW5kaWNlcy54LCB0YXJnZXRLZXlwb2ludElkLCBvZmZzZXRzKTtcbiAgICAgICAgdGFyZ2V0S2V5cG9pbnQgPSBhZGRWZWN0b3JzKHtcbiAgICAgICAgICAgIHg6IHRhcmdldEtleXBvaW50SW5kaWNlcy54ICogb3V0cHV0U3RyaWRlLFxuICAgICAgICAgICAgeTogdGFyZ2V0S2V5cG9pbnRJbmRpY2VzLnkgKiBvdXRwdXRTdHJpZGVcbiAgICAgICAgfSwgeyB4OiBvZmZzZXRQb2ludC54LCB5OiBvZmZzZXRQb2ludC55IH0pO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0S2V5UG9pbnRJbmRpY2VzID0gZ2V0U3RyaWRlZEluZGV4TmVhclBvaW50KHRhcmdldEtleXBvaW50LCBvdXRwdXRTdHJpZGUsIGhlaWdodCwgd2lkdGgpO1xuICAgIHZhciBzY29yZSA9IHNjb3Jlc0J1ZmZlci5nZXQodGFyZ2V0S2V5UG9pbnRJbmRpY2VzLnksIHRhcmdldEtleVBvaW50SW5kaWNlcy54LCB0YXJnZXRLZXlwb2ludElkKTtcbiAgICByZXR1cm4geyBwb3NpdGlvbjogdGFyZ2V0S2V5cG9pbnQsIHBhcnQ6IFBBUlRfTkFNRVNbdGFyZ2V0S2V5cG9pbnRJZF0sIHNjb3JlOiBzY29yZSB9O1xufVxuLyoqXG4gKiBGb2xsb3dzIHRoZSBkaXNwbGFjZW1lbnQgZmllbGRzIHRvIGRlY29kZSB0aGUgZnVsbCBwb3NlIG9mIHRoZSBvYmplY3RcbiAqIGluc3RhbmNlIGdpdmVuIHRoZSBwb3NpdGlvbiBvZiBhIHBhcnQgdGhhdCBhY3RzIGFzIHJvb3QuXG4gKlxuICogQHJldHVybiBBbiBhcnJheSBvZiBkZWNvZGVkIGtleXBvaW50cyBhbmQgdGhlaXIgc2NvcmVzIGZvciBhIHNpbmdsZSBwb3NlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBvc2Uocm9vdCwgc2NvcmVzLCBvZmZzZXRzLCBvdXRwdXRTdHJpZGUsIGRpc3BsYWNlbWVudHNGd2QsIGRpc3BsYWNlbWVudHNCd2QpIHtcbiAgICB2YXIgbnVtUGFydHMgPSBzY29yZXMuc2hhcGVbMl07XG4gICAgdmFyIG51bUVkZ2VzID0gcGFyZW50VG9DaGlsZEVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgaW5zdGFuY2VLZXlwb2ludHMgPSBuZXcgQXJyYXkobnVtUGFydHMpO1xuICAgIC8vIFN0YXJ0IGEgbmV3IGRldGVjdGlvbiBpbnN0YW5jZSBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIHJvb3QuXG4gICAgdmFyIHJvb3RQYXJ0ID0gcm9vdC5wYXJ0LCByb290U2NvcmUgPSByb290LnNjb3JlO1xuICAgIHZhciByb290UG9pbnQgPSBnZXRJbWFnZUNvb3Jkcyhyb290UGFydCwgb3V0cHV0U3RyaWRlLCBvZmZzZXRzKTtcbiAgICBpbnN0YW5jZUtleXBvaW50c1tyb290UGFydC5pZF0gPSB7XG4gICAgICAgIHNjb3JlOiByb290U2NvcmUsXG4gICAgICAgIHBhcnQ6IFBBUlRfTkFNRVNbcm9vdFBhcnQuaWRdLFxuICAgICAgICBwb3NpdGlvbjogcm9vdFBvaW50XG4gICAgfTtcbiAgICAvLyBEZWNvZGUgdGhlIHBhcnQgcG9zaXRpb25zIHVwd2FyZHMgaW4gdGhlIHRyZWUsIGZvbGxvd2luZyB0aGUgYmFja3dhcmRcbiAgICAvLyBkaXNwbGFjZW1lbnRzLlxuICAgIGZvciAodmFyIGVkZ2UgPSBudW1FZGdlcyAtIDE7IGVkZ2UgPj0gMDsgLS1lZGdlKSB7XG4gICAgICAgIHZhciBzb3VyY2VLZXlwb2ludElkID0gcGFyZW50VG9DaGlsZEVkZ2VzW2VkZ2VdO1xuICAgICAgICB2YXIgdGFyZ2V0S2V5cG9pbnRJZCA9IGNoaWxkVG9QYXJlbnRFZGdlc1tlZGdlXTtcbiAgICAgICAgaWYgKGluc3RhbmNlS2V5cG9pbnRzW3NvdXJjZUtleXBvaW50SWRdICYmXG4gICAgICAgICAgICAhaW5zdGFuY2VLZXlwb2ludHNbdGFyZ2V0S2V5cG9pbnRJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlS2V5cG9pbnRzW3RhcmdldEtleXBvaW50SWRdID0gdHJhdmVyc2VUb1RhcmdldEtleXBvaW50KGVkZ2UsIGluc3RhbmNlS2V5cG9pbnRzW3NvdXJjZUtleXBvaW50SWRdLCB0YXJnZXRLZXlwb2ludElkLCBzY29yZXMsIG9mZnNldHMsIG91dHB1dFN0cmlkZSwgZGlzcGxhY2VtZW50c0J3ZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGVjb2RlIHRoZSBwYXJ0IHBvc2l0aW9ucyBkb3dud2FyZHMgaW4gdGhlIHRyZWUsIGZvbGxvd2luZyB0aGUgZm9yd2FyZFxuICAgIC8vIGRpc3BsYWNlbWVudHMuXG4gICAgZm9yICh2YXIgZWRnZSA9IDA7IGVkZ2UgPCBudW1FZGdlczsgKytlZGdlKSB7XG4gICAgICAgIHZhciBzb3VyY2VLZXlwb2ludElkID0gY2hpbGRUb1BhcmVudEVkZ2VzW2VkZ2VdO1xuICAgICAgICB2YXIgdGFyZ2V0S2V5cG9pbnRJZCA9IHBhcmVudFRvQ2hpbGRFZGdlc1tlZGdlXTtcbiAgICAgICAgaWYgKGluc3RhbmNlS2V5cG9pbnRzW3NvdXJjZUtleXBvaW50SWRdICYmXG4gICAgICAgICAgICAhaW5zdGFuY2VLZXlwb2ludHNbdGFyZ2V0S2V5cG9pbnRJZF0pIHtcbiAgICAgICAgICAgIGluc3RhbmNlS2V5cG9pbnRzW3RhcmdldEtleXBvaW50SWRdID0gdHJhdmVyc2VUb1RhcmdldEtleXBvaW50KGVkZ2UsIGluc3RhbmNlS2V5cG9pbnRzW3NvdXJjZUtleXBvaW50SWRdLCB0YXJnZXRLZXlwb2ludElkLCBzY29yZXMsIG9mZnNldHMsIG91dHB1dFN0cmlkZSwgZGlzcGxhY2VtZW50c0Z3ZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlS2V5cG9pbnRzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5mdW5jdGlvbiB3aXRoaW5ObXNSYWRpdXNPZkNvcnJlc3BvbmRpbmdQb2ludChwb3Nlcywgc3F1YXJlZE5tc1JhZGl1cywgX2EsIGtleXBvaW50SWQpIHtcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgIHJldHVybiBwb3Nlcy5zb21lKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIga2V5cG9pbnRzID0gX2Eua2V5cG9pbnRzO1xuICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0tleXBvaW50ID0ga2V5cG9pbnRzW2tleXBvaW50SWRdLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlKHksIHgsIGNvcnJlc3BvbmRpbmdLZXlwb2ludC55LCBjb3JyZXNwb25kaW5nS2V5cG9pbnQueCkgPD1cbiAgICAgICAgICAgIHNxdWFyZWRObXNSYWRpdXM7XG4gICAgfSk7XG59XG4vKiBTY29yZSB0aGUgbmV3bHkgcHJvcG9zZWQgb2JqZWN0IGluc3RhbmNlIHdpdGhvdXQgdGFraW5nIGludG8gYWNjb3VudFxuICogdGhlIHNjb3JlcyBvZiB0aGUgcGFydHMgdGhhdCBvdmVybGFwIHdpdGggYW55IHByZXZpb3VzbHkgZGV0ZWN0ZWRcbiAqIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVNjb3JlKGV4aXN0aW5nUG9zZXMsIHNxdWFyZWRObXNSYWRpdXMsIGluc3RhbmNlS2V5cG9pbnRzKSB7XG4gICAgdmFyIG5vdE92ZXJsYXBwZWRLZXlwb2ludFNjb3JlcyA9IGluc3RhbmNlS2V5cG9pbnRzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBfYSwga2V5cG9pbnRJZCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgc2NvcmUgPSBfYS5zY29yZTtcbiAgICAgICAgaWYgKCF3aXRoaW5ObXNSYWRpdXNPZkNvcnJlc3BvbmRpbmdQb2ludChleGlzdGluZ1Bvc2VzLCBzcXVhcmVkTm1zUmFkaXVzLCBwb3NpdGlvbiwga2V5cG9pbnRJZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzY29yZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIDAuMCk7XG4gICAgcmV0dXJuIG5vdE92ZXJsYXBwZWRLZXlwb2ludFNjb3JlcyAvPSBpbnN0YW5jZUtleXBvaW50cy5sZW5ndGg7XG59XG4vLyBBIHBvaW50ICh5LCB4KSBpcyBjb25zaWRlcmVkIGFzIHJvb3QgcGFydCBjYW5kaWRhdGUgaWYgaXRzIHNjb3JlIGlzIGFcbi8vIG1heGltdW0gaW4gYSB3aW5kb3cgfHkgLSB5J3wgPD0ga0xvY2FsTWF4aW11bVJhZGl1cywgfHggLSB4J3wgPD1cbi8vIGtMb2NhbE1heGltdW1SYWRpdXMuXG52YXIga0xvY2FsTWF4aW11bVJhZGl1cyA9IDE7XG4vKipcbiAqIERldGVjdHMgbXVsdGlwbGUgcG9zZXMgYW5kIGZpbmRzIHRoZWlyIHBhcnRzIGZyb20gcGFydCBzY29yZXMgYW5kXG4gKiBkaXNwbGFjZW1lbnQgdmVjdG9ycy4gSXQgcmV0dXJucyB1cCB0byBgbWF4RGV0ZWN0aW9uc2Agb2JqZWN0IGluc3RhbmNlXG4gKiBkZXRlY3Rpb25zIGluIGRlY3JlYXNpbmcgcm9vdCBzY29yZSBvcmRlci4gSXQgd29ya3MgYXMgZm9sbG93czogV2UgZmlyc3RcbiAqIGNyZWF0ZSBhIHByaW9yaXR5IHF1ZXVlIHdpdGggbG9jYWwgcGFydCBzY29yZSBtYXhpbWEgYWJvdmVcbiAqIGBzY29yZVRocmVzaG9sZGAsIGNvbnNpZGVyaW5nIGFsbCBwYXJ0cyBhdCB0aGUgc2FtZSB0aW1lLiBUaGVuIHdlXG4gKiBpdGVyYXRpdmVseSBwdWxsIHRoZSB0b3AgIGVsZW1lbnQgb2YgdGhlIHF1ZXVlIChpbiBkZWNyZWFzaW5nIHNjb3JlIG9yZGVyKVxuICogYW5kIHRyZWF0IGl0IGFzIGEgcm9vdCBjYW5kaWRhdGUgZm9yIGEgbmV3IG9iamVjdCBpbnN0YW5jZS4gVG8gYXZvaWRcbiAqIGR1cGxpY2F0ZSBkZXRlY3Rpb25zLCB3ZSByZWplY3QgdGhlIHJvb3QgY2FuZGlkYXRlIGlmIGl0IGlzIHdpdGhpbiBhIGRpc2tcbiAqIG9mIGBubXNSYWRpdXNgIHBpeGVscyBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHBhcnQgb2YgYSBwcmV2aW91c2x5IGRldGVjdGVkXG4gKiBpbnN0YW5jZSwgd2hpY2ggaXMgYSBmb3JtIG9mIHBhcnQtYmFzZWQgbm9uLW1heGltdW0gc3VwcHJlc3Npb24gKE5NUykuIElmXG4gKiB0aGUgcm9vdCBjYW5kaWRhdGUgcGFzc2VzIHRoZSBOTVMgY2hlY2ssIHdlIHN0YXJ0IGEgbmV3IG9iamVjdCBpbnN0YW5jZVxuICogZGV0ZWN0aW9uLCB0cmVhdGluZyB0aGUgY29ycmVzcG9uZGluZyBwYXJ0IGFzIHJvb3QgYW5kIGZpbmRpbmcgdGhlXG4gKiBwb3NpdGlvbnMgb2YgdGhlIHJlbWFpbmluZyBwYXJ0cyBieSBmb2xsb3dpbmcgdGhlIGRpc3BsYWNlbWVudCB2ZWN0b3JzXG4gKiBhbG9uZyB0aGUgdHJlZS1zdHJ1Y3R1cmVkIHBhcnQgZ3JhcGguIFdlIGFzc2lnbiB0byB0aGUgbmV3bHkgZGV0ZWN0ZWRcbiAqIGluc3RhbmNlIGEgc2NvcmUgZXF1YWwgdG8gdGhlIHN1bSBvZiBzY29yZXMgb2YgaXRzIHBhcnRzIHdoaWNoIGhhdmUgbm90XG4gKiBiZWVuIGNsYWltZWQgYnkgYSBwcmV2aW91cyBpbnN0YW5jZSAoaS5lLiwgdGhvc2UgYXQgbGVhc3QgYG5tc1JhZGl1c2BcbiAqIHBpeGVscyBhd2F5IGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgcGFydCBvZiBhbGwgcHJldmlvdXNseSBkZXRlY3RlZFxuICogaW5zdGFuY2VzKSwgZGl2aWRlZCBieSB0aGUgdG90YWwgbnVtYmVyIG9mIHBhcnRzIGBudW1QYXJ0c2AuXG4gKlxuICogQHBhcmFtIGhlYXRtYXBTY29yZXMgMy1EIHRlbnNvciB3aXRoIHNoYXBlIGBbaGVpZ2h0LCB3aWR0aCwgbnVtUGFydHNdYC5cbiAqIFRoZSB2YWx1ZSBvZiBoZWF0bWFwU2NvcmVzW3ksIHgsIGtdYCBpcyB0aGUgc2NvcmUgb2YgcGxhY2luZyB0aGUgYGtgLXRoXG4gKiBvYmplY3QgcGFydCBhdCBwb3NpdGlvbiBgKHksIHgpYC5cbiAqXG4gKiBAcGFyYW0gb2Zmc2V0cyAzLUQgdGVuc29yIHdpdGggc2hhcGUgYFtoZWlnaHQsIHdpZHRoLCBudW1QYXJ0cyAqIDJdYC5cbiAqIFRoZSB2YWx1ZSBvZiBbb2Zmc2V0c1t5LCB4LCBrXSwgb2Zmc2V0c1t5LCB4LCBrICsgbnVtUGFydHNdXWAgaXMgdGhlXG4gKiBzaG9ydCByYW5nZSBvZmZzZXQgdmVjdG9yIG9mIHRoZSBga2AtdGggIG9iamVjdCBwYXJ0IGF0IGhlYXRtYXBcbiAqIHBvc2l0aW9uIGAoeSwgeClgLlxuICpcbiAqIEBwYXJhbSBkaXNwbGFjZW1lbnRzRndkIDMtRCB0ZW5zb3Igb2Ygc2hhcGVcbiAqIGBbaGVpZ2h0LCB3aWR0aCwgMiAqIG51bV9lZGdlc11gLCB3aGVyZSBgbnVtX2VkZ2VzID0gbnVtX3BhcnRzIC0gMWAgaXMgdGhlXG4gKiBudW1iZXIgb2YgZWRnZXMgKHBhcmVudC1jaGlsZCBwYWlycykgaW4gdGhlIHRyZWUuIEl0IGNvbnRhaW5zIHRoZSBmb3J3YXJkXG4gKiBkaXNwbGFjZW1lbnRzIGJldHdlZW4gY29uc2VjdXRpdmUgcGFydCBmcm9tIHRoZSByb290IHRvd2FyZHMgdGhlIGxlYXZlcy5cbiAqXG4gKiBAcGFyYW0gZGlzcGxhY2VtZW50c0J3ZCAzLUQgdGVuc29yIG9mIHNoYXBlXG4gKiBgW2hlaWdodCwgd2lkdGgsIDIgKiBudW1fZWRnZXNdYCwgd2hlcmUgYG51bV9lZGdlcyA9IG51bV9wYXJ0cyAtIDFgIGlzIHRoZVxuICogbnVtYmVyIG9mIGVkZ2VzIChwYXJlbnQtY2hpbGQgcGFpcnMpIGluIHRoZSB0cmVlLiBJdCBjb250YWlucyB0aGUgYmFja3dhcmRcbiAqIGRpc3BsYWNlbWVudHMgYmV0d2VlbiBjb25zZWN1dGl2ZSBwYXJ0IGZyb20gdGhlIHJvb3QgdG93YXJkcyB0aGUgbGVhdmVzLlxuICpcbiAqIEBwYXJhbSBvdXRwdXRTdHJpZGUgVGhlIG91dHB1dCBzdHJpZGUgdGhhdCB3YXMgdXNlZCB3aGVuIGZlZWQtZm9yd2FyZGluZ1xuICogdGhyb3VnaCB0aGUgUG9zZU5ldCBtb2RlbC4gIE11c3QgYmUgMzIsIDE2LCBvciA4LlxuICpcbiAqIEBwYXJhbSBtYXhQb3NlRGV0ZWN0aW9ucyBNYXhpbXVtIG51bWJlciBvZiByZXR1cm5lZCBpbnN0YW5jZSBkZXRlY3Rpb25zIHBlclxuICogaW1hZ2UuXG4gKlxuICogQHBhcmFtIHNjb3JlVGhyZXNob2xkIE9ubHkgcmV0dXJuIGluc3RhbmNlIGRldGVjdGlvbnMgdGhhdCBoYXZlIHJvb3QgcGFydFxuICogc2NvcmUgZ3JlYXRlciBvciBlcXVhbCB0byB0aGlzIHZhbHVlLiBEZWZhdWx0cyB0byAwLjUuXG4gKlxuICogQHBhcmFtIG5tc1JhZGl1cyBOb24tbWF4aW11bSBzdXBwcmVzc2lvbiBwYXJ0IGRpc3RhbmNlLiBJdCBuZWVkcyB0byBiZVxuICogc3RyaWN0bHkgcG9zaXRpdmUuIFR3byBwYXJ0cyBzdXBwcmVzcyBlYWNoIG90aGVyIGlmIHRoZXkgYXJlIGxlc3MgdGhhblxuICogYG5tc1JhZGl1c2AgcGl4ZWxzIGF3YXkuIERlZmF1bHRzIHRvIDIwLlxuICpcbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgcG9zZXMgYW5kIHRoZWlyIHNjb3JlcywgZWFjaCBjb250YWluaW5nIGtleXBvaW50cyBhbmRcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGtleXBvaW50IHNjb3Jlcy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlTXVsdGlwbGVQb3NlcyhzY29yZXNCdWZmZXIsIG9mZnNldHNCdWZmZXIsIGRpc3BsYWNlbWVudHNGd2RCdWZmZXIsIGRpc3BsYWNlbWVudHNCd2RCdWZmZXIsIG91dHB1dFN0cmlkZSwgbWF4UG9zZURldGVjdGlvbnMsIHNjb3JlVGhyZXNob2xkLCBubXNSYWRpdXMpIHtcbiAgICBpZiAoc2NvcmVUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBzY29yZVRocmVzaG9sZCA9IDAuNTsgfVxuICAgIGlmIChubXNSYWRpdXMgPT09IHZvaWQgMCkgeyBubXNSYWRpdXMgPSAyMDsgfVxuICAgIHZhciBwb3NlcyA9IFtdO1xuICAgIHZhciBxdWV1ZSA9IGJ1aWxkUGFydFdpdGhTY29yZVF1ZXVlKHNjb3JlVGhyZXNob2xkLCBrTG9jYWxNYXhpbXVtUmFkaXVzLCBzY29yZXNCdWZmZXIpO1xuICAgIHZhciBzcXVhcmVkTm1zUmFkaXVzID0gbm1zUmFkaXVzICogbm1zUmFkaXVzO1xuICAgIC8vIEdlbmVyYXRlIGF0IG1vc3QgbWF4RGV0ZWN0aW9ucyBvYmplY3QgaW5zdGFuY2VzIHBlciBpbWFnZSBpblxuICAgIC8vIGRlY3JlYXNpbmcgcm9vdCBwYXJ0IHNjb3JlIG9yZGVyLlxuICAgIHdoaWxlIChwb3Nlcy5sZW5ndGggPCBtYXhQb3NlRGV0ZWN0aW9ucyAmJiAhcXVldWUuZW1wdHkoKSkge1xuICAgICAgICAvLyBUaGUgdG9wIGVsZW1lbnQgaW4gdGhlIHF1ZXVlIGlzIHRoZSBuZXh0IHJvb3QgY2FuZGlkYXRlLlxuICAgICAgICB2YXIgcm9vdCA9IHF1ZXVlLmRlcXVldWUoKTtcbiAgICAgICAgLy8gUGFydC1iYXNlZCBub24tbWF4aW11bSBzdXBwcmVzc2lvbjogV2UgcmVqZWN0IGEgcm9vdCBjYW5kaWRhdGUgaWYgaXRcbiAgICAgICAgLy8gaXMgd2l0aGluIGEgZGlzayBvZiBgbm1zUmFkaXVzYCBwaXhlbHMgZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwYXJ0IG9mXG4gICAgICAgIC8vIGEgcHJldmlvdXNseSBkZXRlY3RlZCBpbnN0YW5jZS5cbiAgICAgICAgdmFyIHJvb3RJbWFnZUNvb3JkcyA9IGdldEltYWdlQ29vcmRzKHJvb3QucGFydCwgb3V0cHV0U3RyaWRlLCBvZmZzZXRzQnVmZmVyKTtcbiAgICAgICAgaWYgKHdpdGhpbk5tc1JhZGl1c09mQ29ycmVzcG9uZGluZ1BvaW50KHBvc2VzLCBzcXVhcmVkTm1zUmFkaXVzLCByb290SW1hZ2VDb29yZHMsIHJvb3QucGFydC5pZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IGEgbmV3IGRldGVjdGlvbiBpbnN0YW5jZSBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIHJvb3QuXG4gICAgICAgIHZhciBrZXlwb2ludHMgPSBkZWNvZGVQb3NlKHJvb3QsIHNjb3Jlc0J1ZmZlciwgb2Zmc2V0c0J1ZmZlciwgb3V0cHV0U3RyaWRlLCBkaXNwbGFjZW1lbnRzRndkQnVmZmVyLCBkaXNwbGFjZW1lbnRzQndkQnVmZmVyKTtcbiAgICAgICAgdmFyIHNjb3JlID0gZ2V0SW5zdGFuY2VTY29yZShwb3Nlcywgc3F1YXJlZE5tc1JhZGl1cywga2V5cG9pbnRzKTtcbiAgICAgICAgcG9zZXMucHVzaCh7IGtleXBvaW50czoga2V5cG9pbnRzLCBzY29yZTogc2NvcmUgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3Nlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBpbWFnZU5ldE1lYW4gPSBbLTEyMy4xNSwgLTExNS45MCwgLTEwMy4wNl07XG52YXIgUmVzTmV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNOZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzTmV0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFJlc05ldC5wcm90b3R5cGUucHJlcHJvY2Vzc0lucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0Zi5hZGQoaW5wdXQsIGltYWdlTmV0TWVhbik7XG4gICAgfTtcbiAgICBSZXNOZXQucHJvdG90eXBlLm5hbWVPdXRwdXRSZXN1bHRzID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIGRpc3BsYWNlbWVudEJ3ZCA9IHJlc3VsdHNbMF0sIGRpc3BsYWNlbWVudEZ3ZCA9IHJlc3VsdHNbMV0sIGhlYXRtYXAgPSByZXN1bHRzWzJdLCBsb25nT2Zmc2V0cyA9IHJlc3VsdHNbM10sIG9mZnNldHMgPSByZXN1bHRzWzRdLCBwYXJ0SGVhdG1hcHMgPSByZXN1bHRzWzVdLCBzZWdtZW50YXRpb24gPSByZXN1bHRzWzZdLCBwYXJ0T2Zmc2V0cyA9IHJlc3VsdHNbN107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgc2VnbWVudGF0aW9uOiBzZWdtZW50YXRpb24sXG4gICAgICAgICAgICBwYXJ0SGVhdG1hcHM6IHBhcnRIZWF0bWFwcyxcbiAgICAgICAgICAgIGxvbmdPZmZzZXRzOiBsb25nT2Zmc2V0cyxcbiAgICAgICAgICAgIGhlYXRtYXA6IGhlYXRtYXAsXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2Q6IGRpc3BsYWNlbWVudEZ3ZCxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEJ3ZDogZGlzcGxhY2VtZW50QndkLFxuICAgICAgICAgICAgcGFydE9mZnNldHM6IHBhcnRPZmZzZXRzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUmVzTmV0O1xufShCYXNlTW9kZWwpKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBSRVNORVQ1MF9CQVNFX1VSTCA9ICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdGZqcy1tb2RlbHMvc2F2ZWRtb2RlbC9ib2R5cGl4L3Jlc25ldDUwLyc7XG52YXIgTU9CSUxFTkVUX0JBU0VfVVJMID0gJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS90ZmpzLW1vZGVscy9zYXZlZG1vZGVsL2JvZHlwaXgvbW9iaWxlbmV0Lyc7XG4vLyBUaGUgQm9keVBpeCAyLjAgUmVzTmV0NTAgbW9kZWxzIHVzZSB0aGUgbGF0ZXN0IFRlbnNvckZsb3cuanMgMS4wIG1vZGVsXG4vLyBmb3JtYXQuXG5mdW5jdGlvbiByZXNOZXQ1MFNhdmVkTW9kZWwoc3RyaWRlLCBxdWFudEJ5dGVzKSB7XG4gICAgdmFyIGdyYXBoSnNvbiA9IFwibW9kZWwtc3RyaWRlXCIuY29uY2F0KHN0cmlkZSwgXCIuanNvblwiKTtcbiAgICAvLyBxdWFudEJ5dGVzPTQgY29ycmVzcG9uZGluZyB0byB0aGUgbm9uLXF1YW50aXplZCBmdWxsLXByZWNpc2lvbiBTYXZlZE1vZGVsLlxuICAgIGlmIChxdWFudEJ5dGVzID09PSA0KSB7XG4gICAgICAgIHJldHVybiBSRVNORVQ1MF9CQVNFX1VSTCArIFwiZmxvYXQvXCIgKyBncmFwaEpzb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUkVTTkVUNTBfQkFTRV9VUkwgKyBcInF1YW50XCIuY29uY2F0KHF1YW50Qnl0ZXMsIFwiL1wiKSArIGdyYXBoSnNvbjtcbiAgICB9XG59XG4vLyBUaGUgQm9keVBpeCAyLjAgTW9iaWxlTmV0VjEgbW9kZWxzIHVzZSB0aGUgbGF0ZXN0IFRlbnNvckZsb3cuanMgMS4wIG1vZGVsXG4vLyBmb3JtYXQuXG5mdW5jdGlvbiBtb2JpbGVOZXRTYXZlZE1vZGVsKHN0cmlkZSwgbXVsdGlwbGllciwgcXVhbnRCeXRlcykge1xuICAgIHZhciB0b1N0ciA9IHsgMS4wOiAnMTAwJywgMC43NTogJzA3NScsIDAuNTA6ICcwNTAnIH07XG4gICAgdmFyIGdyYXBoSnNvbiA9IFwibW9kZWwtc3RyaWRlXCIuY29uY2F0KHN0cmlkZSwgXCIuanNvblwiKTtcbiAgICAvLyBxdWFudEJ5dGVzPTQgY29ycmVzcG9uZGluZyB0byB0aGUgbm9uLXF1YW50aXplZCBmdWxsLXByZWNpc2lvbiBTYXZlZE1vZGVsLlxuICAgIGlmIChxdWFudEJ5dGVzID09PSA0KSB7XG4gICAgICAgIHJldHVybiBNT0JJTEVORVRfQkFTRV9VUkwgKyBcImZsb2F0L1wiLmNvbmNhdCh0b1N0clttdWx0aXBsaWVyXSwgXCIvXCIpICsgZ3JhcGhKc29uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1PQklMRU5FVF9CQVNFX1VSTCArIFwicXVhbnRcIi5jb25jYXQocXVhbnRCeXRlcywgXCIvXCIpLmNvbmNhdCh0b1N0clttdWx0aXBsaWVyXSwgXCIvXCIpICtcbiAgICAgICAgICAgIGdyYXBoSnNvbjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgX2E7XG5mdW5jdGlvbiBnZXRTaXplRnJvbUltYWdlTGlrZUVsZW1lbnQoaW5wdXQpIHtcbiAgICBpZiAoJ29mZnNldEhlaWdodCcgaW4gaW5wdXQgJiYgaW5wdXQub2Zmc2V0SGVpZ2h0ICE9PSAwXG4gICAgICAgICYmICdvZmZzZXRXaWR0aCcgaW4gaW5wdXQgJiYgaW5wdXQub2Zmc2V0V2lkdGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtpbnB1dC5vZmZzZXRIZWlnaHQsIGlucHV0Lm9mZnNldFdpZHRoXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5wdXQuaGVpZ2h0ICE9IG51bGwgJiYgaW5wdXQud2lkdGggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2lucHV0LmhlaWdodCwgaW5wdXQud2lkdGhdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSFRNTEltYWdlRWxlbWVudCBtdXN0IGhhdmUgaGVpZ2h0IGFuZCB3aWR0aCBhdHRyaWJ1dGVzIHNldC5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2l6ZUZyb21WaWRlb0VsZW1lbnQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdoZWlnaHQnKSAmJiBpbnB1dC5oYXNBdHRyaWJ1dGUoJ3dpZHRoJykpIHtcbiAgICAgICAgLy8gUHJpb3JpdGl6ZXMgdXNlciBzcGVjaWZpZWQgaGVpZ2h0IGFuZCB3aWR0aC5cbiAgICAgICAgLy8gV2UgY2FuJ3QgdGVzdCB0aGUgLmhlaWdodCBhbmQgLndpZHRoIHByb3BlcnRpZXMgZGlyZWN0bHksXG4gICAgICAgIC8vIGJlY2F1c2UgdGhleSBldmFsdWF0ZSB0byAwIGlmIHVuc2V0LlxuICAgICAgICByZXR1cm4gW2lucHV0LmhlaWdodCwgaW5wdXQud2lkdGhdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtpbnB1dC52aWRlb0hlaWdodCwgaW5wdXQudmlkZW9XaWR0aF07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5wdXRTaXplKGlucHV0KSB7XG4gICAgaWYgKCh0eXBlb2YgKEhUTUxDYW52YXNFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkgfHxcbiAgICAgICAgKHR5cGVvZiAoT2Zmc2NyZWVuQ2FudmFzKSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB8fFxuICAgICAgICAodHlwZW9mIChIVE1MSW1hZ2VFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGdldFNpemVGcm9tSW1hZ2VMaWtlRWxlbWVudChpbnB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoSW1hZ2VEYXRhKSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIFtpbnB1dC5oZWlnaHQsIGlucHV0LndpZHRoXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChIVE1MVmlkZW9FbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRTaXplRnJvbVZpZGVvRWxlbWVudChpbnB1dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgdGYuVGVuc29yKSB7XG4gICAgICAgIHJldHVybiBbaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yOiBVbmtub3duIGlucHV0IHR5cGU6IFwiLmNvbmNhdChpbnB1dCwgXCIuXCIpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkSW5wdXRSZXNvbHV0aW9uKHJlc29sdXRpb24sIG91dHB1dFN0cmlkZSkge1xuICAgIHJldHVybiAocmVzb2x1dGlvbiAtIDEpICUgb3V0cHV0U3RyaWRlID09PSAwO1xufVxuZnVuY3Rpb24gdG9WYWxpZElucHV0UmVzb2x1dGlvbihpbnB1dFJlc29sdXRpb24sIG91dHB1dFN0cmlkZSkge1xuICAgIGlmIChpc1ZhbGlkSW5wdXRSZXNvbHV0aW9uKGlucHV0UmVzb2x1dGlvbiwgb3V0cHV0U3RyaWRlKSkge1xuICAgICAgICByZXR1cm4gaW5wdXRSZXNvbHV0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihpbnB1dFJlc29sdXRpb24gLyBvdXRwdXRTdHJpZGUpICogb3V0cHV0U3RyaWRlICsgMTtcbn1cbnZhciBJTlRFUk5BTF9SRVNPTFVUSU9OX1NUUklOR19PUFRJT05TID0ge1xuICAgIGxvdzogJ2xvdycsXG4gICAgbWVkaXVtOiAnbWVkaXVtJyxcbiAgICBoaWdoOiAnaGlnaCcsXG4gICAgZnVsbDogJ2Z1bGwnXG59O1xudmFyIElOVEVSTkFMX1JFU09MVVRJT05fUEVSQ0VOVEFHRVMgPSAoX2EgPSB7fSxcbiAgICBfYVtJTlRFUk5BTF9SRVNPTFVUSU9OX1NUUklOR19PUFRJT05TLmxvd10gPSAwLjI1LFxuICAgIF9hW0lOVEVSTkFMX1JFU09MVVRJT05fU1RSSU5HX09QVElPTlMubWVkaXVtXSA9IDAuNSxcbiAgICBfYVtJTlRFUk5BTF9SRVNPTFVUSU9OX1NUUklOR19PUFRJT05TLmhpZ2hdID0gMC43NSxcbiAgICBfYVtJTlRFUk5BTF9SRVNPTFVUSU9OX1NUUklOR19PUFRJT05TLmZ1bGxdID0gMS4wLFxuICAgIF9hKTtcbnZhciBNSU5fSU5URVJOQUxfUkVTT0xVVElPTiA9IDAuMTtcbnZhciBNQVhfSU5URVJOQUxfUkVTT0xVVElPTiA9IDIuMDtcbmZ1bmN0aW9uIHRvSW50ZXJuYWxSZXNvbHV0aW9uUGVyY2VudGFnZShpbnRlcm5hbFJlc29sdXRpb24pIHtcbiAgICBpZiAodHlwZW9mIGludGVybmFsUmVzb2x1dGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVEVSTkFMX1JFU09MVVRJT05fUEVSQ0VOVEFHRVNbaW50ZXJuYWxSZXNvbHV0aW9uXTtcbiAgICAgICAgdGYudXRpbC5hc3NlcnQodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwic3RyaW5nIHZhbHVlIG9mIGlucHV0UmVzb2x1dGlvbiBtdXN0IGJlIG9uZSBvZiBcIi5jb25jYXQoT2JqZWN0LnZhbHVlcyhJTlRFUk5BTF9SRVNPTFVUSU9OX1NUUklOR19PUFRJT05TKVxuICAgICAgICAgICAgLmpvaW4oJywnKSwgXCIgYnV0IHdhcyBcIikuY29uY2F0KGludGVybmFsUmVzb2x1dGlvbiwgXCIuXCIpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRmLnV0aWwuYXNzZXJ0KHR5cGVvZiBpbnRlcm5hbFJlc29sdXRpb24gPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBpbnRlcm5hbFJlc29sdXRpb24gPD0gTUFYX0lOVEVSTkFMX1JFU09MVVRJT04gJiZcbiAgICAgICAgICAgIGludGVybmFsUmVzb2x1dGlvbiA+PSBNSU5fSU5URVJOQUxfUkVTT0xVVElPTiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXRSZXNvbHV0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtYmVyIGJldHdlZW4gXCIuY29uY2F0KE1JTl9JTlRFUk5BTF9SRVNPTFVUSU9OLCBcIiBhbmQgXCIpLmNvbmNhdChNQVhfSU5URVJOQUxfUkVTT0xVVElPTiwgXCIsIGJ1dCBcIikgK1xuICAgICAgICAgICAgICAgIFwid2FzIFwiLmNvbmNhdChpbnRlcm5hbFJlc29sdXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsUmVzb2x1dGlvbjtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0lucHV0UmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoKGludGVybmFsUmVzb2x1dGlvbiwgb3V0cHV0U3RyaWRlLCBfYSkge1xuICAgIHZhciBpbnB1dEhlaWdodCA9IF9hWzBdLCBpbnB1dFdpZHRoID0gX2FbMV07XG4gICAgdmFyIGludGVybmFsUmVzb2x1dGlvblBlcmNlbnRhZ2UgPSB0b0ludGVybmFsUmVzb2x1dGlvblBlcmNlbnRhZ2UoaW50ZXJuYWxSZXNvbHV0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB0b1ZhbGlkSW5wdXRSZXNvbHV0aW9uKGlucHV0SGVpZ2h0ICogaW50ZXJuYWxSZXNvbHV0aW9uUGVyY2VudGFnZSwgb3V0cHV0U3RyaWRlKSxcbiAgICAgICAgdG9WYWxpZElucHV0UmVzb2x1dGlvbihpbnB1dFdpZHRoICogaW50ZXJuYWxSZXNvbHV0aW9uUGVyY2VudGFnZSwgb3V0cHV0U3RyaWRlKVxuICAgIF07XG59XG5mdW5jdGlvbiB0b0lucHV0VGVuc29yKGlucHV0KSB7XG4gICAgLy8gVE9ETzogdGYuYnJvd3Nlci5mcm9tUGl4ZWxzIHR5cGVzIHRvIHN1cHBvcnQgT2Zmc2NyZWVuQ2FudmFzXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIHRmLlRlbnNvciA/IGlucHV0IDogdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKGlucHV0KTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUFuZFBhZFRvKGltYWdlVGVuc29yLCBfYSwgZmxpcEhvcml6b250YWwpIHtcbiAgICB2YXIgdGFyZ2V0SCA9IF9hWzBdLCB0YXJnZXRXID0gX2FbMV07XG4gICAgaWYgKGZsaXBIb3Jpem9udGFsID09PSB2b2lkIDApIHsgZmxpcEhvcml6b250YWwgPSBmYWxzZTsgfVxuICAgIHZhciBfYiA9IGltYWdlVGVuc29yLnNoYXBlLCBoZWlnaHQgPSBfYlswXSwgd2lkdGggPSBfYlsxXTtcbiAgICB2YXIgdGFyZ2V0QXNwZWN0ID0gdGFyZ2V0VyAvIHRhcmdldEg7XG4gICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIHZhciByZXNpemVXO1xuICAgIHZhciByZXNpemVIO1xuICAgIHZhciBwYWRMO1xuICAgIHZhciBwYWRSO1xuICAgIHZhciBwYWRUO1xuICAgIHZhciBwYWRCO1xuICAgIGlmIChhc3BlY3QgPiB0YXJnZXRBc3BlY3QpIHtcbiAgICAgICAgLy8gcmVzaXplIHRvIGhhdmUgdGhlIGxhcmdlciBkaW1lbnNpb24gbWF0Y2ggdGhlIHNoYXBlLlxuICAgICAgICByZXNpemVXID0gdGFyZ2V0VztcbiAgICAgICAgcmVzaXplSCA9IE1hdGguY2VpbChyZXNpemVXIC8gYXNwZWN0KTtcbiAgICAgICAgdmFyIHBhZEhlaWdodCA9IHRhcmdldEggLSByZXNpemVIO1xuICAgICAgICBwYWRMID0gMDtcbiAgICAgICAgcGFkUiA9IDA7XG4gICAgICAgIHBhZFQgPSBNYXRoLmZsb29yKHBhZEhlaWdodCAvIDIpO1xuICAgICAgICBwYWRCID0gdGFyZ2V0SCAtIChyZXNpemVIICsgcGFkVCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXNpemVIID0gdGFyZ2V0SDtcbiAgICAgICAgcmVzaXplVyA9IE1hdGguY2VpbCh0YXJnZXRIICogYXNwZWN0KTtcbiAgICAgICAgdmFyIHBhZFdpZHRoID0gdGFyZ2V0VyAtIHJlc2l6ZVc7XG4gICAgICAgIHBhZEwgPSBNYXRoLmZsb29yKHBhZFdpZHRoIC8gMik7XG4gICAgICAgIHBhZFIgPSB0YXJnZXRXIC0gKHJlc2l6ZVcgKyBwYWRMKTtcbiAgICAgICAgcGFkVCA9IDA7XG4gICAgICAgIHBhZEIgPSAwO1xuICAgIH1cbiAgICB2YXIgcmVzaXplZEFuZFBhZGRlZCA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNpemUgdG8gaGF2ZSBsYXJnZXN0IGRpbWVuc2lvbiBtYXRjaCBpbWFnZVxuICAgICAgICB2YXIgcmVzaXplZDtcbiAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXNpemVkID0gdGYuaW1hZ2UucmVzaXplQmlsaW5lYXIodGYucmV2ZXJzZShpbWFnZVRlbnNvciwgMSksIFtyZXNpemVILCByZXNpemVXXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNpemVkID0gdGYuaW1hZ2UucmVzaXplQmlsaW5lYXIoaW1hZ2VUZW5zb3IsIFtyZXNpemVILCByZXNpemVXXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZGRlZCA9IHRmLnBhZDNkKHJlc2l6ZWQsIFtbcGFkVCwgcGFkQl0sIFtwYWRMLCBwYWRSXSwgWzAsIDBdXSk7XG4gICAgICAgIHJldHVybiBwYWRkZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVzaXplZEFuZFBhZGRlZDogcmVzaXplZEFuZFBhZGRlZCwgcGFkZGVkQnk6IFtbcGFkVCwgcGFkQl0sIFtwYWRMLCBwYWRSXV0gfTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ3JvcFRvSW5wdXRUZW5zb3JTaGFwZSh0ZW5zb3IsIF9hLCBfYiwgX2MsIGFwcGx5U2lnbW9pZEFjdGl2YXRpb24pIHtcbiAgICB2YXIgaW5wdXRUZW5zb3JIZWlnaHQgPSBfYVswXSwgaW5wdXRUZW5zb3JXaWR0aCA9IF9hWzFdO1xuICAgIHZhciByZXNpemVkQW5kUGFkZGVkSGVpZ2h0ID0gX2JbMF0sIHJlc2l6ZWRBbmRQYWRkZWRXaWR0aCA9IF9iWzFdO1xuICAgIHZhciBfZCA9IF9jWzBdLCBwYWRUID0gX2RbMF0sIHBhZEIgPSBfZFsxXSwgX2UgPSBfY1sxXSwgcGFkTCA9IF9lWzBdLCBwYWRSID0gX2VbMV07XG4gICAgaWYgKGFwcGx5U2lnbW9pZEFjdGl2YXRpb24gPT09IHZvaWQgMCkgeyBhcHBseVNpZ21vaWRBY3RpdmF0aW9uID0gZmFsc2U7IH1cbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpblJlc2l6ZWRBbmRQYWRkZWQgPSB0Zi5pbWFnZS5yZXNpemVCaWxpbmVhcih0ZW5zb3IsIFtyZXNpemVkQW5kUGFkZGVkSGVpZ2h0LCByZXNpemVkQW5kUGFkZGVkV2lkdGhdLCB0cnVlKTtcbiAgICAgICAgaWYgKGFwcGx5U2lnbW9pZEFjdGl2YXRpb24pIHtcbiAgICAgICAgICAgIGluUmVzaXplZEFuZFBhZGRlZCA9IHRmLnNpZ21vaWQoaW5SZXNpemVkQW5kUGFkZGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlUGFkZGluZ0FuZFJlc2l6ZUJhY2soaW5SZXNpemVkQW5kUGFkZGVkLCBbaW5wdXRUZW5zb3JIZWlnaHQsIGlucHV0VGVuc29yV2lkdGhdLCBbW3BhZFQsIHBhZEJdLCBbcGFkTCwgcGFkUl1dKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVBhZGRpbmdBbmRSZXNpemVCYWNrKHJlc2l6ZWRBbmRQYWRkZWQsIF9hLCBfYikge1xuICAgIHZhciBvcmlnaW5hbEhlaWdodCA9IF9hWzBdLCBvcmlnaW5hbFdpZHRoID0gX2FbMV07XG4gICAgdmFyIF9jID0gX2JbMF0sIHBhZFQgPSBfY1swXSwgcGFkQiA9IF9jWzFdLCBfZCA9IF9iWzFdLCBwYWRMID0gX2RbMF0sIHBhZFIgPSBfZFsxXTtcbiAgICByZXR1cm4gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXRjaGVkSW1hZ2UgPSB0Zi5leHBhbmREaW1zKHJlc2l6ZWRBbmRQYWRkZWQpO1xuICAgICAgICByZXR1cm4gdGYuc3F1ZWV6ZSh0Zi5pbWFnZVxuICAgICAgICAgICAgLmNyb3BBbmRSZXNpemUoYmF0Y2hlZEltYWdlLCBbW1xuICAgICAgICAgICAgICAgIHBhZFQgLyAob3JpZ2luYWxIZWlnaHQgKyBwYWRUICsgcGFkQiAtIDEuMCksXG4gICAgICAgICAgICAgICAgcGFkTCAvIChvcmlnaW5hbFdpZHRoICsgcGFkTCArIHBhZFIgLSAxLjApLFxuICAgICAgICAgICAgICAgIChwYWRUICsgb3JpZ2luYWxIZWlnaHQgLSAxLjApIC9cbiAgICAgICAgICAgICAgICAgICAgKG9yaWdpbmFsSGVpZ2h0ICsgcGFkVCArIHBhZEIgLSAxLjApLFxuICAgICAgICAgICAgICAgIChwYWRMICsgb3JpZ2luYWxXaWR0aCAtIDEuMCkgLyAob3JpZ2luYWxXaWR0aCArIHBhZEwgKyBwYWRSIC0gMS4wKVxuICAgICAgICAgICAgXV0sIFswXSwgW29yaWdpbmFsSGVpZ2h0LCBvcmlnaW5hbFdpZHRoXSksIFswXSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYWRBbmRSZXNpemVUbyhpbnB1dCwgX2EpIHtcbiAgICB2YXIgdGFyZ2V0SCA9IF9hWzBdLCB0YXJnZXRXID0gX2FbMV07XG4gICAgdmFyIF9iID0gZ2V0SW5wdXRTaXplKGlucHV0KSwgaGVpZ2h0ID0gX2JbMF0sIHdpZHRoID0gX2JbMV07XG4gICAgdmFyIHRhcmdldEFzcGVjdCA9IHRhcmdldFcgLyB0YXJnZXRIO1xuICAgIHZhciBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICB2YXIgX2MgPSBbMCwgMCwgMCwgMF0sIHBhZFQgPSBfY1swXSwgcGFkQiA9IF9jWzFdLCBwYWRMID0gX2NbMl0sIHBhZFIgPSBfY1szXTtcbiAgICBpZiAoYXNwZWN0IDwgdGFyZ2V0QXNwZWN0KSB7XG4gICAgICAgIC8vIHBhZHMgdGhlIHdpZHRoXG4gICAgICAgIHBhZFQgPSAwO1xuICAgICAgICBwYWRCID0gMDtcbiAgICAgICAgcGFkTCA9IE1hdGgucm91bmQoMC41ICogKHRhcmdldEFzcGVjdCAqIGhlaWdodCAtIHdpZHRoKSk7XG4gICAgICAgIHBhZFIgPSBNYXRoLnJvdW5kKDAuNSAqICh0YXJnZXRBc3BlY3QgKiBoZWlnaHQgLSB3aWR0aCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcGFkcyB0aGUgaGVpZ2h0XG4gICAgICAgIHBhZFQgPSBNYXRoLnJvdW5kKDAuNSAqICgoMS4wIC8gdGFyZ2V0QXNwZWN0KSAqIHdpZHRoIC0gaGVpZ2h0KSk7XG4gICAgICAgIHBhZEIgPSBNYXRoLnJvdW5kKDAuNSAqICgoMS4wIC8gdGFyZ2V0QXNwZWN0KSAqIHdpZHRoIC0gaGVpZ2h0KSk7XG4gICAgICAgIHBhZEwgPSAwO1xuICAgICAgICBwYWRSID0gMDtcbiAgICB9XG4gICAgdmFyIHJlc2l6ZWQgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltYWdlVGVuc29yID0gdG9JbnB1dFRlbnNvcihpbnB1dCk7XG4gICAgICAgIGltYWdlVGVuc29yID0gdGYucGFkM2QoaW1hZ2VUZW5zb3IsIFtbcGFkVCwgcGFkQl0sIFtwYWRMLCBwYWRSXSwgWzAsIDBdXSk7XG4gICAgICAgIHJldHVybiB0Zi5pbWFnZS5yZXNpemVCaWxpbmVhcihpbWFnZVRlbnNvciwgW3RhcmdldEgsIHRhcmdldFddKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyByZXNpemVkOiByZXNpemVkLCBwYWRkaW5nOiB7IHRvcDogcGFkVCwgbGVmdDogcGFkTCwgcmlnaHQ6IHBhZFIsIGJvdHRvbTogcGFkQiB9IH07XG59XG5mdW5jdGlvbiB0b1RlbnNvckJ1ZmZlcnMzRCh0ZW5zb3JzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5hbGwodGVuc29ycy5tYXAoZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmJ1ZmZlcigpOyB9KSldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNjYWxlUG9zZShwb3NlLCBzY2FsZVksIHNjYWxlWCwgb2Zmc2V0WSwgb2Zmc2V0WCkge1xuICAgIGlmIChvZmZzZXRZID09PSB2b2lkIDApIHsgb2Zmc2V0WSA9IDA7IH1cbiAgICBpZiAob2Zmc2V0WCA9PT0gdm9pZCAwKSB7IG9mZnNldFggPSAwOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NvcmU6IHBvc2Uuc2NvcmUsXG4gICAgICAgIGtleXBvaW50czogcG9zZS5rZXlwb2ludHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNjb3JlID0gX2Euc2NvcmUsIHBhcnQgPSBfYS5wYXJ0LCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc2NvcmU6IHNjb3JlLFxuICAgICAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCAqIHNjYWxlWCArIG9mZnNldFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvc2l0aW9uLnkgKiBzY2FsZVkgKyBvZmZzZXRZXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNjYWxlUG9zZXMocG9zZXMsIHNjYWxlWSwgc2NhbGVYLCBvZmZzZXRZLCBvZmZzZXRYKSB7XG4gICAgaWYgKG9mZnNldFkgPT09IHZvaWQgMCkgeyBvZmZzZXRZID0gMDsgfVxuICAgIGlmIChvZmZzZXRYID09PSB2b2lkIDApIHsgb2Zmc2V0WCA9IDA7IH1cbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSAmJiBvZmZzZXRZID09PSAwICYmIG9mZnNldFggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBvc2VzO1xuICAgIH1cbiAgICByZXR1cm4gcG9zZXMubWFwKGZ1bmN0aW9uIChwb3NlKSB7IHJldHVybiBzY2FsZVBvc2UocG9zZSwgc2NhbGVZLCBzY2FsZVgsIG9mZnNldFksIG9mZnNldFgpOyB9KTtcbn1cbmZ1bmN0aW9uIGZsaXBQb3NlSG9yaXpvbnRhbChwb3NlLCBpbWFnZVdpZHRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NvcmU6IHBvc2Uuc2NvcmUsXG4gICAgICAgIGtleXBvaW50czogcG9zZS5rZXlwb2ludHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHNjb3JlID0gX2Euc2NvcmUsIHBhcnQgPSBfYS5wYXJ0LCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc2NvcmU6IHNjb3JlLFxuICAgICAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHsgeDogaW1hZ2VXaWR0aCAtIDEgLSBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH07XG59XG5mdW5jdGlvbiBmbGlwUG9zZXNIb3Jpem9udGFsKHBvc2VzLCBpbWFnZVdpZHRoKSB7XG4gICAgaWYgKGltYWdlV2lkdGggPD0gMCkge1xuICAgICAgICByZXR1cm4gcG9zZXM7XG4gICAgfVxuICAgIHJldHVybiBwb3Nlcy5tYXAoZnVuY3Rpb24gKHBvc2UpIHsgcmV0dXJuIGZsaXBQb3NlSG9yaXpvbnRhbChwb3NlLCBpbWFnZVdpZHRoKTsgfSk7XG59XG5mdW5jdGlvbiBzY2FsZUFuZEZsaXBQb3Nlcyhwb3NlcywgX2EsIF9iLCBwYWRkaW5nLCBmbGlwSG9yaXpvbnRhbCkge1xuICAgIHZhciBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcbiAgICB2YXIgaW5wdXRSZXNvbHV0aW9uSGVpZ2h0ID0gX2JbMF0sIGlucHV0UmVzb2x1dGlvbldpZHRoID0gX2JbMV07XG4gICAgdmFyIHNjYWxlWSA9IChoZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKSAvIChpbnB1dFJlc29sdXRpb25IZWlnaHQpO1xuICAgIHZhciBzY2FsZVggPSAod2lkdGggKyBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0KSAvIChpbnB1dFJlc29sdXRpb25XaWR0aCk7XG4gICAgdmFyIHNjYWxlZFBvc2VzID0gc2NhbGVQb3Nlcyhwb3Nlcywgc2NhbGVZLCBzY2FsZVgsIC1wYWRkaW5nLnRvcCwgLXBhZGRpbmcubGVmdCk7XG4gICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgIHJldHVybiBmbGlwUG9zZXNIb3Jpem9udGFsKHNjYWxlZFBvc2VzLCB3aWR0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NhbGVkUG9zZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG52YXIgQVBQTFlfU0lHTU9JRF9BQ1RJVkFUSU9OID0gdHJ1ZTtcbnZhciBGTElQX1BPU0VTX0FGVEVSX1NDQUxJTkcgPSBmYWxzZTtcbi8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIGxvYWRpbmcgTW9iaWxlTmV0VjEgYmFzZWQgQm9keVBpeC5cbi8vXG4vLyAoQW5kIGZvciByZWZlcmVuY2VzLCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBsb2FkaW5nIFJlc05ldFxuLy8gYmFzZWQgUG9zZU5ldCBpcyBhbHNvIGluY2x1ZGVkKS5cbi8vXG4vLyBgYGBcbi8vIGNvbnN0IFJFU05FVF9DT05GSUcgPSB7XG4vLyAgIGFyY2hpdGVjdHVyZTogJ1Jlc05ldDUwJyxcbi8vICAgb3V0cHV0U3RyaWRlOiAzMixcbi8vICAgcXVhbnRCeXRlczogNCxcbi8vIH0gYXMgTW9kZWxDb25maWc7XG4vLyBgYGBcbnZhciBNT0JJTEVORVRfVjFfQ09ORklHID0ge1xuICAgIGFyY2hpdGVjdHVyZTogJ01vYmlsZU5ldFYxJyxcbiAgICBvdXRwdXRTdHJpZGU6IDE2LFxuICAgIHF1YW50Qnl0ZXM6IDQsXG4gICAgbXVsdGlwbGllcjogMC43NSxcbn07XG52YXIgVkFMSURfQVJDSElURUNUVVJFID0gWydNb2JpbGVOZXRWMScsICdSZXNOZXQ1MCddO1xudmFyIFZBTElEX1NUUklERSA9IHtcbiAgICAnTW9iaWxlTmV0VjEnOiBbOCwgMTYsIDMyXSxcbiAgICAnUmVzTmV0NTAnOiBbMzIsIDE2XVxufTtcbnZhciBWQUxJRF9NVUxUSVBMSUVSID0ge1xuICAgICdNb2JpbGVOZXRWMSc6IFswLjUwLCAwLjc1LCAxLjBdLFxuICAgICdSZXNOZXQ1MCc6IFsxLjBdXG59O1xudmFyIFZBTElEX1FVQU5UX0JZVEVTID0gWzEsIDIsIDRdO1xuZnVuY3Rpb24gdmFsaWRhdGVNb2RlbENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwgTU9CSUxFTkVUX1YxX0NPTkZJRztcbiAgICBpZiAoY29uZmlnLmFyY2hpdGVjdHVyZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5hcmNoaXRlY3R1cmUgPSAnTW9iaWxlTmV0VjEnO1xuICAgIH1cbiAgICBpZiAoVkFMSURfQVJDSElURUNUVVJFLmluZGV4T2YoY29uZmlnLmFyY2hpdGVjdHVyZSkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJjaGl0ZWN0dXJlIFwiLmNvbmNhdChjb25maWcuYXJjaGl0ZWN0dXJlLCBcIi4gXCIpICtcbiAgICAgICAgICAgIFwiU2hvdWxkIGJlIG9uZSBvZiBcIi5jb25jYXQoVkFMSURfQVJDSElURUNUVVJFKSk7XG4gICAgfVxuICAgIGlmIChjb25maWcub3V0cHV0U3RyaWRlID09IG51bGwpIHtcbiAgICAgICAgY29uZmlnLm91dHB1dFN0cmlkZSA9IDE2O1xuICAgIH1cbiAgICBpZiAoVkFMSURfU1RSSURFW2NvbmZpZy5hcmNoaXRlY3R1cmVdLmluZGV4T2YoY29uZmlnLm91dHB1dFN0cmlkZSkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3V0cHV0U3RyaWRlIFwiLmNvbmNhdChjb25maWcub3V0cHV0U3RyaWRlLCBcIi4gXCIpICtcbiAgICAgICAgICAgIFwiU2hvdWxkIGJlIG9uZSBvZiBcIi5jb25jYXQoVkFMSURfU1RSSURFW2NvbmZpZy5hcmNoaXRlY3R1cmVdLCBcIiBcIikgK1xuICAgICAgICAgICAgXCJmb3IgYXJjaGl0ZWN0dXJlIFwiLmNvbmNhdChjb25maWcuYXJjaGl0ZWN0dXJlLCBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLm11bHRpcGxpZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25maWcubXVsdGlwbGllciA9IDEuMDtcbiAgICB9XG4gICAgaWYgKFZBTElEX01VTFRJUExJRVJbY29uZmlnLmFyY2hpdGVjdHVyZV0uaW5kZXhPZihjb25maWcubXVsdGlwbGllcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbXVsdGlwbGllciBcIi5jb25jYXQoY29uZmlnLm11bHRpcGxpZXIsIFwiLiBcIikgK1xuICAgICAgICAgICAgXCJTaG91bGQgYmUgb25lIG9mIFwiLmNvbmNhdChWQUxJRF9NVUxUSVBMSUVSW2NvbmZpZy5hcmNoaXRlY3R1cmVdLCBcIiBcIikgK1xuICAgICAgICAgICAgXCJmb3IgYXJjaGl0ZWN0dXJlIFwiLmNvbmNhdChjb25maWcuYXJjaGl0ZWN0dXJlLCBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnF1YW50Qnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICBjb25maWcucXVhbnRCeXRlcyA9IDQ7XG4gICAgfVxuICAgIGlmIChWQUxJRF9RVUFOVF9CWVRFUy5pbmRleE9mKGNvbmZpZy5xdWFudEJ5dGVzKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBxdWFudEJ5dGVzIFwiLmNvbmNhdChjb25maWcucXVhbnRCeXRlcywgXCIuIFwiKSArXG4gICAgICAgICAgICBcIlNob3VsZCBiZSBvbmUgb2YgXCIuY29uY2F0KFZBTElEX1FVQU5UX0JZVEVTLCBcIiBcIikgK1xuICAgICAgICAgICAgXCJmb3IgYXJjaGl0ZWN0dXJlIFwiLmNvbmNhdChjb25maWcuYXJjaGl0ZWN0dXJlLCBcIi5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xufVxudmFyIFBFUlNPTl9JTkZFUkVOQ0VfQ09ORklHID0ge1xuICAgIGZsaXBIb3Jpem9udGFsOiBmYWxzZSxcbiAgICBpbnRlcm5hbFJlc29sdXRpb246ICdtZWRpdW0nLFxuICAgIHNlZ21lbnRhdGlvblRocmVzaG9sZDogMC43LFxuICAgIG1heERldGVjdGlvbnM6IDEwLFxuICAgIHNjb3JlVGhyZXNob2xkOiAwLjQsXG4gICAgbm1zUmFkaXVzOiAyMCxcbn07XG52YXIgTVVMVElfUEVSU09OX0lOU1RBTkNFX0lORkVSRU5DRV9DT05GSUcgPSB7XG4gICAgZmxpcEhvcml6b250YWw6IGZhbHNlLFxuICAgIGludGVybmFsUmVzb2x1dGlvbjogJ21lZGl1bScsXG4gICAgc2VnbWVudGF0aW9uVGhyZXNob2xkOiAwLjcsXG4gICAgbWF4RGV0ZWN0aW9uczogMTAsXG4gICAgc2NvcmVUaHJlc2hvbGQ6IDAuNCxcbiAgICBubXNSYWRpdXM6IDIwLFxuICAgIG1pbktleXBvaW50U2NvcmU6IDAuMyxcbiAgICByZWZpbmVTdGVwczogMTBcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcnNvbkluZmVyZW5jZUNvbmZpZyhjb25maWcpIHtcbiAgICB2YXIgc2VnbWVudGF0aW9uVGhyZXNob2xkID0gY29uZmlnLnNlZ21lbnRhdGlvblRocmVzaG9sZCwgbWF4RGV0ZWN0aW9ucyA9IGNvbmZpZy5tYXhEZXRlY3Rpb25zLCBzY29yZVRocmVzaG9sZCA9IGNvbmZpZy5zY29yZVRocmVzaG9sZCwgbm1zUmFkaXVzID0gY29uZmlnLm5tc1JhZGl1cztcbiAgICBpZiAoc2VnbWVudGF0aW9uVGhyZXNob2xkIDwgMC4wIHx8IHNlZ21lbnRhdGlvblRocmVzaG9sZCA+IDEuMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWdtZW50YXRpb25UaHJlc2hvbGQgXCIuY29uY2F0KHNlZ21lbnRhdGlvblRocmVzaG9sZCwgXCIuIFwiKSArXG4gICAgICAgICAgICBcIlNob3VsZCBiZSBpbiByYW5nZSBbMC4wLCAxLjBdXCIpO1xuICAgIH1cbiAgICBpZiAobWF4RGV0ZWN0aW9ucyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWF4RGV0ZWN0aW9ucyBcIi5jb25jYXQobWF4RGV0ZWN0aW9ucywgXCIuIFwiKSArXG4gICAgICAgICAgICBcIlNob3VsZCBiZSA+IDBcIik7XG4gICAgfVxuICAgIGlmIChzY29yZVRocmVzaG9sZCA8IDAuMCB8fCBzY29yZVRocmVzaG9sZCA+IDEuMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjb3JlVGhyZXNob2xkIFwiLmNvbmNhdChzY29yZVRocmVzaG9sZCwgXCIuIFwiKSArXG4gICAgICAgICAgICBcIlNob3VsZCBiZSBpbiByYW5nZSBbMC4wLCAxLjBdXCIpO1xuICAgIH1cbiAgICBpZiAobm1zUmFkaXVzIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBubXNSYWRpdXMgXCIuY29uY2F0KG5tc1JhZGl1cywgXCIuXCIpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU11bHRpUGVyc29uSW5zdGFuY2VJbmZlcmVuY2VDb25maWcoY29uZmlnKSB7XG4gICAgdmFyIHNlZ21lbnRhdGlvblRocmVzaG9sZCA9IGNvbmZpZy5zZWdtZW50YXRpb25UaHJlc2hvbGQsIG1heERldGVjdGlvbnMgPSBjb25maWcubWF4RGV0ZWN0aW9ucywgc2NvcmVUaHJlc2hvbGQgPSBjb25maWcuc2NvcmVUaHJlc2hvbGQsIG5tc1JhZGl1cyA9IGNvbmZpZy5ubXNSYWRpdXMsIG1pbktleXBvaW50U2NvcmUgPSBjb25maWcubWluS2V5cG9pbnRTY29yZSwgcmVmaW5lU3RlcHMgPSBjb25maWcucmVmaW5lU3RlcHM7XG4gICAgaWYgKHNlZ21lbnRhdGlvblRocmVzaG9sZCA8IDAuMCB8fCBzZWdtZW50YXRpb25UaHJlc2hvbGQgPiAxLjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VnbWVudGF0aW9uVGhyZXNob2xkIFwiLmNvbmNhdChzZWdtZW50YXRpb25UaHJlc2hvbGQsIFwiLiBcIikgK1xuICAgICAgICAgICAgXCJTaG91bGQgYmUgaW4gcmFuZ2UgWzAuMCwgMS4wXVwiKTtcbiAgICB9XG4gICAgaWYgKG1heERldGVjdGlvbnMgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1heERldGVjdGlvbnMgXCIuY29uY2F0KG1heERldGVjdGlvbnMsIFwiLiBcIikgK1xuICAgICAgICAgICAgXCJTaG91bGQgYmUgPiAwXCIpO1xuICAgIH1cbiAgICBpZiAoc2NvcmVUaHJlc2hvbGQgPCAwLjAgfHwgc2NvcmVUaHJlc2hvbGQgPiAxLjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzY29yZVRocmVzaG9sZCBcIi5jb25jYXQoc2NvcmVUaHJlc2hvbGQsIFwiLiBcIikgK1xuICAgICAgICAgICAgXCJTaG91bGQgYmUgaW4gcmFuZ2UgWzAuMCwgMS4wXVwiKTtcbiAgICB9XG4gICAgaWYgKG5tc1JhZGl1cyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm1zUmFkaXVzIFwiLmNvbmNhdChubXNSYWRpdXMsIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChtaW5LZXlwb2ludFNjb3JlIDwgMCB8fCBtaW5LZXlwb2ludFNjb3JlID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1pbktleXBvaW50U2NvcmUgXCIuY29uY2F0KG1pbktleXBvaW50U2NvcmUsIFwiLlwiKSArXG4gICAgICAgICAgICBcIlNob3VsZCBiZSBpbiByYW5nZSBbMC4wLCAxLjBdXCIpO1xuICAgIH1cbiAgICBpZiAocmVmaW5lU3RlcHMgPD0gMCB8fCByZWZpbmVTdGVwcyA+IDIwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVmaW5lU3RlcHMgXCIuY29uY2F0KHJlZmluZVN0ZXBzLCBcIi5cIikgK1xuICAgICAgICAgICAgXCJTaG91bGQgYmUgaW4gcmFuZ2UgWzEsIDIwXVwiKTtcbiAgICB9XG59XG52YXIgQm9keVBpeCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb2R5UGl4KG5ldCkge1xuICAgICAgICB0aGlzLmJhc2VNb2RlbCA9IG5ldDtcbiAgICB9XG4gICAgQm9keVBpeC5wcm90b3R5cGUucHJlZGljdEZvclBlcnNvblNlZ21lbnRhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmJhc2VNb2RlbC5wcmVkaWN0KGlucHV0KSwgc2VnbWVudGF0aW9uID0gX2Euc2VnbWVudGF0aW9uLCBoZWF0bWFwU2NvcmVzID0gX2EuaGVhdG1hcFNjb3Jlcywgb2Zmc2V0cyA9IF9hLm9mZnNldHMsIGRpc3BsYWNlbWVudEZ3ZCA9IF9hLmRpc3BsYWNlbWVudEZ3ZCwgZGlzcGxhY2VtZW50QndkID0gX2EuZGlzcGxhY2VtZW50QndkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VnbWVudExvZ2l0czogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgaGVhdG1hcFNjb3JlczogaGVhdG1hcFNjb3JlcyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2Q6IGRpc3BsYWNlbWVudEZ3ZCxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEJ3ZDogZGlzcGxhY2VtZW50QndkLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQm9keVBpeC5wcm90b3R5cGUucHJlZGljdEZvclBlcnNvblNlZ21lbnRhdGlvbkFuZFBhcnQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5iYXNlTW9kZWwucHJlZGljdChpbnB1dCksIHNlZ21lbnRhdGlvbiA9IF9hLnNlZ21lbnRhdGlvbiwgcGFydEhlYXRtYXBzID0gX2EucGFydEhlYXRtYXBzLCBoZWF0bWFwU2NvcmVzID0gX2EuaGVhdG1hcFNjb3Jlcywgb2Zmc2V0cyA9IF9hLm9mZnNldHMsIGRpc3BsYWNlbWVudEZ3ZCA9IF9hLmRpc3BsYWNlbWVudEZ3ZCwgZGlzcGxhY2VtZW50QndkID0gX2EuZGlzcGxhY2VtZW50QndkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VnbWVudExvZ2l0czogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgcGFydEhlYXRtYXBMb2dpdHM6IHBhcnRIZWF0bWFwcyxcbiAgICAgICAgICAgIGhlYXRtYXBTY29yZXM6IGhlYXRtYXBTY29yZXMsXG4gICAgICAgICAgICBvZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgZGlzcGxhY2VtZW50RndkOiBkaXNwbGFjZW1lbnRGd2QsXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRCd2Q6IGRpc3BsYWNlbWVudEJ3ZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJvZHlQaXgucHJvdG90eXBlLnByZWRpY3RGb3JNdWx0aVBlcnNvbkluc3RhbmNlU2VnbWVudGF0aW9uQW5kUGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmJhc2VNb2RlbC5wcmVkaWN0KGlucHV0KSwgc2VnbWVudGF0aW9uID0gX2Euc2VnbWVudGF0aW9uLCBsb25nT2Zmc2V0cyA9IF9hLmxvbmdPZmZzZXRzLCBoZWF0bWFwU2NvcmVzID0gX2EuaGVhdG1hcFNjb3Jlcywgb2Zmc2V0cyA9IF9hLm9mZnNldHMsIGRpc3BsYWNlbWVudEZ3ZCA9IF9hLmRpc3BsYWNlbWVudEZ3ZCwgZGlzcGxhY2VtZW50QndkID0gX2EuZGlzcGxhY2VtZW50QndkLCBwYXJ0SGVhdG1hcHMgPSBfYS5wYXJ0SGVhdG1hcHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWdtZW50TG9naXRzOiBzZWdtZW50YXRpb24sXG4gICAgICAgICAgICBsb25nT2Zmc2V0czogbG9uZ09mZnNldHMsXG4gICAgICAgICAgICBoZWF0bWFwU2NvcmVzOiBoZWF0bWFwU2NvcmVzLFxuICAgICAgICAgICAgb2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZ3ZDogZGlzcGxhY2VtZW50RndkLFxuICAgICAgICAgICAgZGlzcGxhY2VtZW50QndkOiBkaXNwbGFjZW1lbnRCd2QsXG4gICAgICAgICAgICBwYXJ0SGVhdG1hcHM6IHBhcnRIZWF0bWFwc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gaW1hZ2Ugd2l0aCBwZW9wbGUsIHJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIGFsbCBpbnRlcm1lZGlhdGVcbiAgICAgKiB0ZW5zb3JzIGluY2x1ZGluZzogMSkgYSBiaW5hcnkgYXJyYXkgd2l0aCAxIGZvciB0aGUgcGl4ZWxzIHRoYXQgYXJlIHBhcnQgb2ZcbiAgICAgKiB0aGUgcGVyc29uLCBhbmQgMCBvdGhlcndpc2UsIDIpIGhlYXRtYXBTY29yZXMsIDMpIG9mZnNldHMsIGFuZCA0KSBwYWRkaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50KVxuICAgICAqIFRoZSBpbnB1dCBpbWFnZSB0byBmZWVkIHRocm91Z2ggdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxSZXNvbHV0aW9uIERlZmF1bHRzIHRvICdtZWRpdW0nLiBUaGUgaW50ZXJuYWwgcmVzb2x1dGlvblxuICAgICAqIHRoYXQgdGhlIGlucHV0IGlzIHJlc2l6ZWQgdG8gYmVmb3JlIGluZmVyZW5jZS4gVGhlIGxhcmdlciB0aGVcbiAgICAgKiBpbnRlcm5hbFJlc29sdXRpb24gdGhlIG1vcmUgYWNjdXJhdGUgdGhlIG1vZGVsIGF0IHRoZSBjb3N0IG9mIHNsb3dlclxuICAgICAqIHByZWRpY3Rpb24gdGltZXMuIEF2YWlsYWJsZSB2YWx1ZXMgYXJlICdsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnLCAnZnVsbCcsIG9yXG4gICAgICogYSBwZXJjZW50YWdlIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVGhlIHZhbHVlcyAnbG93JywgJ21lZGl1bScsICdoaWdoJywgYW5kXG4gICAgICogJ2Z1bGwnIG1hcCB0byAwLjI1LCAwLjUsIDAuNzUsIGFuZCAxLjAgY29ycmVzcG9uZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlZ21lbnRhdGlvblRocmVzaG9sZCBUaGUgbWluaW11bSB0aGF0IHNlZ21lbnRhdGlvbiB2YWx1ZXMgbXVzdCBoYXZlXG4gICAgICogdG8gYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwZXJzb24uIEFmZmVjdHMgdGhlIGdlbmVyYXRpb24gb2YgdGhlXG4gICAgICogc2VnbWVudGF0aW9uIG1hc2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgZGljdGlvbmFyeSBjb250YWluaW5nIGBzZWdtZW50YXRpb25gLCBgaGVhdG1hcFNjb3Jlc2AsIGBvZmZzZXRzYCxcbiAgICAgKiBhbmQgYHBhZGRpbmdgOlxuICAgICAqIC0gYHNlZ21lbnRhdGlvbmA6IEEgMmQgVGVuc29yIHdpdGggMSBmb3IgdGhlIHBpeGVscyB0aGF0IGFyZSBwYXJ0IG9mIHRoZVxuICAgICAqIHBlcnNvbiwgYW5kIDAgb3RoZXJ3aXNlLiBUaGUgd2lkdGggYW5kIGhlaWdodCBjb3JyZXNwb25kIHRvIHRoZSBzYW1lXG4gICAgICogZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgaW1hZ2UuXG4gICAgICogLSBgaGVhdG1hcFNjb3Jlc2A6IEEgM2QgVGVuc29yIG9mIHRoZSBrZXlwb2ludCBoZWF0bWFwcyB1c2VkIGJ5XG4gICAgICogcG9zZSBlc3RpbWF0aW9uIGRlY29kaW5nLlxuICAgICAqIC0gYG9mZnNldHNgOiBBIDNkIFRlbnNvciBvZiB0aGUga2V5cG9pbnQgb2Zmc2V0cyB1c2VkIGJ5IHBvc2VcbiAgICAgKiBlc3RpbWF0aW9uIGRlY29kaW5nLlxuICAgICAqIC0gYGRpc3BsYWNlbWVudEZ3ZGA6IEEgM2QgVGVuc29yIG9mIHRoZSBrZXlwb2ludCBmb3J3YXJkIGRpc3BsYWNlbWVudCB1c2VkXG4gICAgICogYnkgcG9zZSBlc3RpbWF0aW9uIGRlY29kaW5nLlxuICAgICAqIC0gYGRpc3BsYWNlbWVudEJ3ZGA6IEEgM2QgVGVuc29yIG9mIHRoZSBrZXlwb2ludCBiYWNrd2FyZCBkaXNwbGFjZW1lbnQgdXNlZFxuICAgICAqIGJ5IHBvc2UgZXN0aW1hdGlvbiBkZWNvZGluZy5cbiAgICAgKiAtIGBwYWRkaW5nYDogVGhlIHBhZGRpbmcgKHVuaXQgcGl4ZWxzKSBiZWluZyBhcHBsaWVkIHRvIHRoZSBpbnB1dCBpbWFnZVxuICAgICAqIGJlZm9yZSBpdCBpcyBmZWQgaW50byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgQm9keVBpeC5wcm90b3R5cGUuc2VnbWVudFBlcnNvbkFjdGl2YXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGludGVybmFsUmVzb2x1dGlvbiwgc2VnbWVudGF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzZWdtZW50YXRpb25UaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBzZWdtZW50YXRpb25UaHJlc2hvbGQgPSAwLjU7IH1cbiAgICAgICAgdmFyIF9hID0gZ2V0SW5wdXRTaXplKGlucHV0KSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCA9IHRvSW5wdXRSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGgoaW50ZXJuYWxSZXNvbHV0aW9uLCB0aGlzLmJhc2VNb2RlbC5vdXRwdXRTdHJpZGUsIFtoZWlnaHQsIHdpZHRoXSk7XG4gICAgICAgIHZhciBfYiA9IHBhZEFuZFJlc2l6ZVRvKGlucHV0LCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCksIHJlc2l6ZWQgPSBfYi5yZXNpemVkLCBwYWRkaW5nID0gX2IucGFkZGluZztcbiAgICAgICAgdmFyIF9jID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcmVkaWN0Rm9yUGVyc29uU2VnbWVudGF0aW9uKHJlc2l6ZWQpLCBzZWdtZW50TG9naXRzID0gX2Euc2VnbWVudExvZ2l0cywgaGVhdG1hcFNjb3JlcyA9IF9hLmhlYXRtYXBTY29yZXMsIG9mZnNldHMgPSBfYS5vZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QgPSBfYS5kaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZCA9IF9hLmRpc3BsYWNlbWVudEJ3ZDtcbiAgICAgICAgICAgIHZhciBfYiA9IHJlc2l6ZWQuc2hhcGUsIHJlc2l6ZWRIZWlnaHQgPSBfYlswXSwgcmVzaXplZFdpZHRoID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgc2NhbGVkU2VnbWVudFNjb3JlcyA9IHNjYWxlQW5kQ3JvcFRvSW5wdXRUZW5zb3JTaGFwZShzZWdtZW50TG9naXRzLCBbaGVpZ2h0LCB3aWR0aF0sIFtyZXNpemVkSGVpZ2h0LCByZXNpemVkV2lkdGhdLCBbW3BhZGRpbmcudG9wLCBwYWRkaW5nLmJvdHRvbV0sIFtwYWRkaW5nLmxlZnQsIHBhZGRpbmcucmlnaHRdXSwgQVBQTFlfU0lHTU9JRF9BQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VnbWVudGF0aW9uOiB0b01hc2tUZW5zb3IodGYuc3F1ZWV6ZShzY2FsZWRTZWdtZW50U2NvcmVzKSwgc2VnbWVudGF0aW9uVGhyZXNob2xkKSxcbiAgICAgICAgICAgICAgICBoZWF0bWFwU2NvcmVzOiBoZWF0bWFwU2NvcmVzLFxuICAgICAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50RndkOiBkaXNwbGFjZW1lbnRGd2QsXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50QndkOiBkaXNwbGFjZW1lbnRCd2QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSwgc2VnbWVudGF0aW9uID0gX2Muc2VnbWVudGF0aW9uLCBoZWF0bWFwU2NvcmVzID0gX2MuaGVhdG1hcFNjb3Jlcywgb2Zmc2V0cyA9IF9jLm9mZnNldHMsIGRpc3BsYWNlbWVudEZ3ZCA9IF9jLmRpc3BsYWNlbWVudEZ3ZCwgZGlzcGxhY2VtZW50QndkID0gX2MuZGlzcGxhY2VtZW50QndkO1xuICAgICAgICByZXNpemVkLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZ21lbnRhdGlvbjogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgaGVhdG1hcFNjb3JlczogaGVhdG1hcFNjb3JlcyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2Q6IGRpc3BsYWNlbWVudEZ3ZCxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEJ3ZDogZGlzcGxhY2VtZW50QndkLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgICAgIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoOiBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gaW1hZ2Ugd2l0aCBtYW55IHBlb3BsZSwgcmV0dXJucyBhIFBlcnNvblNlZ21lbnRhdGlvbiBkaWN0aW9uYXJ5XG4gICAgICogdGhhdCBjb250YWlucyB0aGUgc2VnbWVudGF0aW9uIG1hc2sgZm9yIGFsbCBwZW9wbGUgYW5kIGEgc2luZ2xlIHBvc2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgc2VnbWVudGF0aW9uIG1hc2sgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgY292ZXJzIGFsbCBwZW9wbGUgYnV0XG4gICAgICogdGhlIHBvc2Ugd29ya3Mgd2VsbCBmb3Igb25lIHBlcnNvbi4gSWYgeW91IHdhbnQgdG8gZXN0aW1hdGUgaW5zdGFuY2UtbGV2ZWxcbiAgICAgKiBtdWx0aXBsZSBwZXJzb24gc2VnbWVudGF0aW9uICYgcG9zZSBmb3IgZWFjaCBwZXJzb24sIHVzZVxuICAgICAqIGBzZWdtZW50TXVsdGlQZXJzb25gIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudClcbiAgICAgKiBUaGUgaW5wdXQgaW1hZ2UgdG8gZmVlZCB0aHJvdWdoIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyBQZXJzb25JbmZlcmVuY2VDb25maWcgb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICAgKiBwYXJhbWV0ZXJzIGZvciB0aGUgQm9keVBpeCBpbmZlcmVuY2UgdXNpbmcgcGVyc29uIGRlY29kaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiBBIFNlbWFudGljUGVyc29uU2VnbWVudGF0aW9uIGRpY3Rpb25hcnkgdGhhdCBjb250YWlucyBoZWlnaHQsXG4gICAgICogd2lkdGgsIHRoZSBmbGF0dGVuZWQgYmluYXJ5IHNlZ21lbnRhdGlvbiBtYXNrIGFuZCB0aGUgcG9zZXMgZm9yIGFsbCBwZW9wbGUuXG4gICAgICogVGhlIHdpZHRoIGFuZCBoZWlnaHQgY29ycmVzcG9uZCB0byB0aGUgc2FtZSBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBpbWFnZS5cbiAgICAgKiAtIGBoZWlnaHRgOiBUaGUgaGVpZ2h0IG9mIHRoZSBzZWdtZW50YXRpb24gZGF0YSBpbiBwaXhlbCB1bml0LlxuICAgICAqIC0gYHdpZHRoYDogVGhlIHdpZHRoIG9mIHRoZSBzZWdtZW50YXRpb24gZGF0YSBpbiBwaXhlbCB1bml0LlxuICAgICAqIC0gYGRhdGFgOiBUaGUgZmxhdHRlbmVkIFVpbnQ4QXJyYXkgb2Ygc2VnbWVudGF0aW9uIGRhdGEuIDEgbWVhbnMgdGhlIHBpeGVsXG4gICAgICogYmVsb25ncyB0byBhIHBlcnNvbiBhbmQgMCBtZWFucyB0aGUgcGl4ZWwgZG9lc24ndCBiZWxvbmcgdG8gYSBwZXJzb24uIFRoZVxuICAgICAqIHNpemUgb2YgdGhlIGFycmF5IGlzIGVxdWFsIHRvIGBoZWlnaHRgIHggYHdpZHRoYCBpbiByb3ctbWFqb3Igb3JkZXIuXG4gICAgICogLSBgYWxsUG9zZXNgOiBUaGUgMmQgcG9zZXMgb2YgYWxsIHBlb3BsZS5cbiAgICAgKi9cbiAgICBCb2R5UGl4LnByb3RvdHlwZS5zZWdtZW50UGVyc29uID0gZnVuY3Rpb24gKGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IFBFUlNPTl9JTkZFUkVOQ0VfQ09ORklHOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgc2VnbWVudGF0aW9uLCBoZWF0bWFwU2NvcmVzLCBvZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZCwgcGFkZGluZywgaW50ZXJuYWxSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGgsIF9iLCBoZWlnaHQsIHdpZHRoLCByZXN1bHQsIHRlbnNvckJ1ZmZlcnMsIHNjb3Jlc0J1Ziwgb2Zmc2V0c0J1ZiwgZGlzcGxhY2VtZW50c0Z3ZEJ1ZiwgZGlzcGxhY2VtZW50c0J3ZEJ1ZiwgcG9zZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgUEVSU09OX0lORkVSRU5DRV9DT05GSUcpLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQZXJzb25JbmZlcmVuY2VDb25maWcoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5zZWdtZW50UGVyc29uQWN0aXZhdGlvbihpbnB1dCwgY29uZmlnLmludGVybmFsUmVzb2x1dGlvbiwgY29uZmlnLnNlZ21lbnRhdGlvblRocmVzaG9sZCksIHNlZ21lbnRhdGlvbiA9IF9hLnNlZ21lbnRhdGlvbiwgaGVhdG1hcFNjb3JlcyA9IF9hLmhlYXRtYXBTY29yZXMsIG9mZnNldHMgPSBfYS5vZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QgPSBfYS5kaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZCA9IF9hLmRpc3BsYWNlbWVudEJ3ZCwgcGFkZGluZyA9IF9hLnBhZGRpbmcsIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoID0gX2EuaW50ZXJuYWxSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHNlZ21lbnRhdGlvbi5zaGFwZSwgaGVpZ2h0ID0gX2JbMF0sIHdpZHRoID0gX2JbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzZWdtZW50YXRpb24uZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudGF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvVGVuc29yQnVmZmVyczNEKFtoZWF0bWFwU2NvcmVzLCBvZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZF0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQnVmZmVycyA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlc0J1ZiA9IHRlbnNvckJ1ZmZlcnNbMF0sIG9mZnNldHNCdWYgPSB0ZW5zb3JCdWZmZXJzWzFdLCBkaXNwbGFjZW1lbnRzRndkQnVmID0gdGVuc29yQnVmZmVyc1syXSwgZGlzcGxhY2VtZW50c0J3ZEJ1ZiA9IHRlbnNvckJ1ZmZlcnNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NlcyA9IGRlY29kZU11bHRpcGxlUG9zZXMoc2NvcmVzQnVmLCBvZmZzZXRzQnVmLCBkaXNwbGFjZW1lbnRzRndkQnVmLCBkaXNwbGFjZW1lbnRzQndkQnVmLCB0aGlzLmJhc2VNb2RlbC5vdXRwdXRTdHJpZGUsIGNvbmZpZy5tYXhEZXRlY3Rpb25zLCBjb25maWcuc2NvcmVUaHJlc2hvbGQsIGNvbmZpZy5ubXNSYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zZXMgPSBzY2FsZUFuZEZsaXBQb3Nlcyhwb3NlcywgW2hlaWdodCwgd2lkdGhdLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCwgcGFkZGluZywgRkxJUF9QT1NFU19BRlRFUl9TQ0FMSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYXRtYXBTY29yZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2QuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50QndkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7IGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGgsIGRhdGE6IHJlc3VsdCwgYWxsUG9zZXM6IHBvc2VzIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGltYWdlIHdpdGggbXVsdGlwbGUgcGVvcGxlLCByZXR1cm5zIGFuICphcnJheSogb2ZcbiAgICAgKiBQZXJzb25TZWdtZW50YXRpb24gb2JqZWN0LiBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IGNvcnJlc3BvbmRpbmcgdG8gb25lXG4gICAgICogb2YgdGhlIHBlb3BsZSBpbiB0aGUgaW5wdXQgaW1hZ2UuIEluIG90aGVyIHdvcmRzLCBpdCBwcmVkaWN0c1xuICAgICAqIGluc3RhbmNlLWxldmVsIG11bHRpcGxlIHBlcnNvbiBzZWdtZW50YXRpb24gJiBwb3NlIGZvciBlYWNoIHBlcnNvbi5cbiAgICAgKlxuICAgICAqIFRoZSBtb2RlbCBkb2VzIHN0YW5kYXJkIEltYWdlTmV0IHByZS1wcm9jZXNzaW5nIGJlZm9yZSBpbmZlcnJpbmcgdGhyb3VnaFxuICAgICAqIHRoZSBtb2RlbC4gVGhlIGltYWdlIHBpeGVscyBzaG91bGQgaGF2ZSB2YWx1ZXMgWzAtMjU1XS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnQpIFRoZSBpbnB1dFxuICAgICAqIGltYWdlIHRvIGZlZWQgdGhyb3VnaCB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgTXVsdGlQZXJzb25JbmZlcmVuY2VDb25maWcgb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICAgKiBwYXJhbWV0ZXJzIGZvciB0aGUgQm9keVBpeCBpbmZlcmVuY2UgdXNpbmcgbXVsdGktcGVyc29uIGRlY29kaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbiBhcnJheSBvZiBQZXJzb25TZWdtZW50YXRpb24gb2JqZWN0LCBlYWNoIGNvbnRhaW5pbmcgYSB3aWR0aCxcbiAgICAgKiBoZWlnaHQsIGEgYmluYXJ5IGFycmF5ICgxIGZvciB0aGUgcGl4ZWxzIHRoYXQgYXJlIHBhcnQgb2YgdGhlXG4gICAgICogcGVyc29uLCBhbmQgMCBvdGhlcndpc2UpIGFuZCAyRCBwb3NlLiBUaGUgYXJyYXkgc2l6ZSBjb3JyZXNwb25kcyB0byB0aGVcbiAgICAgKiBudW1iZXIgb2YgcGl4ZWxzIGluIHRoZSBpbWFnZS4gVGhlIHdpZHRoIGFuZCBoZWlnaHQgY29ycmVzcG9uZCB0byB0aGVcbiAgICAgKiBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZSB0aGUgYmluYXJ5IGFycmF5IGlzIHNoYXBlZCB0bywgd2hpY2ggYXJlIHRoZSBzYW1lXG4gICAgICogZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgaW1hZ2UuXG4gICAgICovXG4gICAgQm9keVBpeC5wcm90b3R5cGUuc2VnbWVudE11bHRpUGVyc29uID0gZnVuY3Rpb24gKGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IE1VTFRJX1BFUlNPTl9JTlNUQU5DRV9JTkZFUkVOQ0VfQ09ORklHOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgaGVpZ2h0LCB3aWR0aCwgaW50ZXJuYWxSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGgsIF9iLCByZXNpemVkLCBwYWRkaW5nLCBfYywgc2VnbWVudGF0aW9uLCBsb25nT2Zmc2V0cywgaGVhdG1hcFNjb3Jlc1Jhdywgb2Zmc2V0c1JhdywgZGlzcGxhY2VtZW50RndkUmF3LCBkaXNwbGFjZW1lbnRCd2RSYXcsIHRlbnNvckJ1ZmZlcnMsIHNjb3Jlc0J1Ziwgb2Zmc2V0c0J1ZiwgZGlzcGxhY2VtZW50c0Z3ZEJ1ZiwgZGlzcGxhY2VtZW50c0J3ZEJ1ZiwgcG9zZXMsIGluc3RhbmNlTWFza3M7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gX19hc3NpZ24oX19hc3NpZ24oe30sIE1VTFRJX1BFUlNPTl9JTlNUQU5DRV9JTkZFUkVOQ0VfQ09ORklHKSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlTXVsdGlQZXJzb25JbnN0YW5jZUluZmVyZW5jZUNvbmZpZyhjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBnZXRJbnB1dFNpemUoaW5wdXQpLCBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoID0gdG9JbnB1dFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aChjb25maWcuaW50ZXJuYWxSZXNvbHV0aW9uLCB0aGlzLmJhc2VNb2RlbC5vdXRwdXRTdHJpZGUsIFtoZWlnaHQsIHdpZHRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhZEFuZFJlc2l6ZVRvKGlucHV0LCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCksIHJlc2l6ZWQgPSBfYi5yZXNpemVkLCBwYWRkaW5nID0gX2IucGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gdGYudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJlZGljdEZvck11bHRpUGVyc29uSW5zdGFuY2VTZWdtZW50YXRpb25BbmRQYXJ0KHJlc2l6ZWQpLCBzZWdtZW50TG9naXRzID0gX2Euc2VnbWVudExvZ2l0cywgbG9uZ09mZnNldHMgPSBfYS5sb25nT2Zmc2V0cywgaGVhdG1hcFNjb3JlcyA9IF9hLmhlYXRtYXBTY29yZXMsIG9mZnNldHMgPSBfYS5vZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QgPSBfYS5kaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZCA9IF9hLmRpc3BsYWNlbWVudEJ3ZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVkU2VnbWVudFNjb3JlcyA9IHNjYWxlQW5kQ3JvcFRvSW5wdXRUZW5zb3JTaGFwZShzZWdtZW50TG9naXRzLCBbaGVpZ2h0LCB3aWR0aF0sIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoLCBbW3BhZGRpbmcudG9wLCBwYWRkaW5nLmJvdHRvbV0sIFtwYWRkaW5nLmxlZnQsIHBhZGRpbmcucmlnaHRdXSwgQVBQTFlfU0lHTU9JRF9BQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVkTG9uZ09mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZWRMb25nT2Zmc2V0cyA9IGxvbmdPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudGF0aW9uID0gdG9NYXNrVGVuc29yKHRmLnNxdWVlemUoc2NhbGVkU2VnbWVudFNjb3JlcyksIGNvbmZpZy5zZWdtZW50YXRpb25UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbjogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25nT2Zmc2V0czogc2NhbGVkTG9uZ09mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYXRtYXBTY29yZXNSYXc6IGhlYXRtYXBTY29yZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldHNSYXc6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudEZ3ZFJhdzogZGlzcGxhY2VtZW50RndkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRCd2RSYXc6IGRpc3BsYWNlbWVudEJ3ZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHNlZ21lbnRhdGlvbiA9IF9jLnNlZ21lbnRhdGlvbiwgbG9uZ09mZnNldHMgPSBfYy5sb25nT2Zmc2V0cywgaGVhdG1hcFNjb3Jlc1JhdyA9IF9jLmhlYXRtYXBTY29yZXNSYXcsIG9mZnNldHNSYXcgPSBfYy5vZmZzZXRzUmF3LCBkaXNwbGFjZW1lbnRGd2RSYXcgPSBfYy5kaXNwbGFjZW1lbnRGd2RSYXcsIGRpc3BsYWNlbWVudEJ3ZFJhdyA9IF9jLmRpc3BsYWNlbWVudEJ3ZFJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvVGVuc29yQnVmZmVyczNEKFtoZWF0bWFwU2NvcmVzUmF3LCBvZmZzZXRzUmF3LCBkaXNwbGFjZW1lbnRGd2RSYXcsIGRpc3BsYWNlbWVudEJ3ZFJhd10pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQnVmZmVycyA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlc0J1ZiA9IHRlbnNvckJ1ZmZlcnNbMF0sIG9mZnNldHNCdWYgPSB0ZW5zb3JCdWZmZXJzWzFdLCBkaXNwbGFjZW1lbnRzRndkQnVmID0gdGVuc29yQnVmZmVyc1syXSwgZGlzcGxhY2VtZW50c0J3ZEJ1ZiA9IHRlbnNvckJ1ZmZlcnNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NlcyA9IGRlY29kZU11bHRpcGxlUG9zZXMoc2NvcmVzQnVmLCBvZmZzZXRzQnVmLCBkaXNwbGFjZW1lbnRzRndkQnVmLCBkaXNwbGFjZW1lbnRzQndkQnVmLCB0aGlzLmJhc2VNb2RlbC5vdXRwdXRTdHJpZGUsIGNvbmZpZy5tYXhEZXRlY3Rpb25zLCBjb25maWcuc2NvcmVUaHJlc2hvbGQsIGNvbmZpZy5ubXNSYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zZXMgPSBzY2FsZUFuZEZsaXBQb3Nlcyhwb3NlcywgW2hlaWdodCwgd2lkdGhdLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCwgcGFkZGluZywgRkxJUF9QT1NFU19BRlRFUl9TQ0FMSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRlY29kZVBlcnNvbkluc3RhbmNlTWFza3Moc2VnbWVudGF0aW9uLCBsb25nT2Zmc2V0cywgcG9zZXMsIGhlaWdodCwgd2lkdGgsIHRoaXMuYmFzZU1vZGVsLm91dHB1dFN0cmlkZSwgaW50ZXJuYWxSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGgsIHBhZGRpbmcsIGNvbmZpZy5zY29yZVRocmVzaG9sZCwgY29uZmlnLnJlZmluZVN0ZXBzLCBjb25maWcubWluS2V5cG9pbnRTY29yZSwgY29uZmlnLm1heERldGVjdGlvbnMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VNYXNrcyA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZWQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudGF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdPZmZzZXRzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYXRtYXBTY29yZXNSYXcuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0c1Jhdy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2RSYXcuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50QndkUmF3LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbnN0YW5jZU1hc2tzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBpbWFnZSB3aXRoIG1hbnkgcGVvcGxlLCByZXR1cm5zIGEgZGljdGlvbmFyeSBjb250YWluaW5nOiBoZWlnaHQsXG4gICAgICogd2lkdGgsIGEgdGVuc29yIHdpdGggYSBwYXJ0IGlkIGZyb20gMC0yNCBmb3IgdGhlIHBpeGVscyB0aGF0IGFyZVxuICAgICAqIHBhcnQgb2YgYSBjb3JyZXNwb25kaW5nIGJvZHkgcGFydCwgYW5kIC0xIG90aGVyd2lzZS4gVGhpcyBkb2VzIHN0YW5kYXJkXG4gICAgICogSW1hZ2VOZXQgcHJlLXByb2Nlc3NpbmcgYmVmb3JlIGluZmVycmluZyB0aHJvdWdoIHRoZSBtb2RlbC4gIFRoZSBpbWFnZVxuICAgICAqIHNob3VsZCBwaXhlbHMgc2hvdWxkIGhhdmUgdmFsdWVzIFswLTI1NV0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudClcbiAgICAgKiBUaGUgaW5wdXQgaW1hZ2UgdG8gZmVlZCB0aHJvdWdoIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVybmFsUmVzb2x1dGlvbiBEZWZhdWx0cyB0byAnbWVkaXVtJy4gVGhlIGludGVybmFsIHJlc29sdXRpb25cbiAgICAgKiBwZXJjZW50YWdlIHRoYXQgdGhlIGlucHV0IGlzIHJlc2l6ZWQgdG8gYmVmb3JlIGluZmVyZW5jZS4gVGhlIGxhcmdlciB0aGVcbiAgICAgKiBpbnRlcm5hbFJlc29sdXRpb24gdGhlIG1vcmUgYWNjdXJhdGUgdGhlIG1vZGVsIGF0IHRoZSBjb3N0IG9mIHNsb3dlclxuICAgICAqIHByZWRpY3Rpb24gdGltZXMuIEF2YWlsYWJsZSB2YWx1ZXMgYXJlICdsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnLCAnZnVsbCcsIG9yXG4gICAgICogYSBwZXJjZW50YWdlIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVGhlIHZhbHVlcyAnbG93JywgJ21lZGl1bScsICdoaWdoJywgYW5kXG4gICAgICogJ2Z1bGwnIG1hcCB0byAwLjI1LCAwLjUsIDAuNzUsIGFuZCAxLjAgY29ycmVzcG9uZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlZ21lbnRhdGlvblRocmVzaG9sZCBUaGUgbWluaW11bSB0aGF0IHNlZ21lbnRhdGlvbiB2YWx1ZXMgbXVzdCBoYXZlXG4gICAgICogdG8gYmUgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwZXJzb24uICBBZmZlY3RzIHRoZSBjbGlwcGluZyBvZiB0aGUgY29sb3JlZFxuICAgICAqIHBhcnQgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuICBBIGRpY3Rpb25hcnkgY29udGFpbmluZyBgcGFydFNlZ21lbnRhdGlvbmAsIGBoZWF0bWFwU2NvcmVzYCxcbiAgICAgKiBgb2Zmc2V0c2AsIGFuZCBgcGFkZGluZ2A6XG4gICAgICogLSBgcGFydFNlZ21lbnRhdGlvbmA6IEEgMmQgVGVuc29yIHdpdGggYSBwYXJ0IGlkIGZyb20gMC0yNCBmb3JcbiAgICAgKiB0aGUgcGl4ZWxzIHRoYXQgYXJlIHBhcnQgb2YgYSBjb3JyZXNwb25kaW5nIGJvZHkgcGFydCwgYW5kIC0xIG90aGVyd2lzZS5cbiAgICAgKiAtIGBoZWF0bWFwU2NvcmVzYDogQSAzZCBUZW5zb3Igb2YgdGhlIGtleXBvaW50IGhlYXRtYXBzIHVzZWQgYnlcbiAgICAgKiBzaW5nbGUtcGVyc29uIHBvc2UgZXN0aW1hdGlvbiBkZWNvZGluZy5cbiAgICAgKiAtIGBvZmZzZXRzYDogQSAzZCBUZW5zb3Igb2YgdGhlIGtleXBvaW50IG9mZnNldHMgdXNlZCBieSBzaW5nbGUtcGVyc29uIHBvc2VcbiAgICAgKiBlc3RpbWF0aW9uIGRlY29kaW5nLlxuICAgICAqIC0gYGRpc3BsYWNlbWVudEZ3ZGA6IEEgM2QgVGVuc29yIG9mIHRoZSBrZXlwb2ludCBmb3J3YXJkIGRpc3BsYWNlbWVudFxuICAgICAqIHVzZWQgYnkgcG9zZSBlc3RpbWF0aW9uIGRlY29kaW5nLlxuICAgICAqIC0gYGRpc3BsYWNlbWVudEJ3ZGA6IEEgM2QgVGVuc29yIG9mIHRoZSBrZXlwb2ludCBiYWNrd2FyZCBkaXNwbGFjZW1lbnQgdXNlZFxuICAgICAqIGJ5IHBvc2UgZXN0aW1hdGlvbiBkZWNvZGluZy5cbiAgICAgKiAtIGBwYWRkaW5nYDogVGhlIHBhZGRpbmcgKHVuaXQgcGl4ZWxzKSBiZWluZyBhcHBsaWVkIHRvIHRoZSBpbnB1dCBpbWFnZVxuICAgICAqIGJlZm9yZSBpdCBpcyBmZWQgaW50byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgQm9keVBpeC5wcm90b3R5cGUuc2VnbWVudFBlcnNvblBhcnRzQWN0aXZhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgaW50ZXJuYWxSZXNvbHV0aW9uLCBzZWdtZW50YXRpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHNlZ21lbnRhdGlvblRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHNlZ21lbnRhdGlvblRocmVzaG9sZCA9IDAuNTsgfVxuICAgICAgICB2YXIgX2EgPSBnZXRJbnB1dFNpemUoaW5wdXQpLCBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoID0gdG9JbnB1dFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aChpbnRlcm5hbFJlc29sdXRpb24sIHRoaXMuYmFzZU1vZGVsLm91dHB1dFN0cmlkZSwgW2hlaWdodCwgd2lkdGhdKTtcbiAgICAgICAgdmFyIF9iID0gcGFkQW5kUmVzaXplVG8oaW5wdXQsIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoKSwgcmVzaXplZCA9IF9iLnJlc2l6ZWQsIHBhZGRpbmcgPSBfYi5wYWRkaW5nO1xuICAgICAgICB2YXIgX2MgPSB0Zi50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByZWRpY3RGb3JQZXJzb25TZWdtZW50YXRpb25BbmRQYXJ0KHJlc2l6ZWQpLCBzZWdtZW50TG9naXRzID0gX2Euc2VnbWVudExvZ2l0cywgcGFydEhlYXRtYXBMb2dpdHMgPSBfYS5wYXJ0SGVhdG1hcExvZ2l0cywgaGVhdG1hcFNjb3JlcyA9IF9hLmhlYXRtYXBTY29yZXMsIG9mZnNldHMgPSBfYS5vZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QgPSBfYS5kaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZCA9IF9hLmRpc3BsYWNlbWVudEJ3ZDtcbiAgICAgICAgICAgIHZhciBfYiA9IHJlc2l6ZWQuc2hhcGUsIHJlc2l6ZWRIZWlnaHQgPSBfYlswXSwgcmVzaXplZFdpZHRoID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgc2NhbGVkU2VnbWVudFNjb3JlcyA9IHNjYWxlQW5kQ3JvcFRvSW5wdXRUZW5zb3JTaGFwZShzZWdtZW50TG9naXRzLCBbaGVpZ2h0LCB3aWR0aF0sIFtyZXNpemVkSGVpZ2h0LCByZXNpemVkV2lkdGhdLCBbW3BhZGRpbmcudG9wLCBwYWRkaW5nLmJvdHRvbV0sIFtwYWRkaW5nLmxlZnQsIHBhZGRpbmcucmlnaHRdXSwgQVBQTFlfU0lHTU9JRF9BQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIHZhciBzY2FsZWRQYXJ0SGVhdG1hcFNjb3JlID0gc2NhbGVBbmRDcm9wVG9JbnB1dFRlbnNvclNoYXBlKHBhcnRIZWF0bWFwTG9naXRzLCBbaGVpZ2h0LCB3aWR0aF0sIFtyZXNpemVkSGVpZ2h0LCByZXNpemVkV2lkdGhdLCBbW3BhZGRpbmcudG9wLCBwYWRkaW5nLmJvdHRvbV0sIFtwYWRkaW5nLmxlZnQsIHBhZGRpbmcucmlnaHRdXSwgQVBQTFlfU0lHTU9JRF9BQ1RJVkFUSU9OKTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50YXRpb24gPSB0b01hc2tUZW5zb3IodGYuc3F1ZWV6ZShzY2FsZWRTZWdtZW50U2NvcmVzKSwgc2VnbWVudGF0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFydFNlZ21lbnRhdGlvbjogZGVjb2RlUGFydFNlZ21lbnRhdGlvbihzZWdtZW50YXRpb24sIHNjYWxlZFBhcnRIZWF0bWFwU2NvcmUpLFxuICAgICAgICAgICAgICAgIGhlYXRtYXBTY29yZXM6IGhlYXRtYXBTY29yZXMsXG4gICAgICAgICAgICAgICAgb2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2Q6IGRpc3BsYWNlbWVudEZ3ZCxcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRCd2Q6IGRpc3BsYWNlbWVudEJ3ZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLCBwYXJ0U2VnbWVudGF0aW9uID0gX2MucGFydFNlZ21lbnRhdGlvbiwgaGVhdG1hcFNjb3JlcyA9IF9jLmhlYXRtYXBTY29yZXMsIG9mZnNldHMgPSBfYy5vZmZzZXRzLCBkaXNwbGFjZW1lbnRGd2QgPSBfYy5kaXNwbGFjZW1lbnRGd2QsIGRpc3BsYWNlbWVudEJ3ZCA9IF9jLmRpc3BsYWNlbWVudEJ3ZDtcbiAgICAgICAgcmVzaXplZC5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJ0U2VnbWVudGF0aW9uOiBwYXJ0U2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgaGVhdG1hcFNjb3JlczogaGVhdG1hcFNjb3JlcyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGd2Q6IGRpc3BsYWNlbWVudEZ3ZCxcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEJ3ZDogZGlzcGxhY2VtZW50QndkLFxuICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgICAgIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoOiBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gaW1hZ2Ugd2l0aCBtYW55IHBlb3BsZSwgcmV0dXJucyBhIFBhcnRTZWdtZW50YXRpb24gZGljdGlvbmFyeSB0aGF0XG4gICAgICogY29udGFpbnMgdGhlIGJvZHkgcGFydCBzZWdtZW50YXRpb24gbWFzayBmb3IgYWxsIHBlb3BsZSBhbmQgYSBzaW5nbGUgcG9zZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZSBib2R5IHBhcnQgc2VnbWVudGF0aW9uIG1hc2sgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QgY292ZXJzIGFsbFxuICAgICAqIHBlb3BsZSBidXQgdGhlIHBvc2Ugd29ya3Mgd2VsbCB3aGVuIHRoZXJlIGlzIG9uZSBwZXJzb24uIElmIHlvdSB3YW50IHRvXG4gICAgICogZXN0aW1hdGUgaW5zdGFuY2UtbGV2ZWwgbXVsdGlwbGUgcGVyc29uIGJvZHkgcGFydCBzZWdtZW50YXRpb24gJiBwb3NlIGZvclxuICAgICAqIGVhY2ggcGVyc29uLCB1c2UgYHNlZ21lbnRNdWx0aVBlcnNvblBhcnRzYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnQpXG4gICAgICogVGhlIGlucHV0IGltYWdlIHRvIGZlZWQgdGhyb3VnaCB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgUGVyc29uSW5mZXJlbmNlQ29uZmlnIG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAgICogcGFyYW1ldGVycyBmb3IgdGhlIEJvZHlQaXggaW5mZXJlbmNlIHVzaW5nIHNpbmdsZSBwZXJzb24gZGVjb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgU2VtYW50aWNQYXJ0U2VnbWVudGF0aW9uIGRpY3Rpb25hcnkgdGhhdCBjb250YWlucyBoZWlnaHQsIHdpZHRoLFxuICAgICAqIHRoZSBmbGF0dGVuZWQgYmluYXJ5IHNlZ21lbnRhdGlvbiBtYXNrIGFuZCB0aGUgcG9zZSBmb3IgdGhlIHBlcnNvbi4gVGhlXG4gICAgICogd2lkdGggYW5kIGhlaWdodCBjb3JyZXNwb25kIHRvIHRoZSBzYW1lIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0IGltYWdlLlxuICAgICAqIC0gYGhlaWdodGA6IFRoZSBoZWlnaHQgb2YgdGhlIHBlcnNvbiBwYXJ0IHNlZ21lbnRhdGlvbiBkYXRhIGluIHBpeGVsIHVuaXQuXG4gICAgICogLSBgd2lkdGhgOiBUaGUgd2lkdGggb2YgdGhlIHBlcnNvbiBwYXJ0IHNlZ21lbnRhdGlvbiBkYXRhIGluIHBpeGVsIHVuaXQuXG4gICAgICogLSBgZGF0YWA6IFRoZSBmbGF0dGVuZWQgSW50MzJBcnJheSBvZiBwZXJzb24gcGFydCBzZWdtZW50YXRpb24gZGF0YSB3aXRoIGFcbiAgICAgKiBwYXJ0IGlkIGZyb20gMC0yNCBmb3IgdGhlIHBpeGVscyB0aGF0IGFyZSBwYXJ0IG9mIGEgY29ycmVzcG9uZGluZyBib2R5XG4gICAgICogcGFydCwgYW5kIC0xIG90aGVyd2lzZS4gVGhlIHNpemUgb2YgdGhlIGFycmF5IGlzIGVxdWFsIHRvIGBoZWlnaHRgIHhcbiAgICAgKiBgd2lkdGhgIGluIHJvdy1tYWpvciBvcmRlci5cbiAgICAgKiAtIGBhbGxQb3Nlc2A6IFRoZSAyZCBwb3NlcyBvZiBhbGwgcGVvcGxlLlxuICAgICAqL1xuICAgIEJvZHlQaXgucHJvdG90eXBlLnNlZ21lbnRQZXJzb25QYXJ0cyA9IGZ1bmN0aW9uIChpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBQRVJTT05fSU5GRVJFTkNFX0NPTkZJRzsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIHBhcnRTZWdtZW50YXRpb24sIGhlYXRtYXBTY29yZXMsIG9mZnNldHMsIGRpc3BsYWNlbWVudEZ3ZCwgZGlzcGxhY2VtZW50QndkLCBwYWRkaW5nLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCwgX2IsIGhlaWdodCwgd2lkdGgsIGRhdGEsIHRlbnNvckJ1ZmZlcnMsIHNjb3Jlc0J1Ziwgb2Zmc2V0c0J1ZiwgZGlzcGxhY2VtZW50c0Z3ZEJ1ZiwgZGlzcGxhY2VtZW50c0J3ZEJ1ZiwgcG9zZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgUEVSU09OX0lORkVSRU5DRV9DT05GSUcpLCBjb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQZXJzb25JbmZlcmVuY2VDb25maWcoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5zZWdtZW50UGVyc29uUGFydHNBY3RpdmF0aW9uKGlucHV0LCBjb25maWcuaW50ZXJuYWxSZXNvbHV0aW9uLCBjb25maWcuc2VnbWVudGF0aW9uVGhyZXNob2xkKSwgcGFydFNlZ21lbnRhdGlvbiA9IF9hLnBhcnRTZWdtZW50YXRpb24sIGhlYXRtYXBTY29yZXMgPSBfYS5oZWF0bWFwU2NvcmVzLCBvZmZzZXRzID0gX2Eub2Zmc2V0cywgZGlzcGxhY2VtZW50RndkID0gX2EuZGlzcGxhY2VtZW50RndkLCBkaXNwbGFjZW1lbnRCd2QgPSBfYS5kaXNwbGFjZW1lbnRCd2QsIHBhZGRpbmcgPSBfYS5wYWRkaW5nLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCA9IF9hLmludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBwYXJ0U2VnbWVudGF0aW9uLnNoYXBlLCBoZWlnaHQgPSBfYlswXSwgd2lkdGggPSBfYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHBhcnRTZWdtZW50YXRpb24uZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRTZWdtZW50YXRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdG9UZW5zb3JCdWZmZXJzM0QoW2hlYXRtYXBTY29yZXMsIG9mZnNldHMsIGRpc3BsYWNlbWVudEZ3ZCwgZGlzcGxhY2VtZW50QndkXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JCdWZmZXJzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVzQnVmID0gdGVuc29yQnVmZmVyc1swXSwgb2Zmc2V0c0J1ZiA9IHRlbnNvckJ1ZmZlcnNbMV0sIGRpc3BsYWNlbWVudHNGd2RCdWYgPSB0ZW5zb3JCdWZmZXJzWzJdLCBkaXNwbGFjZW1lbnRzQndkQnVmID0gdGVuc29yQnVmZmVyc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2VzID0gZGVjb2RlTXVsdGlwbGVQb3NlcyhzY29yZXNCdWYsIG9mZnNldHNCdWYsIGRpc3BsYWNlbWVudHNGd2RCdWYsIGRpc3BsYWNlbWVudHNCd2RCdWYsIHRoaXMuYmFzZU1vZGVsLm91dHB1dFN0cmlkZSwgY29uZmlnLm1heERldGVjdGlvbnMsIGNvbmZpZy5zY29yZVRocmVzaG9sZCwgY29uZmlnLm5tc1JhZGl1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NlcyA9IHNjYWxlQW5kRmxpcFBvc2VzKHBvc2VzLCBbaGVpZ2h0LCB3aWR0aF0sIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoLCBwYWRkaW5nLCBGTElQX1BPU0VTX0FGVEVSX1NDQUxJTkcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhdG1hcFNjb3Jlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudEZ3ZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRCd2QuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aCwgZGF0YTogZGF0YSwgYWxsUG9zZXM6IHBvc2VzIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGltYWdlIHdpdGggbXVsdGlwbGUgcGVvcGxlLCByZXR1cm5zIGFuICphcnJheSogb2YgUGFydFNlZ21lbnRhdGlvblxuICAgICAqIG9iamVjdC4gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSBjb3JyZXNwb25kaW5nIHRvIG9uZVxuICAgICAqIG9mIHRoZSBwZW9wbGUgaW4gdGhlIGlucHV0IGltYWdlLiBJbiBvdGhlciB3b3JkcywgaXQgcHJlZGljdHNcbiAgICAgKiBpbnN0YW5jZS1sZXZlbCBtdWx0aXBsZSBwZXJzb24gYm9keSBwYXJ0IHNlZ21lbnRhdGlvbiAmIHBvc2UgZm9yIGVhY2hcbiAgICAgKiBwZXJzb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGRvZXMgc3RhbmRhcmQgSW1hZ2VOZXQgcHJlLXByb2Nlc3NpbmcgYmVmb3JlIGluZmVycmluZyB0aHJvdWdoXG4gICAgICogdGhlIG1vZGVsLiBUaGUgaW1hZ2UgcGl4ZWxzIHNob3VsZCBoYXZlIHZhbHVlcyBbMC0yNTVdLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudCkgVGhlIGlucHV0XG4gICAgICogaW1hZ2UgdG8gZmVlZCB0aHJvdWdoIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyBNdWx0aVBlcnNvbkluZmVyZW5jZUNvbmZpZyBvYmplY3QgdGhhdCBjb250YWluc1xuICAgICAqIHBhcmFtZXRlcnMgZm9yIHRoZSBCb2R5UGl4IGluZmVyZW5jZSB1c2luZyBtdWx0aS1wZXJzb24gZGVjb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIFBhcnRTZWdtZW50YXRpb24gb2JqZWN0LCBlYWNoIGNvbnRhaW5pbmcgYSB3aWR0aCxcbiAgICAgKiBoZWlnaHQsIGEgZmxhdHRlbmVkIGFycmF5ICh3aXRoIHBhcnQgaWQgZnJvbSAwLTI0IGZvciB0aGUgcGl4ZWxzIHRoYXQgYXJlXG4gICAgICogcGFydCBvZiBhIGNvcnJlc3BvbmRpbmcgYm9keSBwYXJ0LCBhbmQgLTEgb3RoZXJ3aXNlKSBhbmQgMkQgcG9zZS4gVGhlIHdpZHRoXG4gICAgICogYW5kIGhlaWdodCBjb3JyZXNwb25kIHRvIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBpbWFnZS4gRWFjaCBmbGF0dGVuZWQgcGFydFxuICAgICAqIHNlZ21lbnRhdGlvbiBhcnJheSBzaXplIGlzIGVxdWFsIHRvIGBoZWlnaHRgIHggYHdpZHRoYC5cbiAgICAgKi9cbiAgICBCb2R5UGl4LnByb3RvdHlwZS5zZWdtZW50TXVsdGlQZXJzb25QYXJ0cyA9IGZ1bmN0aW9uIChpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSBNVUxUSV9QRVJTT05fSU5TVEFOQ0VfSU5GRVJFTkNFX0NPTkZJRzsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGhlaWdodCwgd2lkdGgsIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoLCBfYiwgcmVzaXplZCwgcGFkZGluZywgX2MsIHNlZ21lbnRhdGlvbiwgbG9uZ09mZnNldHMsIGhlYXRtYXBTY29yZXNSYXcsIG9mZnNldHNSYXcsIGRpc3BsYWNlbWVudEZ3ZFJhdywgZGlzcGxhY2VtZW50QndkUmF3LCBwYXJ0U2VnbWVudGF0aW9uLCB0ZW5zb3JCdWZmZXJzLCBzY29yZXNCdWYsIG9mZnNldHNCdWYsIGRpc3BsYWNlbWVudHNGd2RCdWYsIGRpc3BsYWNlbWVudHNCd2RCdWYsIHBvc2VzLCBpbnN0YW5jZU1hc2tzO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBNVUxUSV9QRVJTT05fSU5TVEFOQ0VfSU5GRVJFTkNFX0NPTkZJRyksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZU11bHRpUGVyc29uSW5zdGFuY2VJbmZlcmVuY2VDb25maWcoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gZ2V0SW5wdXRTaXplKGlucHV0KSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCA9IHRvSW5wdXRSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGgoY29uZmlnLmludGVybmFsUmVzb2x1dGlvbiwgdGhpcy5iYXNlTW9kZWwub3V0cHV0U3RyaWRlLCBbaGVpZ2h0LCB3aWR0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBwYWRBbmRSZXNpemVUbyhpbnB1dCwgaW50ZXJuYWxSZXNvbHV0aW9uSGVpZ2h0QW5kV2lkdGgpLCByZXNpemVkID0gX2IucmVzaXplZCwgcGFkZGluZyA9IF9iLnBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IHRmLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByZWRpY3RGb3JNdWx0aVBlcnNvbkluc3RhbmNlU2VnbWVudGF0aW9uQW5kUGFydChyZXNpemVkKSwgc2VnbWVudExvZ2l0cyA9IF9hLnNlZ21lbnRMb2dpdHMsIGxvbmdPZmZzZXRzID0gX2EubG9uZ09mZnNldHMsIGhlYXRtYXBTY29yZXMgPSBfYS5oZWF0bWFwU2NvcmVzLCBvZmZzZXRzID0gX2Eub2Zmc2V0cywgZGlzcGxhY2VtZW50RndkID0gX2EuZGlzcGxhY2VtZW50RndkLCBkaXNwbGFjZW1lbnRCd2QgPSBfYS5kaXNwbGFjZW1lbnRCd2QsIHBhcnRIZWF0bWFwcyA9IF9hLnBhcnRIZWF0bWFwcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNvZGluZyB3aXRoIHNjYWxpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZFNlZ21lbnRTY29yZXMgPSBzY2FsZUFuZENyb3BUb0lucHV0VGVuc29yU2hhcGUoc2VnbWVudExvZ2l0cywgW2hlaWdodCwgd2lkdGhdLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCwgW1twYWRkaW5nLnRvcCwgcGFkZGluZy5ib3R0b21dLCBbcGFkZGluZy5sZWZ0LCBwYWRkaW5nLnJpZ2h0XV0sIEFQUExZX1NJR01PSURfQUNUSVZBVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVjb2Rpbmcgd2l0aCBzY2FsaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZWRQYXJ0U2VnbWVudGF0aW9uU2NvcmVzID0gc2NhbGVBbmRDcm9wVG9JbnB1dFRlbnNvclNoYXBlKHBhcnRIZWF0bWFwcywgW2hlaWdodCwgd2lkdGhdLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCwgW1twYWRkaW5nLnRvcCwgcGFkZGluZy5ib3R0b21dLCBbcGFkZGluZy5sZWZ0LCBwYWRkaW5nLnJpZ2h0XV0sIEFQUExZX1NJR01PSURfQUNUSVZBVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZExvbmdPZmZzZXRzID0gbG9uZ09mZnNldHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRhdGlvbiA9IHRvTWFza1RlbnNvcih0Zi5zcXVlZXplKHNjYWxlZFNlZ21lbnRTY29yZXMpLCBjb25maWcuc2VnbWVudGF0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydFNlZ21lbnRhdGlvbiA9IGRlY29kZU9ubHlQYXJ0U2VnbWVudGF0aW9uKHNjYWxlZFBhcnRTZWdtZW50YXRpb25TY29yZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbjogc2VnbWVudGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb25nT2Zmc2V0czogc2NhbGVkTG9uZ09mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYXRtYXBTY29yZXNSYXc6IGhlYXRtYXBTY29yZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldHNSYXc6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudEZ3ZFJhdzogZGlzcGxhY2VtZW50RndkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRCd2RSYXc6IGRpc3BsYWNlbWVudEJ3ZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydFNlZ21lbnRhdGlvbjogcGFydFNlZ21lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgc2VnbWVudGF0aW9uID0gX2Muc2VnbWVudGF0aW9uLCBsb25nT2Zmc2V0cyA9IF9jLmxvbmdPZmZzZXRzLCBoZWF0bWFwU2NvcmVzUmF3ID0gX2MuaGVhdG1hcFNjb3Jlc1Jhdywgb2Zmc2V0c1JhdyA9IF9jLm9mZnNldHNSYXcsIGRpc3BsYWNlbWVudEZ3ZFJhdyA9IF9jLmRpc3BsYWNlbWVudEZ3ZFJhdywgZGlzcGxhY2VtZW50QndkUmF3ID0gX2MuZGlzcGxhY2VtZW50QndkUmF3LCBwYXJ0U2VnbWVudGF0aW9uID0gX2MucGFydFNlZ21lbnRhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRvVGVuc29yQnVmZmVyczNEKFtoZWF0bWFwU2NvcmVzUmF3LCBvZmZzZXRzUmF3LCBkaXNwbGFjZW1lbnRGd2RSYXcsIGRpc3BsYWNlbWVudEJ3ZFJhd10pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQnVmZmVycyA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3Jlc0J1ZiA9IHRlbnNvckJ1ZmZlcnNbMF0sIG9mZnNldHNCdWYgPSB0ZW5zb3JCdWZmZXJzWzFdLCBkaXNwbGFjZW1lbnRzRndkQnVmID0gdGVuc29yQnVmZmVyc1syXSwgZGlzcGxhY2VtZW50c0J3ZEJ1ZiA9IHRlbnNvckJ1ZmZlcnNbM107XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NlcyA9IGRlY29kZU11bHRpcGxlUG9zZXMoc2NvcmVzQnVmLCBvZmZzZXRzQnVmLCBkaXNwbGFjZW1lbnRzRndkQnVmLCBkaXNwbGFjZW1lbnRzQndkQnVmLCB0aGlzLmJhc2VNb2RlbC5vdXRwdXRTdHJpZGUsIGNvbmZpZy5tYXhEZXRlY3Rpb25zLCBjb25maWcuc2NvcmVUaHJlc2hvbGQsIGNvbmZpZy5ubXNSYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zZXMgPSBzY2FsZUFuZEZsaXBQb3Nlcyhwb3NlcywgW2hlaWdodCwgd2lkdGhdLCBpbnRlcm5hbFJlc29sdXRpb25IZWlnaHRBbmRXaWR0aCwgcGFkZGluZywgRkxJUF9QT1NFU19BRlRFUl9TQ0FMSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGRlY29kZVBlcnNvbkluc3RhbmNlUGFydE1hc2tzKHNlZ21lbnRhdGlvbiwgbG9uZ09mZnNldHMsIHBhcnRTZWdtZW50YXRpb24sIHBvc2VzLCBoZWlnaHQsIHdpZHRoLCB0aGlzLmJhc2VNb2RlbC5vdXRwdXRTdHJpZGUsIGludGVybmFsUmVzb2x1dGlvbkhlaWdodEFuZFdpZHRoLCBwYWRkaW5nLCBjb25maWcuc2NvcmVUaHJlc2hvbGQsIGNvbmZpZy5yZWZpbmVTdGVwcywgY29uZmlnLm1pbktleXBvaW50U2NvcmUsIGNvbmZpZy5tYXhEZXRlY3Rpb25zKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlTWFza3MgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRhdGlvbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nT2Zmc2V0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWF0bWFwU2NvcmVzUmF3LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldHNSYXcuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50RndkUmF3LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudEJ3ZFJhdy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0U2VnbWVudGF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbnN0YW5jZU1hc2tzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCb2R5UGl4LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJhc2VNb2RlbC5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm9keVBpeDtcbn0oKSk7XG4vKipcbiAqIExvYWRzIHRoZSBNb2JpbGVOZXQgQm9keVBpeCBtb2RlbC5cbiAqL1xuZnVuY3Rpb24gbG9hZE1vYmlsZU5ldChjb25maWcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRwdXRTdHJpZGUsIHF1YW50Qnl0ZXMsIG11bHRpcGxpZXIsIHVybCwgZ3JhcGhNb2RlbCwgbW9iaWxlbmV0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRTdHJpZGUgPSBjb25maWcub3V0cHV0U3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICBxdWFudEJ5dGVzID0gY29uZmlnLnF1YW50Qnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSBjb25maWcubXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRmID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIFRlbnNvckZsb3cuanMuIElmIHlvdSBhcmUgdXNpbmcgYSA8c2NyaXB0PiB0YWcsIHBsZWFzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbHNvIGluY2x1ZGUgQHRlbnNvcmZsb3cvdGZqcyBvbiB0aGUgcGFnZSBiZWZvcmUgdXNpbmcgdGhpc1xcbiAgICAgICAgbW9kZWwuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IG1vYmlsZU5ldFNhdmVkTW9kZWwob3V0cHV0U3RyaWRlLCBtdWx0aXBsaWVyLCBxdWFudEJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGZjb252LmxvYWRHcmFwaE1vZGVsKGNvbmZpZy5tb2RlbFVybCB8fCB1cmwpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoTW9kZWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vYmlsZW5ldCA9IG5ldyBNb2JpbGVOZXQoZ3JhcGhNb2RlbCwgb3V0cHV0U3RyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBCb2R5UGl4KG1vYmlsZW5ldCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogTG9hZHMgdGhlIFJlc05ldCBCb2R5UGl4IG1vZGVsLlxuICovXG5mdW5jdGlvbiBsb2FkUmVzTmV0KGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dHB1dFN0cmlkZSwgcXVhbnRCeXRlcywgdXJsLCBncmFwaE1vZGVsLCByZXNuZXQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFN0cmlkZSA9IGNvbmZpZy5vdXRwdXRTdHJpZGU7XG4gICAgICAgICAgICAgICAgICAgIHF1YW50Qnl0ZXMgPSBjb25maWcucXVhbnRCeXRlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRmID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIFRlbnNvckZsb3cuanMuIElmIHlvdSBhcmUgdXNpbmcgYSA8c2NyaXB0PiB0YWcsIHBsZWFzZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbHNvIGluY2x1ZGUgQHRlbnNvcmZsb3cvdGZqcyBvbiB0aGUgcGFnZSBiZWZvcmUgdXNpbmcgdGhpc1xcbiAgICAgICAgbW9kZWwuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHJlc05ldDUwU2F2ZWRNb2RlbChvdXRwdXRTdHJpZGUsIHF1YW50Qnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0ZmNvbnYubG9hZEdyYXBoTW9kZWwoY29uZmlnLm1vZGVsVXJsIHx8IHVybCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhNb2RlbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzbmV0ID0gbmV3IFJlc05ldChncmFwaE1vZGVsLCBvdXRwdXRTdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEJvZHlQaXgocmVzbmV0KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBMb2FkcyB0aGUgQm9keVBpeCBtb2RlbCBpbnN0YW5jZSBmcm9tIGEgY2hlY2twb2ludCwgd2l0aCB0aGUgUmVzTmV0XG4gKiBvciBNb2JpbGVOZXQgYXJjaGl0ZWN0dXJlLiBUaGUgbW9kZWwgdG8gYmUgbG9hZGVkIGlzIGNvbmZpZ3VyYWJsZSB1c2luZyB0aGVcbiAqIGNvbmZpZyBkaWN0aW9uYXJ5IE1vZGVsQ29uZmlnLiBQbGVhc2UgZmluZCBtb3JlIGRldGFpbHMgaW4gdGhlXG4gKiBkb2N1bWVudGF0aW9uIG9mIHRoZSBNb2RlbENvbmZpZy5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIE1vZGVsQ29uZmlnIGRpY3Rpb25hcnkgdGhhdCBjb250YWlucyBwYXJhbWV0ZXJzIGZvclxuICogdGhlIEJvZHlQaXggbG9hZGluZyBwcm9jZXNzLiBQbGVhc2UgZmluZCBtb3JlIGRldGFpbHMgb2YgZWFjaCBwYXJhbWV0ZXJzXG4gKiBpbiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGUgTW9kZWxDb25maWcgaW50ZXJmYWNlLiBUaGUgcHJlZGVmaW5lZFxuICogYE1PQklMRU5FVF9WMV9DT05GSUdgIGFuZCBgUkVTTkVUX0NPTkZJR2AgY2FuIGFsc28gYmUgdXNlZCBhcyByZWZlcmVuY2VzXG4gKiBmb3IgZGVmaW5pbmcgeW91ciBjdXN0b21pemVkIGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gbG9hZChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0gTU9CSUxFTkVUX1YxX0NPTkZJRzsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgY29uZmlnID0gdmFsaWRhdGVNb2RlbENvbmZpZyhjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5hcmNoaXRlY3R1cmUgPT09ICdSZXNOZXQ1MCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9hZFJlc05ldChjb25maWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5hcmNoaXRlY3R1cmUgPT09ICdNb2JpbGVOZXRWMScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9hZE1vYmlsZU5ldChjb25maWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIG1ldGhvZCBjb3BpZWQgZnJvbSBiR2x1ciBpbiBodHRwczovL2NvZGVwZW4uaW8vemhhb2p1bi9wZW4velptUlFlXG5mdW5jdGlvbiBjcHVCbHVyKGNhbnZhcywgaW1hZ2UsIGJsdXIpIHtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGRlbHRhID0gNTtcbiAgICB2YXIgYWxwaGFMZWZ0ID0gMSAvICgyICogTWF0aC5QSSAqIGRlbHRhICogZGVsdGEpO1xuICAgIHZhciBzdGVwID0gYmx1ciA8IDMgPyAxIDogMjtcbiAgICBmb3IgKHZhciB5ID0gLWJsdXI7IHkgPD0gYmx1cjsgeSArPSBzdGVwKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAtYmx1cjsgeCA8PSBibHVyOyB4ICs9IHN0ZXApIHtcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBhbHBoYUxlZnQgKiBNYXRoLmV4cCgtKHggKiB4ICsgeSAqIHkpIC8gKDIgKiBkZWx0YSAqIGRlbHRhKSk7XG4gICAgICAgICAgICBzdW0gKz0gd2VpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIHkgPSAtYmx1cjsgeSA8PSBibHVyOyB5ICs9IHN0ZXApIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IC1ibHVyOyB4IDw9IGJsdXI7IHggKz0gc3RlcCkge1xuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gYWxwaGFMZWZ0ICpcbiAgICAgICAgICAgICAgICBNYXRoLmV4cCgtKHggKiB4ICsgeSAqIHkpIC8gKDIgKiBkZWx0YSAqIGRlbHRhKSkgLyBzdW0gKiBibHVyO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xudmFyIG9mZlNjcmVlbkNhbnZhc2VzID0ge307XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gKC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2FtZURpbWVuc2lvbnMoX2EsIF9iLCBuYW1lQSwgbmFtZUIpIHtcbiAgICB2YXIgd2lkdGhBID0gX2Eud2lkdGgsIGhlaWdodEEgPSBfYS5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoQiA9IF9iLndpZHRoLCBoZWlnaHRCID0gX2IuaGVpZ2h0O1xuICAgIGlmICh3aWR0aEEgIT09IHdpZHRoQiB8fCBoZWlnaHRBICE9PSBoZWlnaHRCKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImVycm9yOiBkaW1lbnNpb25zIG11c3QgbWF0Y2guIFwiLmNvbmNhdChuYW1lQSwgXCIgaGFzIGRpbWVuc2lvbnMgXCIpLmNvbmNhdCh3aWR0aEEsIFwieFwiKS5jb25jYXQoaGVpZ2h0QSwgXCIsIFwiKS5jb25jYXQobmFtZUIsIFwiIGhhcyBkaW1lbnNpb25zIFwiKS5jb25jYXQod2lkdGhCLCBcInhcIikuY29uY2F0KGhlaWdodEIpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbGlwQ2FudmFzSG9yaXpvbnRhbChjYW52YXMpIHtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICBjdHgudHJhbnNsYXRlKC1jYW52YXMud2lkdGgsIDApO1xufVxuZnVuY3Rpb24gZHJhd1dpdGhDb21wb3NpdGluZyhjdHgsIGltYWdlLCBjb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xufVxuZnVuY3Rpb24gY3JlYXRlT2ZmU2NyZWVuQ2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgYSBjYW52YXMgaW4gdGhpcyBjb250ZXh0Jyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5zdXJlT2Zmc2NyZWVuQ2FudmFzQ3JlYXRlZChpZCkge1xuICAgIGlmICghb2ZmU2NyZWVuQ2FudmFzZXNbaWRdKSB7XG4gICAgICAgIG9mZlNjcmVlbkNhbnZhc2VzW2lkXSA9IGNyZWF0ZU9mZlNjcmVlbkNhbnZhcygpO1xuICAgIH1cbiAgICByZXR1cm4gb2ZmU2NyZWVuQ2FudmFzZXNbaWRdO1xufVxuZnVuY3Rpb24gZHJhd0FuZEJsdXJJbWFnZU9uQ2FudmFzKGltYWdlLCBibHVyQW1vdW50LCBjYW52YXMpIHtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0LCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgICBjcHVCbHVyKGNhbnZhcywgaW1hZ2UsIGJsdXJBbW91bnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bm8tYW55XG4gICAgICAgIGN0eC5maWx0ZXIgPSBcImJsdXIoXCIuY29uY2F0KGJsdXJBbW91bnQsIFwicHgpXCIpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdBbmRCbHVySW1hZ2VPbk9mZlNjcmVlbkNhbnZhcyhpbWFnZSwgYmx1ckFtb3VudCwgb2Zmc2NyZWVuQ2FudmFzTmFtZSkge1xuICAgIHZhciBjYW52YXMgPSBlbnN1cmVPZmZzY3JlZW5DYW52YXNDcmVhdGVkKG9mZnNjcmVlbkNhbnZhc05hbWUpO1xuICAgIGlmIChibHVyQW1vdW50ID09PSAwKSB7XG4gICAgICAgIHJlbmRlckltYWdlVG9DYW52YXMoaW1hZ2UsIGNhbnZhcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkcmF3QW5kQmx1ckltYWdlT25DYW52YXMoaW1hZ2UsIGJsdXJBbW91bnQsIGNhbnZhcyk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5mdW5jdGlvbiByZW5kZXJJbWFnZVRvQ2FudmFzKGltYWdlLCBjYW52YXMpIHtcbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCwgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xufVxuLyoqXG4gKiBEcmF3IGFuIGltYWdlIG9uIGEgY2FudmFzXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckltYWdlRGF0YVRvQ2FudmFzKGltYWdlLCBjYW52YXMpIHtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckltYWdlRGF0YVRvT2ZmU2NyZWVuQ2FudmFzKGltYWdlLCBjYW52YXNOYW1lKSB7XG4gICAgdmFyIGNhbnZhcyA9IGVuc3VyZU9mZnNjcmVlbkNhbnZhc0NyZWF0ZWQoY2FudmFzTmFtZSk7XG4gICAgcmVuZGVySW1hZ2VEYXRhVG9DYW52YXMoaW1hZ2UsIGNhbnZhcyk7XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cbi8qKlxuICogR2l2ZW4gdGhlIG91dHB1dCBmcm9tIGVzdGltYXRpbmcgbXVsdGktcGVyc29uIHNlZ21lbnRhdGlvbiwgZ2VuZXJhdGVzIGFuXG4gKiBpbWFnZSB3aXRoIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgYXQgZWFjaCBwaXhlbCBkZXRlcm1pbmVkIGJ5IHRoZVxuICogY29ycmVzcG9uZGluZyBiaW5hcnkgc2VnbWVudGF0aW9uIHZhbHVlIGF0IHRoZSBwaXhlbCBmcm9tIHRoZSBvdXRwdXQuICBJblxuICogb3RoZXIgd29yZHMsIHBpeGVscyB3aGVyZSB0aGVyZSBpcyBhIHBlcnNvbiB3aWxsIGJlIGNvbG9yZWQgd2l0aCBmb3JlZ3JvdW5kXG4gKiBjb2xvciBhbmQgd2hlcmUgdGhlcmUgaXMgbm90IGEgcGVyc29uIHdpbGwgYmUgY29sb3JlZCB3aXRoIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogQHBhcmFtIHBlcnNvbk9yUGFydFNlZ21lbnRhdGlvbiBUaGUgb3V0cHV0IGZyb21cbiAqIGBzZWdtZW50UGVyc29uYCwgYHNlZ21lbnRNdWx0aVBlcnNvbmAsXG4gKiBgc2VnbWVudFBlcnNvblBhcnRzYCBvciBgc2VnbWVudE11bHRpUGVyc29uUGFydHNgLiBUaGV5IGNhblxuICogYmUgU2VtYW50aWNQZXJzb25TZWdtZW50YXRpb24gb2JqZWN0LCBhbiBhcnJheSBvZiBQZXJzb25TZWdtZW50YXRpb24gb2JqZWN0LFxuICogU2VtYW50aWNQYXJ0U2VnbWVudGF0aW9uIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgUGFydFNlZ21lbnRhdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIGZvcmVncm91bmQgRGVmYXVsdCB0byB7cjowLCBnOjAsIGI6MCwgYTogMH0uIFRoZSBmb3JlZ3JvdW5kIGNvbG9yXG4gKiAocixnLGIsYSkgZm9yIHZpc3VhbGl6aW5nIHBpeGVscyB0aGF0IGJlbG9uZyB0byBwZW9wbGUuXG4gKlxuICogQHBhcmFtIGJhY2tncm91bmQgRGVmYXVsdCB0byB7cjowLCBnOjAsIGI6MCwgYTogMjU1fS4gVGhlIGJhY2tncm91bmQgY29sb3JcbiAqIChyLGcsYixhKSBmb3IgdmlzdWFsaXppbmcgcGl4ZWxzIHRoYXQgZG9uJ3QgYmVsb25nIHRvIHBlb3BsZS5cbiAqXG4gKiBAcGFyYW0gZHJhd0NvbnRvdXIgRGVmYXVsdCB0byBmYWxzZS4gV2hldGhlciB0byBkcmF3IHRoZSBjb250b3VyIGFyb3VuZCBlYWNoXG4gKiBwZXJzb24ncyBzZWdtZW50YXRpb24gbWFzayBvciBib2R5IHBhcnQgbWFzay5cbiAqXG4gKiBAcGFyYW0gZm9yZWdyb3VuZElkcyBEZWZhdWx0IHRvIFsxXS4gVGhlIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50XG4gKiBmb3JlZ3JvdW5kLiBGb3IgcGVyc29uIHNlZ21lbnRhdGlvbiwgMSBpcyB0aGUgZm9yZWdyb3VuZC4gRm9yIGJvZHkgcGFydFxuICogc2VnbWVudGF0aW9uLCBpdCBjYW4gYmUgYSBzdWJzZXQgb2YgYWxsIGJvZHkgcGFydHMgaWRzLlxuICpcbiAqIEByZXR1cm5zIEFuIEltYWdlRGF0YSB3aXRoIHRoZSBzYW1lIHdpZHRoIGFuZCBoZWlnaHQgb2ZcbiAqIGFsbCB0aGUgUGVyc29uU2VnbWVudGF0aW9uIGluIG11bHRpUGVyc29uU2VnbWVudGF0aW9uLCB3aXRoIG9wYWNpdHkgYW5kXG4gKiB0cmFuc3BhcmVuY3kgYXQgZWFjaCBwaXhlbCBkZXRlcm1pbmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJpbmFyeVxuICogc2VnbWVudGF0aW9uIHZhbHVlIGF0IHRoZSBwaXhlbCBmcm9tIHRoZSBvdXRwdXQuXG4gKi9cbmZ1bmN0aW9uIHRvTWFzayhwZXJzb25PclBhcnRTZWdtZW50YXRpb24sIGZvcmVncm91bmQsIGJhY2tncm91bmQsIGRyYXdDb250b3VyLCBmb3JlZ3JvdW5kSWRzKSB7XG4gICAgaWYgKGZvcmVncm91bmQgPT09IHZvaWQgMCkgeyBmb3JlZ3JvdW5kID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBnOiAwLFxuICAgICAgICBiOiAwLFxuICAgICAgICBhOiAwXG4gICAgfTsgfVxuICAgIGlmIChiYWNrZ3JvdW5kID09PSB2b2lkIDApIHsgYmFja2dyb3VuZCA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgZzogMCxcbiAgICAgICAgYjogMCxcbiAgICAgICAgYTogMjU1XG4gICAgfTsgfVxuICAgIGlmIChkcmF3Q29udG91ciA9PT0gdm9pZCAwKSB7IGRyYXdDb250b3VyID0gZmFsc2U7IH1cbiAgICBpZiAoZm9yZWdyb3VuZElkcyA9PT0gdm9pZCAwKSB7IGZvcmVncm91bmRJZHMgPSBbMV07IH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwZXJzb25PclBhcnRTZWdtZW50YXRpb24pICYmXG4gICAgICAgIHBlcnNvbk9yUGFydFNlZ21lbnRhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtdWx0aVBlcnNvbk9yUGFydFNlZ21lbnRhdGlvbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGVyc29uT3JQYXJ0U2VnbWVudGF0aW9uKSkge1xuICAgICAgICBtdWx0aVBlcnNvbk9yUGFydFNlZ21lbnRhdGlvbiA9IFtwZXJzb25PclBhcnRTZWdtZW50YXRpb25dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbXVsdGlQZXJzb25PclBhcnRTZWdtZW50YXRpb24gPSBwZXJzb25PclBhcnRTZWdtZW50YXRpb247XG4gICAgfVxuICAgIHZhciBfYSA9IG11bHRpUGVyc29uT3JQYXJ0U2VnbWVudGF0aW9uWzBdLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgZnVuY3Rpb24gZHJhd1N0cm9rZShieXRlcywgcm93LCBjb2x1bW4sIHdpZHRoLCByYWRpdXMsIGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0geyByOiAwLCBnOiAyNTUsIGI6IDI1NSwgYTogMjU1IH07IH1cbiAgICAgICAgZm9yICh2YXIgaSA9IC1yYWRpdXM7IGkgPD0gcmFkaXVzOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAtcmFkaXVzOyBqIDw9IHJhZGl1czsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IDAgJiYgaiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IChyb3cgKyBpKSAqIHdpZHRoICsgKGNvbHVtbiArIGopO1xuICAgICAgICAgICAgICAgICAgICBieXRlc1s0ICogbiArIDBdID0gY29sb3IucjtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbNCAqIG4gKyAxXSA9IGNvbG9yLmc7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzWzQgKiBuICsgMl0gPSBjb2xvci5iO1xuICAgICAgICAgICAgICAgICAgICBieXRlc1s0ICogbiArIDNdID0gY29sb3IuYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTZWdtZW50YXRpb25Cb3VuZGFyeShzZWdtZW50YXRpb25EYXRhLCByb3csIGNvbHVtbiwgd2lkdGgsIGZvcmVncm91bmRJZHMsIHJhZGl1cykge1xuICAgICAgICBpZiAoZm9yZWdyb3VuZElkcyA9PT0gdm9pZCAwKSB7IGZvcmVncm91bmRJZHMgPSBbMV07IH1cbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7IHJhZGl1cyA9IDE7IH1cbiAgICAgICAgdmFyIG51bWJlckJhY2tncm91bmRQaXhlbHMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gLXJhZGl1czsgaSA8PSByYWRpdXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSAwICYmIGogIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5fMSA9IChyb3cgKyBpKSAqIHdpZHRoICsgKGNvbHVtbiArIGopO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmVncm91bmRJZHMuc29tZShmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkID09PSBzZWdtZW50YXRpb25EYXRhW25fMV07IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJCYWNrZ3JvdW5kUGl4ZWxzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IC1yYWRpdXM7IGogPD0gcmFkaXVzOyBqKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8yKGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1iZXJCYWNrZ3JvdW5kUGl4ZWxzID4gMDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChqKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGkgKiB3aWR0aCArIGo7XG4gICAgICAgICAgICBieXRlc1s0ICogbiArIDBdID0gYmFja2dyb3VuZC5yO1xuICAgICAgICAgICAgYnl0ZXNbNCAqIG4gKyAxXSA9IGJhY2tncm91bmQuZztcbiAgICAgICAgICAgIGJ5dGVzWzQgKiBuICsgMl0gPSBiYWNrZ3JvdW5kLmI7XG4gICAgICAgICAgICBieXRlc1s0ICogbiArIDNdID0gYmFja2dyb3VuZC5hO1xuICAgICAgICAgICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JlZ3JvdW5kSWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCA9PT0gbXVsdGlQZXJzb25PclBhcnRTZWdtZW50YXRpb25ba10uZGF0YVtuXTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbNCAqIG5dID0gZm9yZWdyb3VuZC5yO1xuICAgICAgICAgICAgICAgICAgICBieXRlc1s0ICogbiArIDFdID0gZm9yZWdyb3VuZC5nO1xuICAgICAgICAgICAgICAgICAgICBieXRlc1s0ICogbiArIDJdID0gZm9yZWdyb3VuZC5iO1xuICAgICAgICAgICAgICAgICAgICBieXRlc1s0ICogbiArIDNdID0gZm9yZWdyb3VuZC5hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNCb3VuZGFyeSA9IGlzU2VnbWVudGF0aW9uQm91bmRhcnkobXVsdGlQZXJzb25PclBhcnRTZWdtZW50YXRpb25ba10uZGF0YSwgaSwgaiwgd2lkdGgsIGZvcmVncm91bmRJZHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhd0NvbnRvdXIgJiYgaSAtIDEgPj0gMCAmJiBpICsgMSA8IGhlaWdodCAmJiBqIC0gMSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBqICsgMSA8IHdpZHRoICYmIGlzQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdTdHJva2UoYnl0ZXMsIGksIGosIHdpZHRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG11bHRpUGVyc29uT3JQYXJ0U2VnbWVudGF0aW9uLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMyhrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW1hZ2VEYXRhKGJ5dGVzLCB3aWR0aCwgaGVpZ2h0KTtcbn1cbnZhciBSQUlOQk9XX1BBUlRfQ09MT1JTID0gW1xuICAgIFsxMTAsIDY0LCAxNzBdLCBbMTQzLCA2MSwgMTc4XSwgWzE3OCwgNjAsIDE3OF0sIFsyMTAsIDYyLCAxNjddLFxuICAgIFsyMzgsIDY3LCAxNDldLCBbMjU1LCA3OCwgMTI1XSwgWzI1NSwgOTQsIDk5XSwgWzI1NSwgMTE1LCA3NV0sXG4gICAgWzI1NSwgMTQwLCA1Nl0sIFsyMzksIDE2NywgNDddLCBbMjE3LCAxOTQsIDQ5XSwgWzE5NCwgMjE5LCA2NF0sXG4gICAgWzE3NSwgMjQwLCA5MV0sIFsxMzUsIDI0NSwgODddLCBbOTYsIDI0NywgOTZdLCBbNjQsIDI0MywgMTE1XSxcbiAgICBbNDAsIDIzNCwgMTQxXSwgWzI4LCAyMTksIDE2OV0sIFsyNiwgMTk5LCAxOTRdLCBbMzMsIDE3NiwgMjEzXSxcbiAgICBbNDcsIDE1MCwgMjI0XSwgWzY1LCAxMjUsIDIyNF0sIFs4NCwgMTAxLCAyMTRdLCBbOTksIDgxLCAxOTVdXG5dO1xuLyoqXG4gKiBHaXZlbiB0aGUgb3V0cHV0IGZyb20gcGVyc29uIGJvZHkgcGFydCBzZWdtZW50YXRpb24gKG9yIG11bHRpLXBlcnNvblxuICogaW5zdGFuY2UgYm9keSBwYXJ0IHNlZ21lbnRhdGlvbikgYW5kIGFuIGFycmF5IG9mIGNvbG9ycyBpbmRleGVkIGJ5IHBhcnQgaWQsXG4gKiBnZW5lcmF0ZXMgYW4gaW1hZ2Ugd2l0aCB0aGUgY29ycmVzcG9uZGluZyBjb2xvciBmb3IgZWFjaCBwYXJ0IGF0IGVhY2ggcGl4ZWwsXG4gKiBhbmQgd2hpdGUgcGl4ZWxzIHdoZXJlIHRoZXJlIGlzIG5vIHBhcnQuXG4gKlxuICogQHBhcmFtIHBhcnRTZWdtZW50YXRpb24gVGhlIG91dHB1dCBmcm9tIHNlZ21lbnRQZXJzb25QYXJ0c1xuICogb3Igc2VnbWVudE11bHRpUGVyc29uUGFydHMuIFRoZSBmb3JtZXIgaXMgYSBTZW1hbnRpY1BhcnRTZWdtZW50YXRpb25cbiAqIG9iamVjdCBhbmQgbGF0ZXIgaXMgYW4gYXJyYXkgb2YgUGFydFNlZ21lbnRhdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHBhcnRDb2xvcnMgQSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBvZiByZ2IgY29sb3JzIGluZGV4ZWQgYnlcbiAqIHBhcnQgaWQuICBNdXN0IGhhdmUgMjQgY29sb3JzLCBvbmUgZm9yIGV2ZXJ5IHBhcnQuXG4gKlxuICogQHJldHVybnMgQW4gSW1hZ2VEYXRhIHdpdGggdGhlIHNhbWUgd2lkdGggYW5kIGhlaWdodCBvZiBhbGwgdGhlIGVsZW1lbnQgaW5cbiAqIG11bHRpUGVyc29uUGFydFNlZ21lbnRhdGlvbiwgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBjb2xvciBmb3IgZWFjaCBwYXJ0IGF0XG4gKiBlYWNoIHBpeGVsLCBhbmQgYmxhY2sgcGl4ZWxzIHdoZXJlIHRoZXJlIGlzIG5vIHBhcnQuXG4gKi9cbmZ1bmN0aW9uIHRvQ29sb3JlZFBhcnRNYXNrKHBhcnRTZWdtZW50YXRpb24sIHBhcnRDb2xvcnMpIHtcbiAgICBpZiAocGFydENvbG9ycyA9PT0gdm9pZCAwKSB7IHBhcnRDb2xvcnMgPSBSQUlOQk9XX1BBUlRfQ09MT1JTOyB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFydFNlZ21lbnRhdGlvbikgJiYgcGFydFNlZ21lbnRhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtdWx0aVBlcnNvblBhcnRTZWdtZW50YXRpb247XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRTZWdtZW50YXRpb24pKSB7XG4gICAgICAgIG11bHRpUGVyc29uUGFydFNlZ21lbnRhdGlvbiA9IFtwYXJ0U2VnbWVudGF0aW9uXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG11bHRpUGVyc29uUGFydFNlZ21lbnRhdGlvbiA9IHBhcnRTZWdtZW50YXRpb247XG4gICAgfVxuICAgIHZhciBfYSA9IG11bHRpUGVyc29uUGFydFNlZ21lbnRhdGlvblswXSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0ICogd2lkdGg7ICsraSkge1xuICAgICAgICAvLyBpbnZlcnQgbWFzay4gIEludmVydCB0aGUgc2VnbWVudGF0aW9uIG1hc2suXG4gICAgICAgIHZhciBqID0gaSAqIDQ7XG4gICAgICAgIGJ5dGVzW2ogKyAwXSA9IDI1NTtcbiAgICAgICAgYnl0ZXNbaiArIDFdID0gMjU1O1xuICAgICAgICBieXRlc1tqICsgMl0gPSAyNTU7XG4gICAgICAgIGJ5dGVzW2ogKyAzXSA9IDI1NTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBtdWx0aVBlcnNvblBhcnRTZWdtZW50YXRpb24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0SWQgPSBtdWx0aVBlcnNvblBhcnRTZWdtZW50YXRpb25ba10uZGF0YVtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0SWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gcGFydENvbG9yc1twYXJ0SWRdO1xuICAgICAgICAgICAgICAgIGlmICghY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29sb3IgY291bGQgYmUgZm91bmQgZm9yIHBhcnQgaWQgXCIuY29uY2F0KHBhcnRJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlc1tqICsgMF0gPSBjb2xvclswXTtcbiAgICAgICAgICAgICAgICBieXRlc1tqICsgMV0gPSBjb2xvclsxXTtcbiAgICAgICAgICAgICAgICBieXRlc1tqICsgMl0gPSBjb2xvclsyXTtcbiAgICAgICAgICAgICAgICBieXRlc1tqICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJbWFnZURhdGEoYnl0ZXMsIHdpZHRoLCBoZWlnaHQpO1xufVxudmFyIENBTlZBU19OQU1FUyA9IHtcbiAgICBibHVycmVkOiAnYmx1cnJlZCcsXG4gICAgYmx1cnJlZE1hc2s6ICdibHVycmVkLW1hc2snLFxuICAgIG1hc2s6ICdtYXNrJyxcbiAgICBsb3dyZXNQYXJ0TWFzazogJ2xvd3Jlcy1wYXJ0LW1hc2snLFxufTtcbi8qKlxuICogR2l2ZW4gYW4gaW1hZ2UgYW5kIGEgbWFza0ltYWdlIG9mIHR5cGUgSW1hZ2VEYXRhLCBkcmF3cyB0aGUgaW1hZ2Ugd2l0aCB0aGVcbiAqIG1hc2sgb24gdG9wIG9mIGl0IG9udG8gYSBjYW52YXMuXG4gKlxuICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIHRvIGJlIGRyYXduIG9udG8uXG4gKlxuICogQHBhcmFtIGltYWdlIFRoZSBvcmlnaW5hbCBpbWFnZSB0byBhcHBseSB0aGUgbWFzayB0by5cbiAqXG4gKiBAcGFyYW0gbWFza0ltYWdlIEFuIEltYWdlRGF0YSBjb250YWluaW5nIHRoZSBtYXNrLiAgSWRlYWxseSB0aGlzIHNob3VsZCBiZVxuICogZ2VuZXJhdGVkIGJ5IHRvTWFzayBvciB0b0NvbG9yZWRQYXJ0TWFzay5cbiAqXG4gKiBAcGFyYW0gbWFza09wYWNpdHkgVGhlIG9wYWNpdHkgb2YgdGhlIG1hc2sgd2hlbiBkcmF3aW5nIGl0IG9uIHRvcCBvZiB0aGVcbiAqIGltYWdlLiBEZWZhdWx0cyB0byAwLjcuIFNob3VsZCBiZSBhIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAqXG4gKiBAcGFyYW0gbWFza0JsdXJBbW91bnQgSG93IG1hbnkgcGl4ZWxzIHRvIGJsdXIgdGhlIG1hc2sgYnkuIERlZmF1bHRzIHRvIDAuXG4gKiBTaG91bGQgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDIwLlxuICpcbiAqIEBwYXJhbSBmbGlwSG9yaXpvbnRhbCBJZiB0aGUgcmVzdWx0IHNob3VsZCBiZSBmbGlwcGVkIGhvcml6b250YWxseS4gIERlZmF1bHRzXG4gKiB0byBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gZHJhd01hc2soY2FudmFzLCBpbWFnZSwgbWFza0ltYWdlLCBtYXNrT3BhY2l0eSwgbWFza0JsdXJBbW91bnQsIGZsaXBIb3Jpem9udGFsKSB7XG4gICAgaWYgKG1hc2tPcGFjaXR5ID09PSB2b2lkIDApIHsgbWFza09wYWNpdHkgPSAwLjc7IH1cbiAgICBpZiAobWFza0JsdXJBbW91bnQgPT09IHZvaWQgMCkgeyBtYXNrQmx1ckFtb3VudCA9IDA7IH1cbiAgICBpZiAoZmxpcEhvcml6b250YWwgPT09IHZvaWQgMCkgeyBmbGlwSG9yaXpvbnRhbCA9IGZhbHNlOyB9XG4gICAgdmFyIF9hID0gZ2V0SW5wdXRTaXplKGltYWdlKSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgZmxpcENhbnZhc0hvcml6b250YWwoY2FudmFzKTtcbiAgICB9XG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gbWFza09wYWNpdHk7XG4gICAgaWYgKG1hc2tJbWFnZSkge1xuICAgICAgICBhc3NlcnRTYW1lRGltZW5zaW9ucyh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgbWFza0ltYWdlLCAnaW1hZ2UnLCAnbWFzaycpO1xuICAgICAgICB2YXIgbWFzayA9IHJlbmRlckltYWdlRGF0YVRvT2ZmU2NyZWVuQ2FudmFzKG1hc2tJbWFnZSwgQ0FOVkFTX05BTUVTLm1hc2spO1xuICAgICAgICB2YXIgYmx1cnJlZE1hc2sgPSBkcmF3QW5kQmx1ckltYWdlT25PZmZTY3JlZW5DYW52YXMobWFzaywgbWFza0JsdXJBbW91bnQsIENBTlZBU19OQU1FUy5ibHVycmVkTWFzayk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYmx1cnJlZE1hc2ssIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBHaXZlbiBhbiBpbWFnZSBhbmQgYSBtYXNrSW1hZ2Ugb2YgdHlwZSBJbWFnZURhdGEsIGRyYXdzIHRoZSBpbWFnZSB3aXRoIHRoZVxuICogcGl4ZWxhdGVkIG1hc2sgb24gdG9wIG9mIGl0IG9udG8gYSBjYW52YXMuXG4gKlxuICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzIHRvIGJlIGRyYXduIG9udG8uXG4gKlxuICogQHBhcmFtIGltYWdlIFRoZSBvcmlnaW5hbCBpbWFnZSB0byBhcHBseSB0aGUgbWFzayB0by5cbiAqXG4gKiBAcGFyYW0gbWFza0ltYWdlIEFuIEltYWdlRGF0YSBjb250YWluaW5nIHRoZSBtYXNrLiAgSWRlYWxseSB0aGlzIHNob3VsZCBiZVxuICogZ2VuZXJhdGVkIGJ5IHRvQ29sb3JlZFBhcnRNYXNrLlxuICpcbiAqIEBwYXJhbSBtYXNrT3BhY2l0eSBUaGUgb3BhY2l0eSBvZiB0aGUgbWFzayB3aGVuIGRyYXdpbmcgaXQgb24gdG9wIG9mIHRoZVxuICogaW1hZ2UuIERlZmF1bHRzIHRvIDAuNy4gU2hvdWxkIGJlIGEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICpcbiAqIEBwYXJhbSBtYXNrQmx1ckFtb3VudCBIb3cgbWFueSBwaXhlbHMgdG8gYmx1ciB0aGUgbWFzayBieS4gRGVmYXVsdHMgdG8gMC5cbiAqIFNob3VsZCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjAuXG4gKlxuICogQHBhcmFtIGZsaXBIb3Jpem9udGFsIElmIHRoZSByZXN1bHQgc2hvdWxkIGJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5LiAgRGVmYXVsdHNcbiAqIHRvIGZhbHNlLlxuICpcbiAqIEBwYXJhbSBwaXhlbENlbGxXaWR0aCBUaGUgd2lkdGggb2YgZWFjaCBwaXhlbCBjZWxsLiBEZWZhdWx0IHRvIDEwIHB4LlxuICovXG5mdW5jdGlvbiBkcmF3UGl4ZWxhdGVkTWFzayhjYW52YXMsIGltYWdlLCBtYXNrSW1hZ2UsIG1hc2tPcGFjaXR5LCBtYXNrQmx1ckFtb3VudCwgZmxpcEhvcml6b250YWwsIHBpeGVsQ2VsbFdpZHRoKSB7XG4gICAgaWYgKG1hc2tPcGFjaXR5ID09PSB2b2lkIDApIHsgbWFza09wYWNpdHkgPSAwLjc7IH1cbiAgICBpZiAobWFza0JsdXJBbW91bnQgPT09IHZvaWQgMCkgeyBtYXNrQmx1ckFtb3VudCA9IDA7IH1cbiAgICBpZiAoZmxpcEhvcml6b250YWwgPT09IHZvaWQgMCkgeyBmbGlwSG9yaXpvbnRhbCA9IGZhbHNlOyB9XG4gICAgaWYgKHBpeGVsQ2VsbFdpZHRoID09PSB2b2lkIDApIHsgcGl4ZWxDZWxsV2lkdGggPSAxMC4wOyB9XG4gICAgdmFyIF9hID0gZ2V0SW5wdXRTaXplKGltYWdlKSwgaGVpZ2h0ID0gX2FbMF0sIHdpZHRoID0gX2FbMV07XG4gICAgYXNzZXJ0U2FtZURpbWVuc2lvbnMoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIG1hc2tJbWFnZSwgJ2ltYWdlJywgJ21hc2snKTtcbiAgICB2YXIgbWFzayA9IHJlbmRlckltYWdlRGF0YVRvT2ZmU2NyZWVuQ2FudmFzKG1hc2tJbWFnZSwgQ0FOVkFTX05BTUVTLm1hc2spO1xuICAgIHZhciBibHVycmVkTWFzayA9IGRyYXdBbmRCbHVySW1hZ2VPbk9mZlNjcmVlbkNhbnZhcyhtYXNrLCBtYXNrQmx1ckFtb3VudCwgQ0FOVkFTX05BTUVTLmJsdXJyZWRNYXNrKTtcbiAgICBjYW52YXMud2lkdGggPSBibHVycmVkTWFzay53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gYmx1cnJlZE1hc2suaGVpZ2h0O1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChmbGlwSG9yaXpvbnRhbCkge1xuICAgICAgICBmbGlwQ2FudmFzSG9yaXpvbnRhbChjYW52YXMpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2NyZWVuQ2FudmFzID0gZW5zdXJlT2Zmc2NyZWVuQ2FudmFzQ3JlYXRlZChDQU5WQVNfTkFNRVMubG93cmVzUGFydE1hc2spO1xuICAgIHZhciBvZmZzY3JlZW5DYW52YXNDdHggPSBvZmZzY3JlZW5DYW52YXNcbiAgICAgICAgLmdldENvbnRleHQoJzJkJyk7XG4gICAgb2Zmc2NyZWVuQ2FudmFzLndpZHRoID0gYmx1cnJlZE1hc2sud2lkdGggKiAoMS4wIC8gcGl4ZWxDZWxsV2lkdGgpO1xuICAgIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQgPSBibHVycmVkTWFzay5oZWlnaHQgKiAoMS4wIC8gcGl4ZWxDZWxsV2lkdGgpO1xuICAgIG9mZnNjcmVlbkNhbnZhc0N0eC5kcmF3SW1hZ2UoYmx1cnJlZE1hc2ssIDAsIDAsIGJsdXJyZWRNYXNrLndpZHRoLCBibHVycmVkTWFzay5oZWlnaHQsIDAsIDAsIG9mZnNjcmVlbkNhbnZhcy53aWR0aCwgb2Zmc2NyZWVuQ2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIGN0eC5kcmF3SW1hZ2Uob2Zmc2NyZWVuQ2FudmFzLCAwLCAwLCBvZmZzY3JlZW5DYW52YXMud2lkdGgsIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgLy8gRHJhd3MgdmVydGljYWwgZ3JpZCBsaW5lcyB0aGF0IGFyZSBgcGl4ZWxDZWxsV2lkdGhgIGFwYXJ0IGZyb20gZWFjaCBvdGhlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNjcmVlbkNhbnZhcy53aWR0aDsgaSsrKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICBjdHgubW92ZVRvKHBpeGVsQ2VsbFdpZHRoICogaSwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8ocGl4ZWxDZWxsV2lkdGggKiBpLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvLyBEcmF3cyBob3Jpem9udGFsIGdyaWQgbGluZXMgdGhhdCBhcmUgYHBpeGVsQ2VsbFdpZHRoYCBhcGFydCBmcm9tIGVhY2hcbiAgICAvLyBvdGhlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQ7IGkrKykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmZmZmJztcbiAgICAgICAgY3R4Lm1vdmVUbygwLCBwaXhlbENlbGxXaWR0aCAqIGkpO1xuICAgICAgICBjdHgubGluZVRvKGNhbnZhcy53aWR0aCwgcGl4ZWxDZWxsV2lkdGggKiBpKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjAgLSBtYXNrT3BhY2l0eTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBibHVycmVkTWFzay53aWR0aCwgYmx1cnJlZE1hc2suaGVpZ2h0KTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGVyc29uTWFzayhtdWx0aVBlcnNvblNlZ21lbnRhdGlvbiwgZWRnZUJsdXJBbW91bnQpIHtcbiAgICB2YXIgYmFja2dyb3VuZE1hc2tJbWFnZSA9IHRvTWFzayhtdWx0aVBlcnNvblNlZ21lbnRhdGlvbiwgeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTUgfSwgeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwIH0pO1xuICAgIHZhciBiYWNrZ3JvdW5kTWFzayA9IHJlbmRlckltYWdlRGF0YVRvT2ZmU2NyZWVuQ2FudmFzKGJhY2tncm91bmRNYXNrSW1hZ2UsIENBTlZBU19OQU1FUy5tYXNrKTtcbiAgICBpZiAoZWRnZUJsdXJBbW91bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhY2tncm91bmRNYXNrO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRyYXdBbmRCbHVySW1hZ2VPbk9mZlNjcmVlbkNhbnZhcyhiYWNrZ3JvdW5kTWFzaywgZWRnZUJsdXJBbW91bnQsIENBTlZBU19OQU1FUy5ibHVycmVkTWFzayk7XG4gICAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIHBlcnNvblNlZ21lbnRhdGlvbiBhbmQgYW4gaW1hZ2UsIGRyYXdzIHRoZSBpbWFnZSB3aXRoIGl0cyBiYWNrZ3JvdW5kXG4gKiBibHVycmVkIG9udG8gdGhlIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgdG8gZHJhdyB0aGUgYmFja2dyb3VuZC1ibHVycmVkIGltYWdlIG9udG8uXG4gKlxuICogQHBhcmFtIGltYWdlIFRoZSBpbWFnZSB0byBibHVyIHRoZSBiYWNrZ3JvdW5kIG9mIGFuZCBkcmF3LlxuICpcbiAqIEBwYXJhbSBwZXJzb25TZWdtZW50YXRpb24gQSBTZW1hbnRpY1BlcnNvblNlZ21lbnRhdGlvbiBvciBhbiBhcnJheSBvZlxuICogUGVyc29uU2VnbWVudGF0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYmFja2dyb3VuZEJsdXJBbW91bnQgSG93IG1hbnkgcGl4ZWxzIGluIHRoZSBiYWNrZ3JvdW5kIGJsZW5kIGludG8gZWFjaFxuICogb3RoZXIuICBEZWZhdWx0cyB0byAzLiBTaG91bGQgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDIwLlxuICpcbiAqIEBwYXJhbSBlZGdlQmx1ckFtb3VudCBIb3cgbWFueSBwaXhlbHMgdG8gYmx1ciBvbiB0aGUgZWRnZSBiZXR3ZWVuIHRoZSBwZXJzb25cbiAqIGFuZCB0aGUgYmFja2dyb3VuZCBieS4gIERlZmF1bHRzIHRvIDMuIFNob3VsZCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgMjAuXG4gKlxuICogQHBhcmFtIGZsaXBIb3Jpem9udGFsIElmIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5LiAgRGVmYXVsdHNcbiAqIHRvIGZhbHNlLlxuICovXG5mdW5jdGlvbiBkcmF3Qm9rZWhFZmZlY3QoY2FudmFzLCBpbWFnZSwgbXVsdGlQZXJzb25TZWdtZW50YXRpb24sIGJhY2tncm91bmRCbHVyQW1vdW50LCBlZGdlQmx1ckFtb3VudCwgZmxpcEhvcml6b250YWwpIHtcbiAgICBpZiAoYmFja2dyb3VuZEJsdXJBbW91bnQgPT09IHZvaWQgMCkgeyBiYWNrZ3JvdW5kQmx1ckFtb3VudCA9IDM7IH1cbiAgICBpZiAoZWRnZUJsdXJBbW91bnQgPT09IHZvaWQgMCkgeyBlZGdlQmx1ckFtb3VudCA9IDM7IH1cbiAgICBpZiAoZmxpcEhvcml6b250YWwgPT09IHZvaWQgMCkgeyBmbGlwSG9yaXpvbnRhbCA9IGZhbHNlOyB9XG4gICAgdmFyIGJsdXJyZWRJbWFnZSA9IGRyYXdBbmRCbHVySW1hZ2VPbk9mZlNjcmVlbkNhbnZhcyhpbWFnZSwgYmFja2dyb3VuZEJsdXJBbW91bnQsIENBTlZBU19OQU1FUy5ibHVycmVkKTtcbiAgICBjYW52YXMud2lkdGggPSBibHVycmVkSW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGJsdXJyZWRJbWFnZS5oZWlnaHQ7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG11bHRpUGVyc29uU2VnbWVudGF0aW9uKSAmJlxuICAgICAgICBtdWx0aVBlcnNvblNlZ21lbnRhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShibHVycmVkSW1hZ2UsIDAsIDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwZXJzb25NYXNrID0gY3JlYXRlUGVyc29uTWFzayhtdWx0aVBlcnNvblNlZ21lbnRhdGlvbiwgZWRnZUJsdXJBbW91bnQpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XG4gICAgICAgIGZsaXBDYW52YXNIb3Jpem9udGFsKGNhbnZhcyk7XG4gICAgfVxuICAgIC8vIGRyYXcgdGhlIG9yaWdpbmFsIGltYWdlIG9uIHRoZSBmaW5hbCBjYW52YXNcbiAgICB2YXIgX2EgPSBnZXRJbnB1dFNpemUoaW1hZ2UpLCBoZWlnaHQgPSBfYVswXSwgd2lkdGggPSBfYVsxXTtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAvLyBcImRlc3RpbmF0aW9uLWluXCIgLSBcIlRoZSBleGlzdGluZyBjYW52YXMgY29udGVudCBpcyBrZXB0IHdoZXJlIGJvdGggdGhlXG4gICAgLy8gbmV3IHNoYXBlIGFuZCBleGlzdGluZyBjYW52YXMgY29udGVudCBvdmVybGFwLiBFdmVyeXRoaW5nIGVsc2UgaXMgbWFkZVxuICAgIC8vIHRyYW5zcGFyZW50LlwiXG4gICAgLy8gY3JvcCB3aGF0J3Mgbm90IHRoZSBwZXJzb24gdXNpbmcgdGhlIG1hc2sgZnJvbSB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICBkcmF3V2l0aENvbXBvc2l0aW5nKGN0eCwgcGVyc29uTWFzaywgJ2Rlc3RpbmF0aW9uLWluJyk7XG4gICAgLy8gXCJkZXN0aW5hdGlvbi1vdmVyXCIgLSBcIlRoZSBleGlzdGluZyBjYW52YXMgY29udGVudCBpcyBrZXB0IHdoZXJlIGJvdGggdGhlXG4gICAgLy8gbmV3IHNoYXBlIGFuZCBleGlzdGluZyBjYW52YXMgY29udGVudCBvdmVybGFwLiBFdmVyeXRoaW5nIGVsc2UgaXMgbWFkZVxuICAgIC8vIHRyYW5zcGFyZW50LlwiXG4gICAgLy8gZHJhdyB0aGUgYmx1cnJlZCBiYWNrZ3JvdW5kIG9uIHRvcCBvZiB0aGUgb3JpZ2luYWwgaW1hZ2Ugd2hlcmUgaXQgZG9lc24ndFxuICAgIC8vIG92ZXJsYXAuXG4gICAgZHJhd1dpdGhDb21wb3NpdGluZyhjdHgsIGJsdXJyZWRJbWFnZSwgJ2Rlc3RpbmF0aW9uLW92ZXInKTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQm9keVBhcnRNYXNrKG11bHRpUGVyc29uUGFydFNlZ21lbnRhdGlvbiwgYm9keVBhcnRJZHNUb01hc2ssIGVkZ2VCbHVyQW1vdW50KSB7XG4gICAgdmFyIGJhY2tncm91bmRNYXNrSW1hZ2UgPSB0b01hc2sobXVsdGlQZXJzb25QYXJ0U2VnbWVudGF0aW9uLCB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDAgfSwgeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTUgfSwgdHJ1ZSwgYm9keVBhcnRJZHNUb01hc2spO1xuICAgIHZhciBiYWNrZ3JvdW5kTWFzayA9IHJlbmRlckltYWdlRGF0YVRvT2ZmU2NyZWVuQ2FudmFzKGJhY2tncm91bmRNYXNrSW1hZ2UsIENBTlZBU19OQU1FUy5tYXNrKTtcbiAgICBpZiAoZWRnZUJsdXJBbW91bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhY2tncm91bmRNYXNrO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRyYXdBbmRCbHVySW1hZ2VPbk9mZlNjcmVlbkNhbnZhcyhiYWNrZ3JvdW5kTWFzaywgZWRnZUJsdXJBbW91bnQsIENBTlZBU19OQU1FUy5ibHVycmVkTWFzayk7XG4gICAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIHBlcnNvblNlZ21lbnRhdGlvbiBhbmQgYW4gaW1hZ2UsIGRyYXdzIHRoZSBpbWFnZSB3aXRoIGl0cyBiYWNrZ3JvdW5kXG4gKiBibHVycmVkIG9udG8gdGhlIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMgdG8gZHJhdyB0aGUgYmFja2dyb3VuZC1ibHVycmVkIGltYWdlIG9udG8uXG4gKlxuICogQHBhcmFtIGltYWdlIFRoZSBpbWFnZSB0byBibHVyIHRoZSBiYWNrZ3JvdW5kIG9mIGFuZCBkcmF3LlxuICpcbiAqIEBwYXJhbSBwYXJ0U2VnbWVudGF0aW9uIEEgU2VtYW50aWNQYXJ0U2VnbWVudGF0aW9uIG9yIGFuIGFycmF5IG9mXG4gKiBQYXJ0U2VnbWVudGF0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYm9keVBhcnRJZHNUb0JsdXIgRGVmYXVsdCB0byBbMCwgMV0gKGxlZnQtZmFjZSBhbmQgcmlnaHQtZmFjZSkuIEFuXG4gKiBhcnJheSBvZiBib2R5IHBhcnQgaWRzIHRvIGJsdXIuIEVhY2ggbXVzdCBiZSBvbmUgb2YgdGhlIDI0IGJvZHkgcGFydCBpZHMuXG4gKlxuICogQHBhcmFtIGJhY2tncm91bmRCbHVyQW1vdW50IEhvdyBtYW55IHBpeGVscyBpbiB0aGUgYmFja2dyb3VuZCBibGVuZCBpbnRvIGVhY2hcbiAqIG90aGVyLiAgRGVmYXVsdHMgdG8gMy4gU2hvdWxkIGJlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCAyMC5cbiAqXG4gKiBAcGFyYW0gZWRnZUJsdXJBbW91bnQgSG93IG1hbnkgcGl4ZWxzIHRvIGJsdXIgb24gdGhlIGVkZ2UgYmV0d2VlbiB0aGUgcGVyc29uXG4gKiBhbmQgdGhlIGJhY2tncm91bmQgYnkuICBEZWZhdWx0cyB0byAzLiBTaG91bGQgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDIwLlxuICpcbiAqIEBwYXJhbSBmbGlwSG9yaXpvbnRhbCBJZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBmbGlwcGVkIGhvcml6b250YWxseS4gIERlZmF1bHRzXG4gKiB0byBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gYmx1ckJvZHlQYXJ0KGNhbnZhcywgaW1hZ2UsIHBhcnRTZWdtZW50YXRpb24sIGJvZHlQYXJ0SWRzVG9CbHVyLCBiYWNrZ3JvdW5kQmx1ckFtb3VudCwgZWRnZUJsdXJBbW91bnQsIGZsaXBIb3Jpem9udGFsKSB7XG4gICAgaWYgKGJvZHlQYXJ0SWRzVG9CbHVyID09PSB2b2lkIDApIHsgYm9keVBhcnRJZHNUb0JsdXIgPSBbMCwgMV07IH1cbiAgICBpZiAoYmFja2dyb3VuZEJsdXJBbW91bnQgPT09IHZvaWQgMCkgeyBiYWNrZ3JvdW5kQmx1ckFtb3VudCA9IDM7IH1cbiAgICBpZiAoZWRnZUJsdXJBbW91bnQgPT09IHZvaWQgMCkgeyBlZGdlQmx1ckFtb3VudCA9IDM7IH1cbiAgICBpZiAoZmxpcEhvcml6b250YWwgPT09IHZvaWQgMCkgeyBmbGlwSG9yaXpvbnRhbCA9IGZhbHNlOyB9XG4gICAgdmFyIGJsdXJyZWRJbWFnZSA9IGRyYXdBbmRCbHVySW1hZ2VPbk9mZlNjcmVlbkNhbnZhcyhpbWFnZSwgYmFja2dyb3VuZEJsdXJBbW91bnQsIENBTlZBU19OQU1FUy5ibHVycmVkKTtcbiAgICBjYW52YXMud2lkdGggPSBibHVycmVkSW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGJsdXJyZWRJbWFnZS5oZWlnaHQ7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnRTZWdtZW50YXRpb24pICYmIHBhcnRTZWdtZW50YXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoYmx1cnJlZEltYWdlLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYm9keVBhcnRNYXNrID0gY3JlYXRlQm9keVBhcnRNYXNrKHBhcnRTZWdtZW50YXRpb24sIGJvZHlQYXJ0SWRzVG9CbHVyLCBlZGdlQmx1ckFtb3VudCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoZmxpcEhvcml6b250YWwpIHtcbiAgICAgICAgZmxpcENhbnZhc0hvcml6b250YWwoY2FudmFzKTtcbiAgICB9XG4gICAgLy8gZHJhdyB0aGUgb3JpZ2luYWwgaW1hZ2Ugb24gdGhlIGZpbmFsIGNhbnZhc1xuICAgIHZhciBfYSA9IGdldElucHV0U2l6ZShpbWFnZSksIGhlaWdodCA9IF9hWzBdLCB3aWR0aCA9IF9hWzFdO1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIFwiZGVzdGluYXRpb24taW5cIiAtIFwiVGhlIGV4aXN0aW5nIGNhbnZhcyBjb250ZW50IGlzIGtlcHQgd2hlcmUgYm90aCB0aGVcbiAgICAvLyBuZXcgc2hhcGUgYW5kIGV4aXN0aW5nIGNhbnZhcyBjb250ZW50IG92ZXJsYXAuIEV2ZXJ5dGhpbmcgZWxzZSBpcyBtYWRlXG4gICAgLy8gdHJhbnNwYXJlbnQuXCJcbiAgICAvLyBjcm9wIHdoYXQncyBub3QgdGhlIHBlcnNvbiB1c2luZyB0aGUgbWFzayBmcm9tIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgIGRyYXdXaXRoQ29tcG9zaXRpbmcoY3R4LCBib2R5UGFydE1hc2ssICdkZXN0aW5hdGlvbi1pbicpO1xuICAgIC8vIFwiZGVzdGluYXRpb24tb3ZlclwiIC0gXCJUaGUgZXhpc3RpbmcgY2FudmFzIGNvbnRlbnQgaXMga2VwdCB3aGVyZSBib3RoIHRoZVxuICAgIC8vIG5ldyBzaGFwZSBhbmQgZXhpc3RpbmcgY2FudmFzIGNvbnRlbnQgb3ZlcmxhcC4gRXZlcnl0aGluZyBlbHNlIGlzIG1hZGVcbiAgICAvLyB0cmFuc3BhcmVudC5cIlxuICAgIC8vIGRyYXcgdGhlIGJsdXJyZWQgYmFja2dyb3VuZCBvbiB0b3Agb2YgdGhlIG9yaWdpbmFsIGltYWdlIHdoZXJlIGl0IGRvZXNuJ3RcbiAgICAvLyBvdmVybGFwLlxuICAgIGRyYXdXaXRoQ29tcG9zaXRpbmcoY3R4LCBibHVycmVkSW1hZ2UsICdkZXN0aW5hdGlvbi1vdmVyJyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciBQQVJUX0NIQU5ORUxTID0gW1xuICAgICdsZWZ0X2ZhY2UnLFxuICAgICdyaWdodF9mYWNlJyxcbiAgICAnbGVmdF91cHBlcl9hcm1fZnJvbnQnLFxuICAgICdsZWZ0X3VwcGVyX2FybV9iYWNrJyxcbiAgICAncmlnaHRfdXBwZXJfYXJtX2Zyb250JyxcbiAgICAncmlnaHRfdXBwZXJfYXJtX2JhY2snLFxuICAgICdsZWZ0X2xvd2VyX2FybV9mcm9udCcsXG4gICAgJ2xlZnRfbG93ZXJfYXJtX2JhY2snLFxuICAgICdyaWdodF9sb3dlcl9hcm1fZnJvbnQnLFxuICAgICdyaWdodF9sb3dlcl9hcm1fYmFjaycsXG4gICAgJ2xlZnRfaGFuZCcsXG4gICAgJ3JpZ2h0X2hhbmQnLFxuICAgICd0b3Jzb19mcm9udCcsXG4gICAgJ3RvcnNvX2JhY2snLFxuICAgICdsZWZ0X3VwcGVyX2xlZ19mcm9udCcsXG4gICAgJ2xlZnRfdXBwZXJfbGVnX2JhY2snLFxuICAgICdyaWdodF91cHBlcl9sZWdfZnJvbnQnLFxuICAgICdyaWdodF91cHBlcl9sZWdfYmFjaycsXG4gICAgJ2xlZnRfbG93ZXJfbGVnX2Zyb250JyxcbiAgICAnbGVmdF9sb3dlcl9sZWdfYmFjaycsXG4gICAgJ3JpZ2h0X2xvd2VyX2xlZ19mcm9udCcsXG4gICAgJ3JpZ2h0X2xvd2VyX2xlZ19iYWNrJyxcbiAgICAnbGVmdF9mZWV0JyxcbiAgICAncmlnaHRfZmVldCdcbl07XG5cbi8qKiBAbGljZW5zZSBTZWUgdGhlIExJQ0VOU0UgZmlsZS4gKi9cbi8vIFRoaXMgY29kZSBpcyBhdXRvLWdlbmVyYXRlZCwgZG8gbm90IG1vZGlmeSB0aGlzIGZpbGUhXG52YXIgdmVyc2lvbiA9ICcyLjIuMSc7XG5cbmV4cG9ydCB7IEJvZHlQaXgsIFBBUlRfQ0hBTk5FTFMsIGJsdXJCb2R5UGFydCwgZHJhd0Jva2VoRWZmZWN0LCBkcmF3TWFzaywgZHJhd1BpeGVsYXRlZE1hc2ssIGZsaXBQb3NlSG9yaXpvbnRhbCwgbG9hZCwgcmVzaXplQW5kUGFkVG8sIHNjYWxlQW5kQ3JvcFRvSW5wdXRUZW5zb3JTaGFwZSwgdG9Db2xvcmVkUGFydE1hc2ssIHRvTWFzaywgdmVyc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9keS1waXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow-models/body-pix/dist/body-pix.esm.js\n");

/***/ })

};
;